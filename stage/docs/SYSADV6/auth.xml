<?Pub UDT _bookmark _target?><?Pub CX solbook(?><chapter id="auth-1"><?Pub Tag atict:info tracking="off" ref="0"?><?Pub Tag atict:user
user="sharonr" fullname="Sharon Veach"?><?Pub Tag atict:user user="kathys"
fullname="Kathy Slattery"?><title>Using Authentication Services (Tasks)</title><highlights><itemizedlist><para>This chapter provides information about how to use Secure RPC to authenticate
a host and a user across an NFS mount. The following is a list of the topics
in this chapter.</para><listitem><para><olink targetptr="auth-2" remap="internal">Overview of Secure RPC</olink></para>
</listitem><listitem><para><olink targetptr="auth-11" remap="internal">Administering Secure RPC (Task
Map)</olink></para>
</listitem>
</itemizedlist>
</highlights><sect1 id="auth-2"><title>Overview of Secure RPC</title><para><indexterm><primary>Secure RPC</primary><secondary>description</secondary></indexterm><indexterm><primary>authentication</primary><secondary>Secure RPC</secondary></indexterm><indexterm><primary>authentication</primary><secondary>name services</secondary></indexterm><indexterm><primary>NIS+ name service</primary><secondary>authentication</secondary></indexterm><indexterm><primary>NIS name service</primary><secondary>authentication</secondary></indexterm><indexterm><primary><literal>AUTH_DES</literal> authentication</primary><see><envar>AUTH_DH</envar> authentication</see></indexterm><indexterm><primary>access</primary><secondary>Secure RPC authentication</secondary></indexterm>Secure
RPC (Remote Procedure Call) protects remote procedures with an authentication
mechanism. The Diffie-Hellman authentication mechanism authenticates both
the host and the user who is making a request for a service. The authentication
mechanism uses Data Encryption Standard (<olink targetptr="glossary-137" remap="internal">DES</olink>)
encryption. Applications that use Secure RPC include NFS and the name services,
NIS and NIS+.</para><sect2 id="auth-3"><title>NFS Services and Secure RPC</title><para><indexterm><primary>authentication</primary><secondary>use with NFS</secondary></indexterm><indexterm><primary>NFS file systems</primary><secondary>authentication</secondary></indexterm><indexterm><primary>file systems</primary><secondary>security</secondary><tertiary>authentication and NFS</tertiary></indexterm><indexterm><primary>file systems</primary><secondary>NFS</secondary></indexterm><indexterm><primary><envar>AUTH_DH</envar> authentication</primary><secondary>and NFS</secondary></indexterm>NFS enables several hosts to share files over the network. Under
the NFS service, a server holds the data and resources for several clients.
The clients have access to the file systems that the server shares with the
clients. Users who are logged in to the client systems can access the file
systems by mounting the file systems from the server. To the user on the client
system, it appears as if the files are local to the client. One of the most
common uses of NFS allows systems to be installed in offices, while storing
all user files in a central location. Some features of the NFS service, such
as the <option>nosuid</option> option to the <command>mount</command> command,
can be used to prohibit the opening of devices and file systems by unauthorized
users.</para><itemizedlist><para><indexterm><primary>Secure NFS</primary></indexterm>The NFS service
uses Secure RPC to authenticate users who make requests over the network.
This process is known as <emphasis>Secure NFS</emphasis>. The Diffie-Hellman
authentication mechanism, <envar>AUTH_DH</envar>, uses DES encryption to ensure
authorized access. The <envar>AUTH_DH</envar> mechanism has also been called <envar>AUTH_DES</envar>. For more information, see the following:</para><listitem><para>To set up and administer Secure NFS, see <olink targetdoc="group-sa" targetptr="rfsadmin-96" remap="external"><citetitle remap="section">Administering the Secure NFS System</citetitle> in <citetitle remap="book">System Administration Guide: Network Services</citetitle></olink>.</para>
</listitem><listitem><para>To set up the NIS+ tables and enter names in the <literal>cred</literal> table,
see <olink targetdoc="sysadv7" remap="external"><citetitle remap="book">System Administration Guide: Naming and Directory Services (NIS+)</citetitle></olink>.</para>
</listitem><listitem><para>For an outline of the transactions that are involved in RPC
authentication, see <olink targetptr="auth-35" remap="internal">Implementation of Diffie-Hellman
Authentication</olink>.</para>
</listitem>
</itemizedlist>
</sect2><sect2 id="auth-52"><title>DES Encryption With Secure NFS</title><indexterm><primary>Data Encryption Standard</primary><see>DES encryption</see>
</indexterm><indexterm><primary>DES encryption</primary><secondary>Secure NFS</secondary>
</indexterm><indexterm><primary>encryption</primary><secondary>DES algorithm</secondary>
</indexterm><para>The Data Encryption Standard (DES) encryption functions use a 56-bit
key to encrypt data. If two credential users or principals know the same DES
key, they can communicate in private by using the key to encipher and decipher
text. DES is a relatively fast encryption mechanism. A DES chip makes the
encryption even faster. However, if the chip is not present, a software implementation
is substituted.</para><para><indexterm><primary>encrypting</primary><secondary>Secure NFS</secondary></indexterm>The risk of using just the DES key is that an intruder can collect
enough cipher-text messages that were encrypted with the same key to be able
to discover the key and decipher the messages. For this reason, security systems
such as Secure NFS need to change the keys frequently.</para>
</sect2><sect2 id="auth-17"><title>Kerberos Authentication</title><para><indexterm><primary>Kerberos authentication</primary><secondary>and Secure RPC</secondary></indexterm><indexterm><primary>Secure RPC</primary><secondary>and Kerberos</secondary></indexterm>Kerberos is an authentication
system that was developed at MIT. Some encryption in Kerberos is based on
DES. Kerberos V4 support is no longer supplied as part of Secure RPC. However,
a client-side and server-side implementation of Kerberos V5, which uses RPCSEC_GSS,
is included with this release. For more information, see <olink targetptr="intro-1" remap="internal">Chapter&nbsp;21, Introduction to the Kerberos Service</olink>.</para>
</sect2><sect2 id="auth-34"><title>Diffie-Hellman Authentication and Secure RPC</title><indexterm><primary>authentication</primary><secondary>DH authentication</secondary>
</indexterm><indexterm><primary>Diffie-Hellman authentication</primary><see>DH authentication</see>
</indexterm><indexterm><primary>DH authentication</primary><secondary>description</secondary>
</indexterm><indexterm><primary>private keys</primary><seealso>secret keys</seealso>
</indexterm><indexterm><primary><literal>cred</literal> database</primary><secondary>DH authentication</secondary>
</indexterm><indexterm><primary>public keys</primary><secondary>DH authentication and</secondary>
</indexterm><indexterm><primary><filename>publickey</filename> map</primary><secondary>DH authentication</secondary>
</indexterm><indexterm><primary>common keys</primary><secondary>DH authentication and</secondary>
</indexterm><para>The Diffie-Hellman (DH) method of authenticating a user is nontrivial
for an intruder to crack. The client and the server have their own private
key, which they use with the public key to devise a common key. The private
key is also known as the <emphasis>secret key</emphasis>. The client and the
server use the common key to communicate with each other. The common key is
encrypted with an agreed-upon encryption function, such as DES.</para><para>Authentication is based on the ability of the sending system to use
the common key to encrypt the current time. Then, the receiving system can
decrypt and check against its current time. The time on the client and the
server must be synchronized. For more information, see <olink targetdoc="group-sa" targetptr="time-20" remap="external"><citetitle remap="section">Managing Network Time Protocol (Tasks)</citetitle> in <citetitle remap="book">System Administration Guide: Network Services</citetitle></olink>.</para><para><indexterm><primary><filename>/etc/publickey</filename> file</primary><secondary>DH authentication and</secondary></indexterm><indexterm><primary>databases</primary><secondary><literal>publickey</literal> for Secure RPC</secondary></indexterm><indexterm><primary>databases</primary><secondary><literal>cred</literal> for Secure RPC</secondary></indexterm>The public keys and private keys are stored
in an NIS or NIS+ database. NIS stores the keys in the <filename>publickey</filename> map.
NIS+ stores the keys in the <literal>cred</literal> table. These files contain
the public key and the private key for all potential users.</para><para><indexterm><primary>NIS+ name service</primary><secondary><filename>cred</filename> table</secondary></indexterm><indexterm><primary><literal>cred</literal> table</primary><secondary>DH authentication and</secondary></indexterm>The system administrator
is responsible for setting up NIS maps or NIS+ tables, and for generating
a public key and a private key for each user. The private key is stored in
encrypted form with the user's password. This process makes the private key
known only to the user.</para><sect3 id="auth-35"><title>Implementation of Diffie-Hellman Authentication</title><indexterm><primary>access</primary><secondary>security</secondary><tertiary>NFS client-server</tertiary>
</indexterm><indexterm><primary>security</primary><secondary>NFS client-server</secondary>
</indexterm><indexterm><primary>NFS file systems</primary><secondary>providing client-server security</secondary>
</indexterm><indexterm><primary>clients</primary><secondary><envar>AUTH_DH</envar> client-server session</secondary>
</indexterm><indexterm><primary>authentication</primary><secondary><envar>AUTH_DH</envar> client-server session</secondary>
</indexterm><indexterm><primary>public key cryptography</primary><secondary><envar>AUTH_DH</envar> client-server session</secondary>
</indexterm><indexterm><primary>security</primary><secondary>DH authentication</secondary>
</indexterm><indexterm><primary>servers</primary><secondary><envar>AUTH_DH</envar> client-server session</secondary>
</indexterm><indexterm><primary>Secure RPC</primary><secondary>implementation of</secondary>
</indexterm><indexterm><primary>administering</primary><secondary>NFS client-server file security</secondary>
</indexterm><para><indexterm><primary>commands</primary><secondary>Secure RPC commands</secondary></indexterm>This section describes the series of transactions in a client-server
session that use Diffie-Hellman authentication (<envar>AUTH_DH</envar>).</para><sect4 id="auth-24"><title>Generating the Public Keys and Secret Keys for
Secure RPC</title><para><indexterm><primary>public key cryptography</primary><secondary>generating keys</secondary><tertiary>using Diffie-Hellman</tertiary></indexterm><indexterm><primary>secret keys</primary><secondary>generating for Secure RPC</secondary></indexterm><indexterm><primary>generating</primary><secondary>NFS secret keys</secondary></indexterm><indexterm><primary>changing</primary><secondary>NFS secret keys</secondary></indexterm><indexterm><primary>databases</primary><secondary>NFS secret keys</secondary></indexterm><indexterm><primary>decrypting</primary><secondary>NFS secret keys</secondary></indexterm><indexterm><primary><command>newkey</command> command</primary><secondary>generating keys</secondary></indexterm><indexterm><primary><command>nisaddcred</command> command</primary><secondary>generating keys</secondary></indexterm><indexterm><primary>public key cryptography</primary><secondary>NFS secret keys</secondary></indexterm><indexterm><primary>public key cryptography</primary><secondary>database of public keys for Secure RPC</secondary></indexterm><indexterm><primary><command>chkey</command> command</primary></indexterm><indexterm><primary>public key cryptography</primary><secondary>changing NFS public keys and secret keys</secondary></indexterm>Sometime prior to a
transaction, the administrator runs either the <command>newkey</command> or
the <command>nisaddcred</command> command to generate a public key and a secret
key. Each user has a unique public key and secret key. The public key is stored
in a public database. The secret key is stored in encrypted form in the same
database. The <command>chkey</command> command changes the key pair.</para>
</sect4><sect4 id="auth-19"><title>Running the <command>keylogin</command> Command
for Secure RPC</title><indexterm><primary>decrypting</primary><secondary>secret keys</secondary>
</indexterm><indexterm><primary>passwords</primary><secondary>secret-key decryption for Secure RPC</secondary>
</indexterm><indexterm><primary>logging in</primary><secondary>and <envar>AUTH_DH</envar></secondary>
</indexterm><para>Normally, the login password is identical to the Secure RPC password.
In this case, the <command>keylogin</command> command is not required. However,
if the passwords are different, the users have to log in and then run the <command>keylogin</command> command.</para><para><indexterm><primary>keyserver</primary><secondary>description</secondary></indexterm><indexterm><primary><command>keylogin</command> command</primary><secondary>use for Secure RPC</secondary></indexterm><indexterm><primary>Secure RPC</primary><secondary>keyserver</secondary></indexterm>The <command>keylogin</command> command
prompts the user for a Secure RPC password. The command then uses the password
to decrypt the secret key. The <command>keylogin</command> command then passes
the decrypted secret key to the <emphasis>keyserver</emphasis> program. The
keyserver is an RPC service with a local instance on every computer. The keyserver
saves the decrypted secret key and waits for the user to initiate a Secure
RPC transaction with a server.</para><para>If both the login password and the RPC password are the same, the login
process passes the secret key to the keyserver. If the passwords are required
to be different, then the user must always run the <command>keylogin</command> command.
When the <command>keylogin</command> command is included in the user's environment
configuration file, such as the <filename>~/.login</filename>, <filename>~/.cshrc</filename>, or <filename>~/.profile</filename> file, the <command>keylogin</command> command
runs automatically whenever the user logs in.</para>
</sect4><sect4 id="auth-20"><title>Generating the Conversation Key for Secure RPC</title><orderedlist><para><indexterm><primary>conversation keys</primary><secondary>generating in secure RPC</secondary></indexterm><indexterm><primary>public key cryptography</primary><secondary>generating keys</secondary><tertiary>conversation keys for Secure NFS</tertiary></indexterm>When the user initiates a transaction with a server,
the following occurs:</para><listitem><para>The keyserver randomly generates a conversation key.</para>
</listitem><listitem><para>The kernel uses the conversation key, plus other material,
to encrypt the client's timestamp.</para>
</listitem><listitem><para>The keyserver looks up the server's public key in the public
key database. For more information, see the <olink targetdoc="group-refman" targetptr="publickey-4" remap="external"><citerefentry><refentrytitle>publickey</refentrytitle><manvolnum>4</manvolnum></citerefentry></olink> man page.</para>
</listitem><listitem><para>The keyserver uses the client's secret key and the server's
public key to create a common key.</para>
</listitem><listitem><para>The keyserver encrypts the conversation key with the common
key.</para>
</listitem>
</orderedlist>
</sect4><sect4 id="auth-22"><title>Initially Contacting the Server in Secure RPC</title><itemizedlist><para>The transmission, which includes the encrypted timestamp and the encrypted
conversation key, is then sent to the server. The transmission includes a
credential and a verifier. The credential contains three components:</para><listitem><para>The client's network name</para>
</listitem><listitem><para>The conversation key, which is encrypted with the common key</para>
</listitem><listitem><para>A &ldquo;window,&rdquo; which is encrypted with the conversation
key</para>
</listitem>
</itemizedlist><para><indexterm><primary>credential</primary><secondary>description</secondary></indexterm>The window is the difference in time that the client says should
be allowed between the server's clock and the client's timestamp. If the difference
between the server's clock and the timestamp is greater than the window, the
server rejects the client's request. Under normal circumstances, this rejection
does not happen, because the client first synchronizes with the server before
starting the RPC session.</para><itemizedlist><para><indexterm><primary>verifiers</primary><secondary>description</secondary></indexterm>The client's verifier contains the following:</para><listitem><para>The encrypted timestamp</para>
</listitem><listitem><para>An encrypted verifier of the specified window, which is decremented
by 1</para>
</listitem>
</itemizedlist><para><indexterm><primary>verifiers</primary><secondary>window</secondary></indexterm><indexterm><primary>window verifier</primary></indexterm>The window
verifier is needed in case somebody wants to impersonate a user. The impersonator
can write a program that, instead of filling in the encrypted fields of the
credential and verifier, just inserts random bits. The server decrypts the
conversation key into some random key. The server then uses the key to try
to decrypt the window and the timestamp. The result is random numbers. After
a few thousand trials, however, the random window/timestamp pair is likely
to pass the authentication system. The window verifier lessens the chance
that a fake credential could be authenticated.</para>
</sect4><sect4 id="auth-23"><title>Decrypting the Conversation Key in Secure RPC</title><indexterm><primary>conversation keys</primary><secondary>decrypting in secure RPC</secondary>
</indexterm><indexterm><primary>decrypting</primary><secondary>conversation keys for Secure RPC</secondary>
</indexterm><orderedlist><para>When the server receives the transmission from the client, the following
occurs:</para><listitem><para>The keyserver that is local to the server looks up the client's
public key in the public key database.</para>
</listitem><listitem><para><indexterm><primary>common keys</primary><secondary>calculating</secondary></indexterm><indexterm><primary>public key cryptography</primary><secondary>common keys</secondary><tertiary>calculation</tertiary></indexterm>The keyserver
uses the client's public key and the server's secret key to deduce the common
key. The common key is the same common key that is computed by the client.
Only the server and the client can calculate the common key because the calculation
requires knowing one of the secret keys.</para>
</listitem><listitem><para>The kernel uses the common key to decrypt the conversation
key.</para>
</listitem><listitem><para>The kernel calls the keyserver to decrypt the client's timestamp
with the decrypted conversation key.</para>
</listitem>
</orderedlist>
</sect4><sect4 id="auth-33"><title>Storing Information on the Server in Secure RPC</title><itemizedlist><para><indexterm><primary><literal>cred</literal> table</primary><secondary>information stored by server</secondary></indexterm>After the server decrypts the client's
timestamp, the server stores four items of information in a credential table:</para><listitem><para>The client's computer name </para>
</listitem><listitem><para>The conversation key </para>
</listitem><listitem><para>The window </para>
</listitem><listitem><para>The client's timestamp </para>
</listitem>
</itemizedlist><para><indexterm><primary>replayed transactions</primary></indexterm>The server
stores the first three items for future use. The server stores the client's
timestamp to protect against replays. The server accepts only timestamps that
are chronologically greater than the last timestamp seen. As a result, any
replayed transactions are guaranteed to be rejected.</para><note><para><indexterm><primary>remote logins</primary><secondary>security and</secondary></indexterm>Implicit in these transactions is the name of the
caller, who must be authenticated in some manner. The keyserver cannot use
DES authentication to authenticate the caller because the use of DES by the
keyserver would create a deadlock. To avoid a deadlock, the keyserver stores
the secret keys by user ID (UID) and grants requests only to local <literal>root</literal> processes.</para>
</note>
</sect4><sect4 id="auth-25"><title>Returning the Verifier to the Client in Secure
RPC</title><itemizedlist><para><indexterm><primary>verifiers</primary><secondary>returned to NFS client</secondary></indexterm>The server returns a verifier to the client, which includes the
following:</para><listitem><para>The index ID, which the server records in its credential cache</para>
</listitem><listitem><para>The client's timestamp minus 1, which is encrypted by the
conversation key </para>
</listitem>
</itemizedlist><para>The reason for subtracting 1 from the client's timestamp is to ensure
that the timestamp is out of date. An out-of-date timestamp cannot be reused
as a client verifier.</para>
</sect4><sect4 id="auth-26"><title>Authenticating the Server in Secure RPC</title><para>The client receives the verifier and authenticates the server. The client
knows that only the server could have sent the verifier because only the server
knows what timestamp the client sent.</para>
</sect4><sect4 id="auth-27"><title>Handling Transactions in Secure RPC</title><para>With every transaction after the first transaction, the client returns
the index ID to the server in its next transaction. The client also sends
another encrypted timestamp. The server sends back the client's timestamp
minus 1, which is encrypted by the conversation key.</para>
</sect4>
</sect3>
</sect2>
</sect1><sect1 id="auth-11"><title>Administering Secure RPC (Task Map)</title><indexterm><primary>task maps</primary><secondary>administering Secure RPC</secondary>
</indexterm><indexterm><primary>administering</primary><secondary>Secure RPC task map</secondary>
</indexterm><para>The following task map points to procedures that configure Secure RPC
for NIS, NIS+, and NFS.</para><informaltable frame="all" pgwide="1"><tgroup cols="3" colsep="1" rowsep="1"><colspec colname="colspec0" colwidth="80.80*"/><colspec colname="col2" colwidth="151.20*"/><colspec colname="colspec1" colwidth="164.01*"/><thead><row><entry><para>Task</para>
</entry><entry><para>Description</para>
</entry><entry><para>For Instructions</para>
</entry>
</row>
</thead><tbody><row><entry><para>1. Start the keyserver.</para>
</entry><entry><para>Ensures that keys can be created so that users can be authenticated.</para>
</entry><entry><para><olink targetptr="auth-37" remap="internal">How to Restart the Secure RPC Keyserver</olink></para>
</entry>
</row><row><entry><para>2. Set up credentials on an NIS+ host.</para>
</entry><entry><para>Ensures that the <literal>root</literal> user on a host can be authenticated
in an NIS+ environment.</para>
</entry><entry><para><olink targetptr="auth-38" remap="internal">How to Set Up a Diffie-Hellman Key for an
NIS+ Host</olink></para>
</entry>
</row><row><entry><para>3. Give an NIS+ user a key.</para>
</entry><entry><para>Enables a user to be authenticated in an NIS+ environment.</para>
</entry><entry><para><olink targetptr="auth-4" remap="internal">How to Set Up a Diffie-Hellman Key for an
NIS+ User</olink></para>
</entry>
</row><row><entry><para>4. Set up credentials on an NIS host.</para>
</entry><entry><para>Ensures that the <literal>root</literal> user on a host can be authenticated
in an NIS environment.</para>
</entry><entry><para><olink targetptr="auth-39" remap="internal">How to Set Up a Diffie-Hellman Key for an
NIS Host</olink></para>
</entry>
</row><row><entry><para>5. Give an NIS user a key.</para>
</entry><entry><para>Enables a user to be authenticated in an NIS environment.</para>
</entry><entry><para><olink targetptr="auth-5" remap="internal">How to Set Up a Diffie-Hellman Key for an
NIS User</olink></para>
</entry>
</row><row><entry><para>6. Share NFS files with authentication.</para>
</entry><entry><para>Enables an NFS server to securely protect shared file systems using
authentication.</para>
</entry><entry><para><olink targetptr="auth-41" remap="internal">How to Share NFS Files With Diffie-Hellman
Authentication</olink></para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</sect1><sect1 id="auth-36"><title>Administering Authentication With Secure RPC</title><para><indexterm><primary>adding</primary><secondary>DH authentication to mounted file systems</secondary></indexterm>By requiring authentication for
use of mounted NFS file systems, you increase the security of your network. </para><task id="auth-37"><title>How to Restart the Secure RPC Keyserver</title><indexterm><primary>starting</primary><secondary>Secure RPC keyserver</secondary>
</indexterm><indexterm><primary>keyserver</primary><secondary>starting</secondary>
</indexterm><indexterm><primary>daemons</primary><secondary><command>keyserv</command></secondary>
</indexterm><indexterm><primary><command>keyserv</command> daemon</primary>
</indexterm><procedure>&rolePAstep;<step><para><indexterm><primary>service management facility</primary><secondary>enabling keyserver</secondary></indexterm><indexterm><primary><command>svcs</command> command</primary><secondary>listing keyserver service</secondary></indexterm>Verify
that the <command>keyserv</command> daemon is running.</para><screen># <userinput>svcs \*keyserv\*</userinput>
STATE    STIME   FMRI
disabled Dec_14  svc:/network/rpc/keyserv</screen>
</step><step><para><indexterm><primary><command>svcadm</command> command</primary><secondary>enabling keyserver daemon</secondary></indexterm>Enable the keyserver
service if the service is not online.</para><screen># <userinput>svcadm enable network/rpc/keyserv</userinput></screen>
</step>
</procedure>
</task><task id="auth-38"><title>How to Set Up a Diffie-Hellman Key for an NIS+ Host</title><indexterm><primary>configuring</primary><secondary>DH key in NIS+</secondary>
</indexterm><indexterm><primary>DH authentication</primary><secondary>configuring in NIS+</secondary>
</indexterm><indexterm><primary>adding</primary><secondary>keys for DH authentication</secondary>
</indexterm><indexterm><primary><literal>mech_dh</literal> mechanism</primary><secondary>secure RPC</secondary>
</indexterm><indexterm><primary>GSS-API</primary><secondary>credentials in secure RPC</secondary>
</indexterm><tasksummary><para>This procedure should be done on every host in the NIS+ domain. After <literal>root</literal> has run the <command>keylogin</command> command, the server
has GSS-API acceptor credentials for <literal>mech_dh</literal> and the client
has GSS-API initiator credentials.</para><para>For a detailed description of NIS+ security, see <olink targetdoc="sysadv7" remap="external"><citetitle remap="book">System Administration Guide: Naming and Directory Services (NIS+)</citetitle></olink>.</para>
</tasksummary><procedure>&rolePAstep;<step><para>Enable the <literal>publickey</literal> table in the name service.</para><para>Add the following line to the <filename>/etc/nsswitch.conf</filename> file:</para><screen>publickey: nisplus</screen>
</step><step><para>Initialize the NIS+ client.</para><screen># <userinput>nisinit -cH</userinput> <replaceable>hostname</replaceable></screen><para>where <replaceable>hostname</replaceable> is the name of a trusted NIS+
server that contains an entry in its tables for the client system.</para>
</step><step><para><indexterm><primary>databases</primary><secondary><literal>cred</literal> for Secure RPC</secondary></indexterm><indexterm><primary><literal>cred</literal> database</primary><secondary>adding client credential</secondary></indexterm><indexterm><primary><command>nisaddcred</command> command</primary><secondary>adding client credential</secondary></indexterm>Add the client to the <literal>cred</literal> table.</para><para>Type the following commands: </para><screen># <userinput>nisaddcred local</userinput>
# <userinput>nisaddcred des</userinput></screen>
</step><step><para>Verify the setup by using the <command>keylogin</command> command.</para><para><indexterm><primary><command>keylogin</command> command</primary><secondary>verifying DH authentication setup</secondary></indexterm>If you
are prompted for a password, the procedure has succeeded.</para><screen># <userinput>keylogin</userinput>
Password:</screen>
</step>
</procedure><example id="auth-21"><title>Setting Up a New Key for <literal>root</literal> on an NIS+ Client</title><para><indexterm><primary>DH authentication</primary><secondary>for NIS+ client</secondary></indexterm>The following example uses the host <literal>pluto</literal> to
set up <literal>earth</literal> as an NIS+ client. You can ignore the warnings.
The <command>keylogin</command> command is accepted, verifying that <literal>earth</literal> is correctly set up as a secure NIS+ client.</para><screen># <userinput>nisinit -cH pluto</userinput>
NIS Server/Client setup utility.
This system is in the example.com. directory.
Setting up NIS+ client ...
All done.
# <userinput>nisaddcred local</userinput>
# <userinput>nisaddcred des</userinput> 
DES principal name : unix.earth@example.com
Adding new key for unix.earth@example.com (earth.example.com.)
Network password:<lineannotation>&lt;Type password&gt;</lineannotation>
Warning, password differs from login password.
Retype password: <lineannotation>&lt;Retype password&gt;</lineannotation>
# <userinput>keylogin</userinput>
Password:        <lineannotation>&lt;Type password&gt;</lineannotation>
#</screen>
</example>
</task><task id="auth-4"><title>How to Set Up a Diffie-Hellman Key for an NIS+ User</title><indexterm><primary>configuring</primary><secondary>DH key for NIS+ user</secondary>
</indexterm><tasksummary><para>This procedure should be done on every user in the NIS+ domain.</para>
</tasksummary><procedure>&rolePAstep;<step><para><indexterm><primary><literal>cred</literal> database</primary><secondary>adding user credential</secondary></indexterm><indexterm><primary>NIS+ name service</primary><secondary><literal>cred</literal> database</secondary></indexterm>Add the user to the <literal>cred</literal> table on the root
master server.</para><para>Type the following command:</para><screen># <userinput>nisaddcred -p unix.</userinput><replaceable>UID</replaceable>@<replaceable>domain-name</replaceable> <userinput>-P</userinput> <replaceable>username</replaceable>.<replaceable>domain-name</replaceable>. <userinput>des</userinput></screen><para>Note that, in this case, the <emphasis>username.domain-name</emphasis> must
end with a dot (<literal>.</literal>).</para>
</step><step><para>Verify the setup by logging in as the client and typing the <command>keylogin</command> command.</para>
</step>
</procedure><example id="auth-31"><title>Setting Up a New Key for an NIS+ User</title><indexterm><primary>NIS+ name service</primary><secondary>adding authenticated user</secondary>
</indexterm><para>In the following example, a key for Diffie-Hellman authentication is
given to the user <literal>jdoe</literal>.</para><screen># <userinput>nisaddcred -p unix.1234@example.com -P jdoe.example.com. des</userinput>
DES principal name : unix.1234@example.com
Adding new key for unix.1234@example.com (jdoe.example.com.)
Password:       <lineannotation>&lt;Type password&gt;</lineannotation>
Retype password:<lineannotation>&lt;Retype password&gt;</lineannotation>
# <userinput>rlogin rootmaster -l jdoe</userinput>
% <userinput>keylogin</userinput>
Password:       <lineannotation>&lt;Type password&gt;</lineannotation>
%</screen>
</example>
</task><task id="auth-39"><title>How to Set Up a Diffie-Hellman Key for an NIS Host</title><indexterm><primary>configuring</primary><secondary>DH key in NIS</secondary>
</indexterm><indexterm><primary>DH authentication</primary><secondary>configuring in NIS</secondary>
</indexterm><indexterm><primary>DH authentication</primary><secondary>for NIS client</secondary>
</indexterm><tasksummary><para>This procedure should be done on every host in the NIS domain.</para>
</tasksummary><procedure>&rolePAstep;<step><para>Enable the <literal>publickey</literal> map in the name service.</para><para>Add the following line to the <filename>/etc/nsswitch.conf</filename> file:</para><screen>publickey: nis</screen>
</step><step><para><indexterm><primary>computing</primary><secondary>DH key</secondary></indexterm>Create a new key pair by using the <command>newkey</command> command.</para><screen># <userinput>newkey -h</userinput> <replaceable>hostname</replaceable></screen><para>where <replaceable>hostname</replaceable> is the name of the client.</para>
</step>
</procedure><example id="auth-15"><title>Setting Up a New Key for <literal>root</literal> on an NIS Client</title><para>In the following example, <literal>earth</literal> is set up as a secure
NIS client.</para><screen># <userinput>newkey -h earth</userinput>
Adding new key for unix.earth@example.com
New Password:   <lineannotation>&lt;Type password&gt;</lineannotation>
Retype password:<lineannotation>&lt;Retype password&gt;</lineannotation>
Please wait for the database to get updated...
Your new key has been successfully stored away.
#</screen>
</example>
</task><task id="auth-5"><title>How to Set Up a Diffie-Hellman Key for an NIS User</title><indexterm><primary>configuring</primary><secondary>DH key for NIS user</secondary>
</indexterm><indexterm><primary>keys</primary><secondary>creating DH key for NIS user</secondary>
</indexterm><indexterm><primary><command>newkey</command> command</primary><secondary>creating key for NIS user</secondary>
</indexterm><tasksummary><para>This procedure should be done for every user in the NIS domain.</para>
</tasksummary><taskprerequisites><para>Only system administrators, when logged in to the NIS master server,
can generate a new key for a user.</para>
</taskprerequisites><procedure>&rolePAstep;<step><para>Create a new key for a user.</para><screen># <userinput>newkey -u</userinput> <replaceable>username</replaceable></screen><para>where <replaceable>username</replaceable> is the name of the user. The
system prompts for a password. You can type a generic password. The private
key is stored in an encrypted form by using the generic password.</para>
</step><step><para><indexterm><primary>user procedures</primary><secondary>encrypting  NIS user's private key</secondary></indexterm><indexterm><primary>encrypting</primary><secondary>private key of NIS user</secondary></indexterm><indexterm><primary><command>chkey</command> command</primary></indexterm>Tell the user to log in and type
the <command>chkey -p</command> command.</para><para>This command allows users
to re-encrypt their private keys with a password known only to the user.</para><note><para>The <command>chkey</command> command can be used to create a new
key pair for a user.</para>
</note>
</step>
</procedure><example id="auth-12"><title>Setting Up and Encrypting a New User Key in NIS</title><para>In this example, superuser sets up the key.</para><screen># <userinput>newkey -u jdoe</userinput>
Adding new key for unix.12345@example.com
New Password:   <lineannotation>&lt;Type password&gt;</lineannotation>
Retype password:<lineannotation>&lt;Retype password&gt;</lineannotation>
Please wait for the database to get updated...
Your new key has been successfully stored away.
#</screen><para><indexterm><primary>user procedures</primary><secondary><command>chkey</command> command</secondary></indexterm>Then the user <literal>jdoe</literal> re-encrypts
the key with a private password.</para><screen>% <userinput>chkey -p</userinput>
Updating nis publickey database.
Reencrypting key for unix.12345@example.com
Please enter the Secure-RPC password for jdoe:<lineannotation>&lt;Type password&gt;</lineannotation>
Please enter the login password for jdoe:     <lineannotation>&lt;Type password&gt;</lineannotation>
Sending key change request to centralexample...</screen>
</example>
</task><task id="auth-41"><title>How to Share NFS Files With Diffie-Hellman Authentication</title><indexterm><primary>DH authentication</primary><secondary>sharing files with</secondary>
</indexterm><indexterm><primary>files</primary><secondary>sharing with DH authentication</secondary>
</indexterm><indexterm><primary>sharing files</primary><secondary>with DH authentication</secondary>
</indexterm><tasksummary><para>This procedure protects shared file systems on an NFS server by requiring
authentication for access.</para>
</tasksummary><taskprerequisites><itemizedlist><para>Diffie-Hellman public key authentication must be enabled on the network.
To enable authentication on the network, do one of the following:</para><listitem><para><olink targetptr="auth-38" remap="internal">How to Set Up a Diffie-Hellman
Key for an NIS+ Host</olink></para>
</listitem><listitem><para><olink targetptr="auth-39" remap="internal">How to Set Up a Diffie-Hellman
Key for an NIS Host</olink></para>
</listitem>
</itemizedlist>
</taskprerequisites><procedure><step><para>Become superuser or assume a role that includes the System Management
profile.</para><para>The System Administrator role includes the System Management
profile. To create the role and assign the role to a user, see <olink targetptr="rbactask-15" remap="internal">Configuring RBAC (Task Map)</olink>.</para>
</step><step><para><indexterm><primary>NFS file systems</primary><secondary>secure access with <envar>AUTH_DH</envar></secondary></indexterm><indexterm><primary>authentication</primary><secondary>NFS-mounted files</secondary></indexterm>On the NFS server,
share a file system with Diffie-Hellman authentication.</para><screen># <userinput>share -F nfs -o sec=dh /</userinput><replaceable>filesystem</replaceable></screen><para>where <replaceable>filesystem</replaceable> is the file system that
is being shared.</para><para>The <option>o sec=dh</option> option means that <envar>AUTH_DH</envar> authentication is now required to access the file system.</para>
</step><step><para><indexterm><primary>authentication</primary><secondary>NFS-mounted files</secondary></indexterm><indexterm><primary>DH authentication</primary><secondary>mounting files with</secondary></indexterm><indexterm><primary>files</primary><secondary>mounting with DH authentication</secondary></indexterm><indexterm><primary>mounting</primary><secondary>files with DH authentication</secondary></indexterm>On an NFS client, mount a file system with Diffie-Hellman authentication.</para><screen># <userinput>mount -F nfs -o sec=dh</userinput> <replaceable>server:filesystem mount-point</replaceable></screen><variablelist><varlistentry><term><replaceable>server</replaceable></term><listitem><para>Is the name of the system that is sharing <replaceable>filesystem</replaceable></para>
</listitem>
</varlistentry><varlistentry><term><replaceable>filesystem</replaceable></term><listitem><para>Is the name of the file system that is being shared, such
as <filename>opt</filename></para>
</listitem>
</varlistentry><varlistentry><term><replaceable>mount-point</replaceable></term><listitem><para>Is the name of the mount point, such as <filename>/opt</filename></para>
</listitem>
</varlistentry>
</variablelist><para>The <option>o sec=dh</option> option mounts the file system
with <envar>AUTH_DH</envar> authentication.</para>
</step>
</procedure>
</task>
</sect1>
</chapter><?Pub *0000040123 0?>
<chapter id="chapter2-1"><title>Solaris Kernel Tunable Parameters</title><highlights><para>This chapter describes most of the Solaris kernel tunable parameters.</para><itemizedlist><listitem><para><olink targetptr="chapter2-2" remap="internal">General Kernel and Memory Parameters</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-3" remap="internal">fsflush and Related Parameters</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-4" remap="internal">Process-Sizing Parameters</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-10" remap="internal">Paging-Related Parameters</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-123" remap="internal">Swapping-Related Parameters</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-126" remap="internal">Kernel Memory Allocator</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-27" remap="internal">General Driver Parameter</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-29" remap="internal">General I/O Parameters</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-33" remap="internal">General File System Parameters</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-37" remap="internal">UFS Parameters</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-47" remap="internal">TMPFS Parameters</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-50" remap="internal">Pseudo Terminals</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-52" remap="internal">STREAMS Parameters</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-56" remap="internal">System V Message Queues</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-63" remap="internal">System V Semaphores</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-73" remap="internal">System V Shared Memory</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-98" remap="internal">Scheduling</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-82" remap="internal">Timers</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-94" remap="internal">sun4u or sun4v Specific Parameters</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-156" remap="internal">Solaris Volume Manager Parameters</olink></para>
</listitem><listitem><para><olink targetptr="chapter2-164" remap="internal">Network Driver Parameters</olink></para>
</listitem>
</itemizedlist>
</highlights><sect1 id="chapter2-9"><title>Where to Find Tunable Parameter Information</title><informaltable frame="topbot"><tgroup cols="2" colsep="0" rowsep="0"><colspec colname="colspec0" colwidth="50*"/><colspec colname="colspec1" colwidth="50*"/><thead><row rowsep="1"><entry><para>Tunable Parameter</para>
</entry><entry><para>For Information</para>
</entry>
</row>
</thead><tbody><row><entry><para>NFS tunable parameters</para>
</entry><entry><para><olink targetptr="chapter3-1" remap="internal">Chapter&nbsp;3, NFS Tunable Parameters</olink></para>
</entry>
</row><row><entry><para>Internet Protocol Suite tunable parameters</para>
</entry><entry><para><olink targetptr="chapter4-1" remap="internal">Chapter&nbsp;4, Internet Protocol Suite
Tunable Parameters</olink></para>
</entry>
</row><row><entry><para>Network Cache and Accelerator (NCA) tunable parameters</para>
</entry><entry><para><olink targetptr="chapter5-1" remap="internal">Chapter&nbsp;5, Network Cache and Accelerator
Tunable Parameters</olink></para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</sect1><sect1 id="chapter2-2"><title>General Kernel and Memory Parameters</title><para>This section describes general kernel parameters that are related to
physical memory and stack configuration.</para><sect2 id="chapter2-12"><title><literal>physmem</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Modifies the system's configuration of the number of physical
pages of memory after the Solaris OS and firmware are accounted for.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned long</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>Number of usable pages of physical memory available on the
system, not counting the memory where the core kernel and data are stored</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to amount of physical memory on system</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Whenever you want to test the effect of running the system
with less physical memory. Because this parameter does <emphasis>not</emphasis> take
into account the memory used by the core kernel and data, as well as various
other data structures allocated early in the startup process, the value of <literal>physmem</literal> should be less than the actual number of pages that represent
the smaller amount of memory.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="faawu"><title><literal>default_stksize</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the default stack size of all threads. No thread
can be created with a stack size smaller than <literal>default_stksize</literal>.
 If <literal>default_stksize</literal> is set, it overrides <literal>lwp_default_stksize</literal>. See also <olink targetptr="chapter2-118" remap="internal">lwp_default_stksize</olink>.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><itemizedlist><listitem><para>3 x <literal>PAGESIZE</literal> on SPARC systems</para>
</listitem><listitem><para>2 x <literal>PAGESIZE</literal> on x86 systems</para>
</listitem><listitem><para>5 x <literal>PAGESIZE</literal> on AMD64 systems</para>
</listitem>
</itemizedlist>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>Minimum is the default values:</para><itemizedlist><listitem><para>3 x <literal>PAGESIZE</literal> on SPARC systems</para>
</listitem><listitem><para>2 x <literal>PAGESIZE</literal> on x86 systems</para>
</listitem><listitem><para>5 x <literal>PAGESIZE</literal> on AMD64 systems</para>
</listitem>
</itemizedlist><para>Maximum is 32 times the default value.</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Bytes in multiples of the value returned by the <literal>getpagesize</literal> parameter. For more information, see <olink targetdoc="refman3a" targetptr="getpagesize-3c" remap="external"><citerefentry><refentrytitle>getpagesize</refentrytitle><manvolnum>3C</manvolnum></citerefentry></olink>.</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes. Affects threads created after the variable is changed.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>Must be greater than or equal to 8192 and less than or equal
to 262,144 (256 x 1024). Also must be a multiple of the system page size.
If these conditions are not met, the following message  is displayed:</para><screen>Illegal stack size, Using <replaceable>N</replaceable></screen><para>The value of <replaceable>N</replaceable> is the default value of <literal>default_stksize</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When the system panics because it has run out of stack space.
The best solution for this problem is to determine why the system is running
out of space and then make a correction.</para><para>Increasing the default stack size means that almost every kernel thread
will have a larger stack, resulting in increased kernel memory consumption
for no good reason. Generally, that space will be unused. The increased consumption
means other resources that are competing for the same pool of memory will
have the amount of space available to them reduced, possibly decreasing the
system's ability to perform work. Among the side effects is a reduction in
the number of threads that the kernel can create. This solution should be
treated as no more than an interim workaround until the root cause is remedied.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-118"><title><literal>lwp_default_stksize</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the default value of the stack size to be used when
a kernel thread is created, and when the calling routine does not provide
an explicit size to be used.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><itemizedlist><listitem><para>8192 for x86 platforms</para>
</listitem><listitem><para>24,576 for SPARC platforms</para>
</listitem><listitem><para>20,480 for AMD64 platforms</para>
</listitem>
</itemizedlist>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>Minimum is the default values:</para><itemizedlist><listitem><para>3 x <literal>PAGESIZE</literal> on SPARC systems</para>
</listitem><listitem><para>2 x <literal>PAGESIZE</literal> on x86 systems</para>
</listitem><listitem><para>5 x <literal>PAGESIZE</literal> on AMD64 systems</para>
</listitem>
</itemizedlist><para>Maximum is 32 times the default value.</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Bytes in multiples of the value returned by the <literal>getpagesize</literal> parameter. For more information, see <olink targetdoc="refman3a" targetptr="getpagesize-3c" remap="external"><citerefentry><refentrytitle>getpagesize</refentrytitle><manvolnum>3C</manvolnum></citerefentry></olink>.</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes. Affects threads created after the variable is changed.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>Must be greater than or equal to 8192 and less than or equal
to 262,144 (256 x 1024). Also must be a multiple of the system page size.
If these conditions are not met, the following message  is displayed:</para><screen>Illegal stack size, Using <replaceable>N</replaceable></screen><para>The value of <replaceable>N</replaceable> is the default value of <literal>lwp_default_stksize</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When the system panics because it has run out of stack space.
The best solution for this problem is to determine why the system is running
out of space and then make a correction.</para><para>Increasing the default stack size means that almost every kernel thread
will have a larger stack, resulting in increased kernel memory consumption
for no good reason. Generally, that space will be unused. The increased consumption
means other resources that are competing for the same pool of memory will
have the amount of space available to them reduced, possibly decreasing the
system's ability to perform work. Among the side effects is a reduction in
the number of threads that the kernel can create. This solution should be
treated as no more than an interim workaround until the root cause is remedied.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry><varlistentry><term>Change History</term><listitem><para>For information, see <olink targetptr="fahqp" remap="internal">lwp_default_stksize
(Solaris 9 Releases)</olink>.</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-155"><title><literal>logevent_max_q_sz</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Maximum number of system events allowed to be queued and waiting
for delivery to the <command>syseventd</command> daemon. Once the size of
the system event queue reaches this limit, no other system events are allowed
on the queue.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>5000</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to MAXINT</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>System events</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>The system event framework checks this value every time a
system event is generated by <literal>ddi_log_sysevent</literal> and <literal>sysevent_post_event</literal>.</para><para>For more information, see <olink targetdoc="refman9f" targetptr="ddi-log-sysevent-9f" remap="external"><citerefentry><refentrytitle>ddi_log_sysevent</refentrytitle><manvolnum>9F</manvolnum></citerefentry></olink> and <olink targetdoc="refman3i" targetptr="sysevent-post-event-3sysevent" remap="external"><citerefentry><refentrytitle>sysevent_post_event</refentrytitle><manvolnum>3SYSEVENT</manvolnum></citerefentry></olink>.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When error log messages indicate that a system event failed
to be logged, generated, or posted.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-150"><title><literal>segkpsize</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the amount of kernel pageable memory available.
This memory is used primarily for kernel thread stacks. Increasing this number
allows either larger stacks for the same number of threads or more threads.
This parameter can only be set on a system running a 64-bit kernel. A system
running a 64-bit kernel uses a default stack size of 24 Kbytes.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned long</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>64-bit kernels, 2 Gbytes</para><para>32-bit kernels, 512 Mbytes</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>64-bit kernels, 512 Mbytes to 24 Gbytes</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>8-Kbyte pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>Value is compared to minimum and maximum sizes (512 Mbytes
and 24 Gbytes for 64-bit systems). If smaller than the minimum or larger than
the maximum, it is reset to 2 Gbytes. A message to that effect is displayed.</para><para>The actual size used in creation of the cache is the lesser of the value
specified in <literal>segkpsize</literal> after the validation checking or
50 percent of physical memory.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Required to support large numbers of processes on a system.
The default size of 2 Gbytes, assuming at least 1 Gbyte of physical memory
is present. This default size allows creation of 24-Kbyte stacks for more
than 87,000 kernel threads. The size of a stack in a 64-bit kernel is the
same, whether the process is a 32-bit process or a 64-bit process. If more
than this number is needed, <literal>segkpsize</literal> can be increased,
assuming sufficient physical memory exists.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry><varlistentry><term>Change History</term><listitem><para>For information, see <olink targetptr="appendixa-41" remap="internal">segkpsize
(Solaris 9 12/02 Release)</olink>.</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-26"><title><literal>noexec_user_stack</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Enables the stack to be marked as nonexecutable, which helps
make buffer-overflow attacks more difficult.</para><para>A Solaris system running a 64-bit kernel makes the stacks of all
64-bit applications nonexecutable by default. Setting this parameter is necessary
to make 32-bit applications nonexecutable on systems running 64-bit or 32-bit
kernels.</para><note><para>This parameter exists on all systems running the Solaris 2.6,
7, 8, 9, or 10 releases, but it is only effective on 64&ndash;bit SPARC and
AMD64  architectures.</para>
</note>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>0 (disabled)</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 (disabled) or 1 (enabled)</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Toggle (on/off)</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes. Does not affect currently running processes, only processes
created after the value is set.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Should be enabled at all times unless applications are deliberately
placing executable code on the stack without using <literal>mprotect</literal> to
make the stack executable. For more information, see <olink targetdoc="refman2" targetptr="mprotect-2" remap="external"><citerefentry><refentrytitle>mprotect</refentrytitle><manvolnum>2</manvolnum></citerefentry></olink>.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry><varlistentry><term>Change History</term><listitem><para>For information, see <olink targetptr="appendixa-37" remap="internal">noexec_user_stack
(Solaris 9 Releases)</olink>.</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-3"><title><literal>fsflush</literal> and Related Parameters</title><para>This section describes <literal>fsflush</literal> and related tunables.</para><sect2 id="chapter2-13"><title><literal>fsflush</literal></title><para>The
system daemon, <literal>fsflush</literal>, runs periodically to do three main
tasks:</para><orderedlist><listitem><para>On every invocation, <literal>fsflush</literal> flushes dirty
file system pages over a certain age to disk.</para>
</listitem><listitem><para>On every invocation, <literal>fsflush</literal> examines a
portion of memory and causes modified pages to be written to their backing
store. Pages are written if they are modified and if they do not meet one
of the following conditions:</para><itemizedlist><listitem><para>Pages are kernel page</para>
</listitem><listitem><para>Pages are free</para>
</listitem><listitem><para>Pages are locked</para>
</listitem><listitem><para>Pages are associated with a swap device</para>
</listitem><listitem><para>Pages are currently involved in an I/O operation</para>
</listitem>
</itemizedlist><para>The net effect is to flush pages from files that are mapped with <literal>mmap</literal> with write permission and that have actually been changed.</para><para>Pages are flushed to backing store but left attached to the process
using them. This will simplify page reclamation when the system runs low on
memory by avoiding delay for writing the page to backing store before claiming
it, if the page has not been modified since the flush.</para>
</listitem><listitem><para><literal>fsflush</literal> writes file system metadata to
disk. This write is done every <replaceable>n</replaceable>th invocation,
where <replaceable>n</replaceable> is computed from various configuration
variables. See <olink targetptr="chapter2-105" remap="internal">tune_t_fsflushr</olink> and <olink targetptr="chapter2-16" remap="internal">autoup</olink> for details.</para>
</listitem>
</orderedlist><para>The following features are configurable:</para><itemizedlist><listitem><para>Frequency of invocation (<literal>tune_t_fsflushr</literal>)</para>
</listitem><listitem><para>Whether memory scanning is executed (<literal>dopageflush</literal>)</para>
</listitem><listitem><para>Whether file system data flushing occurs (<literal>doiflush</literal>)</para>
</listitem><listitem><para>The frequency with which file system data flushing occurs
(<literal>autoup</literal>)</para>
</listitem>
</itemizedlist><para>For most systems, memory scanning and file system metadata synchronizing
are the dominant activities for <literal>fsflush</literal>. Depending on system
usage, memory scanning can be of little use or consume too much CPU time.</para>
</sect2><sect2 id="chapter2-105"><title><literal>tune_t_fsflushr</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the number of seconds between <literal>fsflush</literal> invocations</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>1</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to MAXINT</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Seconds</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>If the value is less than or equal to zero, the value is reset
to 1 and a warning message is displayed.
This check is done only at boot time.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>See the <literal>autoup</literal> parameter.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-16"><title><literal>autoup</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Along with <literal>tune_t_flushr</literal>, <literal>autoup</literal> controls
the amount of memory examined for dirty pages in each invocation and frequency
of file system synchronizing operations. </para><para>The
value of <literal>autoup</literal> is also used to control whether a buffer
is written out from the free list. Buffers marked with the <literal>B_DELWRI</literal> flag
(which identifies file content pages that have changed) are written out whenever
the buffer has been on the list for longer than <replaceable>autoup</replaceable> seconds.
Increasing the value of <literal>autoup</literal> keeps the buffers in memory
for a longer time.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>30</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to MAXINT</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Seconds</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>If <literal>autoup</literal> is less than or equal to zero,
it is reset to 30 and a warning message is displayed. This check is done only
at boot time.</para>
</listitem>
</varlistentry><varlistentry><term>Implicit</term><listitem><para><literal>autoup</literal> should be an integer multiple of <literal>tune_t_fsflushr</literal>. At a minimum, <literal>autoup</literal> should
be at least 6 times the value of <literal>tune_t_fsflushr</literal>.  If not,
excessive amounts of memory are scanned each time <literal>fsflush</literal> is
invoked.</para><para>The total system pages multiplied by <literal>tune_t_fsflushr</literal> should
be greater than or equal to <literal>autoup</literal> to cause memory to be
checked if <literal>dopageflush</literal> is non-zero.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Here are several potential situations for changing <literal>autoup</literal>, <literal>tune_t_fsflushr</literal>, or both:</para><itemizedlist><listitem><para>Systems with large amounts of memory &ndash; In this case,
increasing <literal>autoup</literal>  reduces the amount of memory scanned
in each invocation of <literal>fsflush</literal>.</para>
</listitem><listitem><para>Systems with minimal memory demand &ndash; Increasing both <literal>autoup</literal> and <literal>tune_t_fsflushr</literal> reduces the number
of scans made. <literal>autoup</literal> should be increased also to maintain
the current ratio of <literal>autoup</literal> / <literal>tune_t_fsflushr</literal>.</para>
</listitem><listitem><para>Systems with large numbers of transient files (for example,
mail servers or software build machines) &ndash; If large numbers of files
are created and then deleted, <literal>fsflush</literal> might unnecessarily
write data pages for those files to disk.</para>
</listitem>
</itemizedlist>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-5"><title><literal>dopageflush</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Controls whether memory is examined for modified pages during <literal>fsflush</literal> invocations. In each invocation of <literal>fsflush</literal>,
the number of memory pages in the system is determined. This number might
have changed because of a dynamic reconfiguration operation. Each invocation
scans by using this algorithm: total number of pages x <literal>tune_t_fsflushr</literal> / <literal>autoup</literal> pages</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>1 (enabled)</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 (disabled) or 1 (enabled)</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Toggle (on/off)</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>If the system page scanner rarely runs, which is indicated
by a value of 0 in the <literal>sr</literal> column of <command>vmstat</command> output.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-104"><title><literal>doiflush</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Controls whether file system metadata syncs will be executed during <literal>fsflush</literal> invocations. This synchronization is done every <replaceable>N</replaceable>th
invocation of <literal>fsflush</literal> where <replaceable>N</replaceable><literal>= (autoup / tune_t_fsflushr)</literal>. Because this algorithm is integer
division, if <literal>tune_t_fsflushr</literal> is greater than <literal>autoup</literal>,
a synchronization is done on every invocation of <literal>fsflush</literal> because
the code checks to see if its iteration counter is greater than or equal to <replaceable>N</replaceable>. Note that <replaceable>N</replaceable> is computed once on
invocation of <literal>fsflush</literal>. Later changes to <literal>tune_t_fsflushr</literal> or <literal>autoup</literal> have no effect on the frequency of
synchronization operations.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>1 (enabled)</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 (disabled) or 1 (enabled)</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Toggle (on/off)</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When files are frequently modified over a period of time and
the load caused by the flushing perturbs system behavior.</para><para>Files whose existence, and therefore consistency of state, does not
matter if the system reboots are better kept in a TMPFS file system (for example, <filename>/tmp</filename>). Inode traffic can be reduced on systems, starting in the
Solaris 7 release, by using the <command>mount</command> <option>noatime</option> option.
This option eliminates inode updates when the file is accessed.</para><para>For a system engaged in realtime processing, you might want to disable
this option and use explicit application file synchronizing to achieve consistency.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-4"><title>Process-Sizing Parameters</title><para>Several parameters (or variables) are used to control the number of
processes that are available on the system and the number of processes that
an individual user can create. The foundation parameter is <literal>maxusers</literal>.
This parameter drives the values assigned to <literal>max_nprocs</literal> and <literal>maxuprc</literal>.</para><sect2 id="chapter2-92"><title><literal>maxusers</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Originally, <literal>maxusers</literal> defined the number of
logged in users the system could support. When a kernel was generated, various
tables were sized based on this setting. Current Solaris releases do much
of its sizing based on the amount of memory on the system. Thus, much of the
past use of <literal>maxusers</literal> has changed. A number of subsystems
that are still derived from <literal>maxusers</literal>: </para><itemizedlist><listitem><para>The maximum number of processes on the system</para>
</listitem><listitem><para>The number of quota structures held in the system</para>
</listitem><listitem><para>The size of the directory name look-up cache (DNLC)</para>
</listitem>
</itemizedlist>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>Lesser of the amount of memory in Mbytes or 2048</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to 2048, based on physical memory if not set in the <filename>/etc/system</filename> file</para><para>1 to 4096, if set in the <filename>/etc/system</filename> file</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Users</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No. After computation of dependent parameters is done, <literal>maxusers</literal> is never referenced again.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When the default number of user processes derived by the system
is too low. This situation is evident when the following message displays
on the system console:</para><screen>out of processes</screen><para>You might also change this parameter when the default number of processes
is too high, as in these situations:</para><itemizedlist><listitem><para>Database servers that have a lot of memory and relatively
few running processes can save system memory when the default value of <literal>maxusers</literal> is reduced.</para>
</listitem><listitem><para>If file servers have a lot of memory and few running processes,
you might reduce this value. However, you should explicitly set the size of
the DNLC. See <olink targetptr="chapter2-35" remap="internal">ncsize</olink>.</para>
</listitem><listitem><para>If compute servers have a lot of memory and few running processes,
you might reduce this value.</para>
</listitem>
</itemizedlist>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-6"><title><literal>reserved_procs</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the number of system process slots to be reserved in
the process table for processes with a UID of root (0). For example, <literal>fsflush</literal> has a UID of root (0).</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>5</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>5 to MAXINT</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Processes</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No. Not used after the initial parameter computation.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>Starting in the Solaris 8 release, any <filename>/etc/system</filename> setting
is honored.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Consider increasing to 10 + the normal number of UID 0 (root)
processes on system. This setting provides some cushion should it be necessary
to obtain a root shell when the system is otherwise unable to create user-level
processes. </para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-107"><title><literal>pidmax</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the value of the largest possible process ID. Valid
for Solaris 8 and later releases.</para><para><literal>pidmax</literal> sets the value for the <literal>maxpid</literal> variable.
Once <literal>maxpid</literal> is set, <literal>pidmax</literal> is ignored. <literal>maxpid</literal> is used elsewhere in the kernel to determine the maximum
process ID and for validation checking.</para><para>Any attempts to set <literal>maxpid</literal> by adding an entry to
the <filename>/etc/system</filename> file have no effect.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>30,000</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>266 to 999,999 </para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Processes </para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No. Used only at boot time to set the value of <literal>pidmax</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>Yes. Value is compared to the value of <literal>reserved_procs</literal> and
999,999. If less than <literal>reserved_procs</literal> or greater than 999,999,
the value is set to 999,999.</para>
</listitem>
</varlistentry><varlistentry><term>Implicit</term><listitem><para><literal>max_nprocs</literal> range checking ensures that <literal>max_nprocs</literal> is always less than or equal to this value.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Required to enable support for more than 30,000 processes
on a system.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-8"><title><literal>max_nprocs</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the maximum number of processes that can be created
on a system. Includes system processes and user processes. Any value specified
in <filename>/etc/system</filename> is used in the computation of <literal>maxuprc</literal>.</para><para>This
value is also used in determining the size of several other system data structures.
Other data structures where this parameter plays a role are as follows:</para><itemizedlist><listitem><para>Determining the size of the directory name lookup cache (if <literal>ncsize</literal> is not specified)</para>
</listitem><listitem><para>Allocating disk quota structures for UFS (if <literal>ndquot</literal> is
not specified)</para>
</listitem><listitem><para>Verifying that the amount of memory used by configured system
V semaphores does not exceed system limits</para>
</listitem><listitem><para>Configuring Hardware Address Translation resources for  x86 platforms.</para>
</listitem>
</itemizedlist>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>10 + (16 x <literal>maxusers</literal>)</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>266 to value of <literal>maxpid</literal></para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>Yes. The value is compared to <literal>maxpid</literal> and
set to <literal>maxpid</literal> if it is larger. On x86 platforms, an additional
check is made against a platform-specific value. <literal>max_nprocs</literal> is
set to the smallest value in the triplet (<literal>max_nprocs</literal>, <literal>maxpid</literal>, platform value). Both SPARC and x86 platforms use 65,534
as the platform value.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Changing this parameter is one of the steps necessary to enable
support for more than 30,000 processes on a system.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry><varlistentry><term>Change History</term><listitem><para>For information, see <olink targetptr="appendixa-29" remap="internal">max_nprocs
(Solaris 9 Releases)</olink>.</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-109"><title><literal>maxuprc</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the maximum number of processes that can be created
on a system by any one user.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para><literal>max_nprocs</literal> - <literal>reserved_procs</literal></para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to <literal>max_nprocs</literal> - <literal>reserved_procs</literal></para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Processes</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>Yes. This value is compared to <literal>max_nprocs</literal> - <literal>reserved_procs</literal> and set to the smaller of the two values.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When you want to specify a hard limit for the number of processes
a user can create that is less than the default value of however many processes
the system can create. Attempting to exceed this limit generates the following
warning messages on the console or in the messages file: </para><screen>out of per-user processes for uid <replaceable>N</replaceable></screen>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-10"><title>Paging-Related Parameters</title><para>The Solaris OS uses a demand paged virtual memory system. As the system
runs, pages are brought into memory as needed. When memory becomes occupied
above a certain threshold and demand for memory continues, paging begins.
Paging goes through several levels that are controlled by certain parameters.</para><para>The general paging algorithm is as follows: </para><itemizedlist><listitem><para>A memory deficit is noticed. The page scanner thread runs
and begins to walk through memory. A two-step algorithm is employed:</para><orderedlist><listitem><para>A page is marked as unused.</para>
</listitem><listitem><para>If still unused after a time interval, the page is viewed
as a subject for reclaim.</para>
</listitem>
</orderedlist><para>If the page has been modified, a request is made to the pageout thread
to schedule the page for I/O. Also, the page scanner continues looking at
memory. Pageout causes the page to be written to the page's backing store
and placed on the free list. When the page scanner scans memory, no distinction
is made as to the origin of the page. The page might have come from a data
file, or it might represent a page from an executable's text, data, or stack.</para>
</listitem><listitem><para>As memory pressure on the system increases, the algorithm
becomes more aggressive in the pages it will consider as candidates for reclamation
and in how frequently the paging algorithm runs. (For more information, see <olink targetptr="chapter2-19" remap="internal">fastscan</olink> and <olink targetptr="chapter2-20" remap="internal">slowscan</olink>.) As available memory falls between the range <literal>lotsfree</literal> and <literal>minfree</literal>, the system linearly increases the amount of memory scanned
in each invocation of the pageout thread from the value specified by <literal>slowscan</literal> to the value specified by <literal>fastscan</literal>. The system
uses the <literal>desfree</literal> parameter to control a number of decisions
about resource usage and behavior.</para>
</listitem>
</itemizedlist><para>The system initially constrains itself to use no more than 4 percent
of one CPU for <literal>pageout</literal> operations. As memory pressure increases,
the amount of CPU time consumed in support of <literal>pageout</literal> operations
linearly increases until a maximum of 80 percent of one CPU is consumed. The
algorithm looks through some amount of memory between <literal>slowscan</literal> and <literal>fastscan</literal>, then stops when one of the following occurs: </para><itemizedlist><listitem><para>Enough pages have been found to satisfy the memory shortfall. </para>
</listitem><listitem><para>The planned number of pages have been looked at.</para>
</listitem><listitem><para>Too much time has elapsed.</para>
</listitem>
</itemizedlist><para>If a memory shortfall is still present when pageout finishes its scan,
another scan is scheduled for 1/4 second in the future.</para><para>The configuration mechanism of the paging subsystem was changed, starting
in the Solaris 9 release. Instead of depending on a set of predefined values
for <literal>fastscan</literal>, <literal>slowscan</literal>, and <literal>handspreadpages</literal>, the system determines the appropriate settings for these parameters
at boot time. Setting any of these parameters in the <literal>/etc/system</literal> file
can cause the system to use less than optimal values.</para><caution><para>Remove all tuning of the VM system from the <filename>/etc/system</filename> file.
Run with the default settings and determine if it is necessary to adjust any
of these parameters. Do not set either <literal>cachefree</literal> or <literal>priority_paging</literal>. They have been removed, starting in the Solaris 9 release.</para>
</caution><para>Beginning in the Solaris 7 5/99 release, dynamic reconfiguration (DR)
for CPU and memory is supported. A system in a DR operation that involves
the addition or deletion of memory recalculates values for the relevant parameters,
unless the parameter has been explicitly set in <filename>/etc/system</filename>.
In that case, the value specified in <filename>/etc/system</filename> is used,
unless a constraint on the value of the variable has been violated. In this
case, the value is reset.</para><sect2 id="chapter2-11"><title><literal>lotsfree</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Serves as the initial trigger for system paging to begin. When
this threshold is crossed, the page scanner wakes up to begin looking for
memory pages to reclaim.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned long</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>The greater of 1/64th of physical memory or 512 Kbytes</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>The minimum value is 512 Kbytes or 1/64th of physical  memory,
whichever is greater, expressed as pages using the page size returned by <literal>getpagesize</literal>. For more information, see<olink targetdoc="refman3a" targetptr="getpagesize-3c" remap="external"><citerefentry><refentrytitle>getpagesize</refentrytitle><manvolnum>3C</manvolnum></citerefentry></olink>.</para><para>The maximum value is the number of physical memory pages. The maximum
value should be no more than 30 percent of physical memory. The system does
not enforce this range, other than that described in the Validation section.</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes, but dynamic changes are lost if a memory-based DR operation
occurs.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>If <literal>lotsfree</literal> is greater than the amount
of physical memory, the value is reset to the default.</para>
</listitem>
</varlistentry><varlistentry><term>Implicit</term><listitem><para>The relationship of <literal>lotsfree</literal> being greater
than <literal>desfree</literal>, which is greater than <literal>minfree</literal>,
should be maintained at all times.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When demand for pages is subject to sudden sharp spikes, the
memory algorithm might be unable to keep up with demand. One workaround is
to start reclaiming memory at an earlier time. This solution gives the paging
system some additional margin.</para><para>A rule of thumb is to set this parameter to 2 times what the system
needs to allocate in a few seconds. This parameter is workload dependent.
A DBMS server can probably work fine with the default settings. However, you
might need to adjust this parameter for a system doing heavy file system I/O.</para><para>For systems with relatively static workloads and large amounts of memory,
lower this value. The minimum acceptable value is 512 Kbytes, expressed as
pages using the page size returned by <literal>getpagesize</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-103"><title><literal>desfree</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the preferred amount of memory to be free at all times
on the system.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para><literal>lotsfree</literal> / 2</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>The minimum value is 256 Kbytes or 1/128th of physical  memory,
whichever is greater, expressed as pages using the page size returned by <literal>getpagesize</literal>.</para><para>The maximum value is the number of physical memory pages. The maximum
value should be no more than 15 percent of physical memory. The system does
not enforce this range other than that described in the Validation section.</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes, unless dynamic reconfiguration operations that add or
delete memory occur. At that point, the value is reset to the value provided
in the <filename>/etc/system</filename> file or calculated from the new physical
memory value.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>If <literal>desfree</literal> is greater than <literal>lotsfree</literal>, <literal>desfree</literal> is set to <literal>lotsfree</literal> / 2. No message is
displayed.</para>
</listitem>
</varlistentry><varlistentry><term>Implicit</term><listitem><para>The relationship of <literal>lotsfree</literal> being greater
than <literal>desfree</literal>, which is greater than <literal>minfree</literal>,
should be maintained at all times.</para>
</listitem>
</varlistentry><varlistentry><term>Side Effects</term><listitem><para>Several side effects can arise from increasing the value of
this parameter. When the new value nears or exceeds the amount of available
memory on the system, the following can occur:</para><itemizedlist><listitem><para>Asynchronous I/O requests are not processed, unless available
memory exceeds <literal>desfree</literal>. Increasing the value of <literal>desfree</literal> can result in rejection of requests that otherwise would succeed.</para>
</listitem><listitem><para>NFS asynchronous writes are executed as synchronous writes.</para>
</listitem><listitem><para>The swapper is awakened earlier, and the behavior of the swapper
is biased towards more aggressive actions.</para>
</listitem><listitem><para>The system might not prefault as many executable pages into
the system. This side effect results in applications potentially running slower
than they otherwise would. </para>
</listitem>
</itemizedlist>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>For systems with relatively static workloads and large amounts
of memory, lower this value. The minimum acceptable value is 256 Kbytes, expressed
as pages using the page size returned by <literal>getpagesize</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-93"><title><literal>minfree</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the minimum acceptable memory level. When memory drops
below this number, the system biases allocations toward allocations necessary
to successfully complete pageout operations or to swap processes completely
out of memory. Either allocation denies or blocks other allocation requests.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para><literal>desfree</literal> / 2</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>The minimum value is 128 Kbytes or 1/256th of physical memory,
whichever is greater, expressed as pages using the page size returned by <literal>getpagesize</literal>.</para><para>The maximum value is the number of physical memory pages. The maximum
value should be no more than 7.5 percent of physical memory. The system does
not enforce this range other than that described in the Validation section.</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes, unless dynamic reconfiguration operations that add or
delete memory occur. At that point, the value is reset to the value provided
in the <filename>/etc/system</filename> file or calculated from the new physical
memory value.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>If <literal>minfree</literal> is greater than <literal>desfree</literal>, <literal>minfree</literal> is set to <literal>desfree</literal> / 2. No message is
displayed.</para>
</listitem>
</varlistentry><varlistentry><term>Implicit</term><listitem><para>The relationship of <literal>lotsfree</literal> being greater
than <literal>desfree</literal>, which is greater than <literal>minfree</literal>,
should be maintained at all times.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>The default value is generally adequate. For systems with
relatively static workloads and large amounts of memory, lower this value.
The minimum acceptable value is 128 Kbytes, expressed as pages using the page
size returned by <literal>getpagesize</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-14"><title><literal>throttlefree</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the memory level at which blocking memory allocation
requests are put to sleep, even if the memory is sufficient to satisfy the
request.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para><literal>minfree</literal></para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>The minimum value is 128 Kbytes or 1/256th of physical  memory,
whichever is greater, expressed as pages using the page size returned by <literal>getpagesize</literal>.</para><para>The maximum value is the number of physical memory pages. The maximum
value should be no more than 4 percent of physical memory. The system does
not enforce this range other than that described in the Validation section.</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes, unless dynamic reconfiguration operations that add or
delete memory occur. At that point, the value is reset to the value provided
in the <filename>/etc/system</filename> file or calculated from the new physical
memory value.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>If <literal>throttlefree</literal> is greater than <literal>desfree</literal>, <literal>throttlefree</literal> is set to <literal>minfree</literal>.
No message is displayed.</para>
</listitem>
</varlistentry><varlistentry><term>Implicit</term><listitem><para>The relationship of <literal>lotsfree</literal> is greater
than <literal>desfree</literal>, which is greater than <literal>minfree</literal>,
should be maintained at all times.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>The default value is generally adequate. For systems with
relatively static workloads and large amounts of memory, lower this value.
The minimum acceptable value is 128 Kbytes, expressed as pages using the page
size returned by <literal>getpagesize</literal>. For more information, see<olink targetdoc="refman3a" targetptr="getpagesize-3c" remap="external"><citerefentry><refentrytitle>getpagesize</refentrytitle><manvolnum>3C</manvolnum></citerefentry></olink>.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-15"><title><literal>pageout_reserve</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the number of pages reserved for the exclusive use of
the pageout or scheduler threads. When available memory is less than this
value, nonblocking allocations are denied for any processes other than pageout
or the scheduler. Pageout needs to have a small pool of memory for its use
so it can allocate the data structures necessary to do the I/O for writing
a page to its backing store. This variable was introduced in the Solaris 2.6
release to ensure that the system would be able to perform a pageout operation
in the face of the most severe memory shortage.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para><literal>throttlefree</literal> / 2</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>The minimum value is 64 Kbytes or 1/512th of physical  memory,
whichever is greater, expressed as pages using the page size returned by <literal>getpagesize(3C)</literal>.</para><para>The maximum is the number of physical memory pages. The maximum value
should be no more than 2 percent of physical memory. The system does not enforce
this range, other than that described in the Validation section.</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes, unless dynamic reconfiguration operations that add or
delete memory occur. At that point, the value is reset to the value provided
in the <filename>/etc/system</filename> file or calculated from the new physical
memory value.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>If <literal>pageout_reserve</literal> is greater than <literal>throttlefree</literal> / 2, <literal>pageout_reserve</literal> is set to <literal>throttlefree</literal> / 2. No message is displayed.</para>
</listitem>
</varlistentry><varlistentry><term>Implicit</term><listitem><para>The relationship of <literal>lotsfree</literal> being greater
than <literal>desfree</literal>, which is greater than <literal>minfree</literal>,
should be maintained at all times.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>The default value is generally adequate. For systems with
relatively static workloads and large amounts of memory, lower this value.
The minimum acceptable value is 64 Kbytes, expressed as pages using the page
size returned by <literal>getpagesize</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-17"><title><literal>pages_pp_maximum</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the number of pages that must be unlocked. If a request
to lock pages would force available memory below this value, that request
is refused.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned long</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>The greater of (<literal>tune_t_minarmem</literal> + 100 and
[4% of memory available at boot time + 4 Mbytes])</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>Minimum value enforced by the system is <literal>tune_t_minarmem</literal> +
100. The system does not enforce a maximum value.</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes, unless dynamic reconfiguration operations that add or
delete memory occur. At that point, the value is reset to the value provided
in the <filename>/etc/system</filename> file or was calculated from the new
physical memory value.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>If the value specified in the <filename>/etc/system</filename> file
or the calculated default is less than <literal>tune_t_minarmem</literal> +
100, the value is reset to 	<literal>tune_t_minarmem</literal> + 100.</para><para>No message is displayed if the value from the <literal>/etc/system</literal> file
is increased. Validation is done only at boot time and during dynamic reconfiguration
operations that involve adding or deleting memory.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When memory-locking requests fail or when attaching to a shared
memory segment with the <literal>SHARE_MMU</literal> flag fails, yet the amount
of memory available seems to be sufficient.</para><para>Excessively large values can cause memory locking requests (<literal>mlock</literal>, <literal>mlockall</literal>, and <literal>memcntl</literal>) to fail unnecessarily.
For more information, see <olink targetdoc="refman3a" targetptr="mlock-3c" remap="external"><citerefentry><refentrytitle>mlock</refentrytitle><manvolnum>3C</manvolnum></citerefentry></olink>,
 <olink targetdoc="refman3a" targetptr="mlockall-3c" remap="external"><citerefentry><refentrytitle>mlockall</refentrytitle><manvolnum>3C</manvolnum></citerefentry></olink>,
and <olink targetdoc="refman2" targetptr="memcntl-2" remap="external"><citerefentry><refentrytitle>memcntl</refentrytitle><manvolnum>2</manvolnum></citerefentry></olink>.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry><varlistentry><term>Change History</term><listitem><para>For information, see <olink targetptr="appendixa-27" remap="internal">pages_pp_maximum
(Solaris Releases Prior to Solaris 9 Releases)</olink>.</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-18"><title><literal>tune_t_minarmem</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the minimum available resident (not swappable) memory
to maintain necessary to avoid deadlock. Used to reserve a portion of memory
for use by the core of the OS. Pages restricted in this way are not seen when
the OS determines the maximum amount of memory available.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>25</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to physical memory</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None. Large values result in wasted physical memory.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>The default value is generally adequate. Consider increasing
the default value if the system locks up and debugging information indicates
that no memory was available.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-19"><title><literal>fastscan</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the maximum number of pages per second that the system
looks at when memory pressure is highest.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>The lesser of 64 Mbytes and 1/2 of physical memory.</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to one-half of physical memory</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes, unless dynamic reconfiguration operations that add or
delete memory occur. At that point, the value is reset to the value provided
by <filename>/etc/system</filename> or calculated from the new physical memory
value.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>The maximum value is the lesser of 64 Mbytes and 1/2 of physical
memory. </para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When more aggressive scanning of memory is preferred during
periods of memory shortfall, especially when the system is subject to periods
of intense memory demand or when performing heavy file I/O.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-20"><title><literal>slowscan</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the minimum number of pages per second that the system
looks at when attempting to reclaim memory.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>The smaller of 1/20th of physical memory in pages and 100.</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to <literal>fastscan</literal> / 2</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes, unless dynamic reconfiguration operations that add or
delete memory occur. At that point, the value is reset to the value provided
in the <filename>/etc/system</filename> file or calculated from the new physical
memory value.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>If <literal>slowscan</literal> is larger than <literal>fastscan</literal> /
2, <literal>slowscan</literal> is reset to <literal>fastscan</literal> / 2.
No message is displayed.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When more aggressive scanning of memory is preferred during
periods of memory shortfall, especially when the system is subject to periods
of intense memory demand.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-122"><title><literal>min_percent_cpu</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the minimum percentage of CPU that <literal>pageout</literal> can
consume. This parameter is used as the starting point for determining the
maximum amount of time that can be consumed by the page scanner.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>4</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to 80</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Percentage</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Increasing this value on systems with multiple CPUs and lots
of memory, which are subject to intense periods of memory demand, enables
the pager to spend more time attempting to find memory.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-21"><title><literal>handspreadpages</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>The Solaris OS uses a two-handed clock algorithm to look for pages
that are candidates for reclaiming when memory is low. The first hand of the
clock walks through memory marking pages as unused. The second hand walks
through memory some distance after the first hand, checking to see if the
page is still marked as unused. If so, the page is subject to being reclaimed.
The distance between the first hand and the second hand is <literal>handspreadpages</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned long</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para><literal>fastscan</literal></para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to maximum number of physical memory pages on the system</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes. This parameter requires that the kernel <literal>reset_hands</literal> parameter also be set to a non-zero value. Once the new value of <literal>handspreadpages</literal> has been recognized, <literal>reset_hands</literal> is
set to zero.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>The value is set to the lesser of either the amount of physical
memory and the <literal>handspreadpages</literal> <replaceable>value</replaceable>.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When you want to increase the amount of time that pages are
potentially resident before being reclaimed. Increasing this value increases
the separation between the hands, and therefore, the amount of time before
a page can be reclaimed.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-22"><title><literal>pages_before_pager</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines part of a system threshold that immediately frees pages
after an I/O completes instead of storing the pages for possible reuse. The
threshold is <literal>lotsfree + pages_before_pager</literal>. The NFS environment
also uses this threshold to curtail its asynchronous activities as memory
pressure mounts. </para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>200</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to amount of physical memory</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>You might change this parameter when the majority of I/O is
done for pages that are truly read or written once and never referenced again.
Setting this variable to a larger amount of memory keeps adding pages to the
free list.</para><para>You might also change this parameter when the system is subject to bursts
of severe memory pressure. A larger value here helps maintain a larger cushion
against the pressure.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-148"><title><literal>maxpgio</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the maximum number of page I/O requests that can be queued
by the paging system. This number is divided by 4 to get the actual maximum
number used by the paging system. This parameter is used to throttle the number
of requests as well as to control process swapping.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>40</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to a variable maximum that depends on the system architecture,
but mainly by the I/O subsystem, such as the number of controllers, disks,
and disk swap size</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>I/0s</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>Implicit</term><listitem><para>The maximum number of I/O requests from the pager is limited
by the size of a list of request buffers, which is currently sized at 256.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Increase this parameter to page out memory faster. A larger
value might help to recover faster from memory pressure if more than one swap
device is configured or if the swap device is a striped device. Note that
the existing I/O subsystem should be able to handle the additional I/O load.
Also, increased swap I/O could degrade application I/O performance if the
swap partition and application files are on the same disk. </para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry><varlistentry><term>Change History</term><listitem><para>For information, see <olink targetptr="gfhxd" remap="internal">maxpgio (Solaris
10 Releases)</olink>.</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-123"><title>Swapping-Related Parameters</title><para>Swapping in the Solaris OS is accomplished by the swapfs pseudo file
system. The combination of space on swap devices and physical memory is treated
as the pool of space available to support the system for maintaining backing
store for anonymous memory. The system attempts to allocate space from disk
devices first, and then uses physical memory as backing store. When swapfs
is forced to use system memory for backing store, limits are enforced to ensure
that the system does not deadlock because of excessive consumption by swapfs.</para><sect2 id="chapter2-124"><title><literal>swapfs_reserve</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the amount of system memory that is reserved for use by
system (UID = 0) processes.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned long</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>The smaller of 4 Mbytes and 1/16th of physical memory</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>The minimum value is 4 Mbytes or 1/16th of physical memory,
 whichever is smaller, expressed as pages using the page size returned by <literal>getpagesize</literal>.</para><para>The maximum value is the number of physical memory pages. The maximum
value should be no more than 10 percent of physical memory. The system does
not enforce this range, other than that described in the Validation section.</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Generally not necessary. Only change when recommended by a
software provider, or when system processes are terminating because of an
inability to obtain swap space. A much better solution is to add physical
memory or additional swap devices to the system.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-125"><title><literal>swapfs_minfree</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the desired amount of physical memory to be kept free
for the rest of the system. Attempts to reserve memory for use as swap space
by any process that causes the system's perception of available memory to
fall below this value are rejected. Pages reserved in this manner can only
be used for locked-down allocations by the kernel or by user-level processes.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned long</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>The larger of 2 Mbytes and 1/8th of physical memory</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to amount of physical memory</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When processes are failing because of an inability to obtain
swap space, yet the system has memory available.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-126"><title>Kernel Memory Allocator</title><para>The Solaris kernel memory allocator distributes chunks of memory for
use by clients inside the kernel. The allocator creates a number of caches
of varying size for use by its clients. Clients can also request the allocator
to create a cache for use by that client (for example, to allocate structures
of a particular size). Statistics about each cache that the allocator manages
can be seen by using the <literal>kstat -c kmem_cache</literal> command.</para><para>Occasionally, systems might panic because of memory corruption. The
kernel memory allocator supports a debugging interface (a set of flags), that
performs various integrity checks on the buffers. The kernel memory allocator
also collects information on the allocators. The integrity checks provide
the opportunity to detect errors closer to where they actually occurred. The
collected information provides additional data for support people when they
try to ascertain the reason for the panic.</para><para>Use of the flags incurs additional overhead and memory usage during
system operations. The flags should only be used when a memory corruption
problem is suspected.</para><sect2 id="chapter2-127"><title><literal>kmem_flags</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>The Solaris kernel memory allocator has various debugging and
test options that were extensively used during the internal development cycle
of the Solaris OS. Starting in the Solaris 2.5 release, a subset of these
options became available. They are controlled by the <literal>kmem_flags</literal> variable,
which was set with a kernel debugger, and then rebooting the system. Because
of issues with the timing of the instantiation of the kernel memory allocator
and the parsing of the <filename>/etc/system</filename> file, it was not possible
to set these flags in the <filename>/etc/system</filename> file until the
Solaris 8 release.</para><para>Five supported flag settings are described here.</para><informaltable remap="CHAPTER2-TBL-128" frame="topbot"><tgroup cols="3" colsep="0" rowsep="0"><colspec colwidth="20.80*"/><colspec colwidth="17.00*"/><colspec colwidth="61.20*"/><thead><row rowsep="1"><entry><para>Flag</para>
</entry><entry><para>Setting</para>
</entry><entry><para>Description</para>
</entry>
</row>
</thead><tbody><row><entry><para><literal>AUDIT</literal></para>
</entry><entry><para><literal>0x1</literal></para>
</entry><entry><para>The allocator maintains a log that contains recent history of its activity.
The number of items logged depends on whether <literal>CONTENTS</literal> is
also set. The log is a fixed size. When space is exhausted, earlier records
are reclaimed.</para>
</entry>
</row><row><entry><para><literal>TEST</literal></para>
</entry><entry><para><literal>0x2</literal></para>
</entry><entry><para>The allocator writes a pattern into freed memory and checks that the
pattern is unchanged when the buffer is next allocated. If some portion of
the buffer is changed, then the memory was probably used by a client that
had previously allocated and freed the buffer. If an overwrite is identified,
the system panics.</para>
</entry>
</row><row><entry><para><literal>REDZONE</literal></para>
</entry><entry><para><literal>0x4</literal></para>
</entry><entry><para>The allocator provides extra memory at the end of the requested buffer
and inserts a special pattern into that memory. When the buffer is freed,
the pattern is checked to see if data was written past the end of the buffer.
If an overwrite is identified, the kernel panics.</para>
</entry>
</row><row><entry><para><literal>CONTENTS</literal></para>
</entry><entry><para><literal>0x8</literal></para>
</entry><entry><para>The allocator logs up to 256 bytes of buffer contents when the buffer
is freed. This flag requires that <literal>AUDIT</literal> also be set.</para><para>The numeric value of these flags can be logically added together and
set by the <filename>/etc/system</filename> file, starting in the Solaris
8 release, or for previous releases, by booting <command>kadb</command> and
setting the flags before starting the kernel.</para>
</entry>
</row><row><entry><para><literal>LITE</literal></para>
</entry><entry><para><literal>0x100</literal></para>
</entry><entry><para>Does minimal integrity checking when a buffer is allocated and freed.
When enabled, the allocator checks that the redzone has not been written into,
that a freed buffer is not being freed again, and that the buffer being freed
is the size that was allocated. This flag is available as of the Solaris 7
3/99 release. Do not combine this flag with any other flags.</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>0 (disabled) </para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 (disabled) or 1 - 15 or 256 (0x100)</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes. Changes made during runtime only affect new kernel memory
caches. After system initialization, the creation of new caches is rare.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When memory corruption is suspected</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-27"><title>General Driver Parameter</title><sect2 id="chapter2-28"><title><literal>moddebug</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Used to cause messages about various steps in the module loading
process to be displayed.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>0  (messages off)</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>Here are the most useful values:</para><itemizedlist><listitem><para>0x80000000 &ndash; Prints <literal>[un] loading...</literal> message.
For every module loaded, messages such as the following appear on the console
and in the <filename>/var/adm/messages</filename> file:</para><screen>Nov 5 16:12:28 sys genunix: [ID 943528 kern.notice] 
load 'sched/TS_DPTBL' id 9 loaded @ 0x10126438/
0x10438dd8 size 132/2064 
Nov 5 16:12:28 sys genunix: [ID 131579 kern.notice] 
installing TS_DPTBL, module id 9.</screen>
</listitem><listitem><para>0x40000000 &ndash; Prints detailed error messages. For every
module loaded, messages such as the following appear on the console and in
the <filename>/var/adm/messages</filename> file:</para><screen>Nov 5 16:16:50 sys krtld: [ID 284770 kern.notice] 
kobj_open: can't open /platform/SUNW,Ultra-80/kernel/
sched/TS_DPTBL
Nov 5 16:16:50 sys krtld: [ID 284770 kern.notice] 
kobj_open: can't open /platform/sun4u/kernel/sched/
TS_DPTBL
Nov 5 16:16:50 sys krtld: [ID 797908 kern.notice] 
kobj_open: '/kernel/sch...
Nov 5 16:16:50 sys krtld: [ID 605504 kern.notice] 
descr = 0x2a
Nov 5 16:16:50 sys krtld: [ID 642728 kern.notice] 
kobj_read_file: size=34,
Nov 5 16:16:50 sys krtld: [ID 217760 kern.notice] 
offset=0
Nov 5 16:16:50 sys krtld: [ID 136382 kern.notice] 
kobj_read: req 8192 bytes,
Nov 5 16:16:50 sys krtld: [ID 295989 kern.notice] 
got 4224
Nov 5 16:16:50 sys krtld: [ID 426732 kern.notice] 
read 1080 bytes
Nov 5 16:16:50 sys krtld: [ID 720464 kern.notice] 
copying 34 bytes
Nov 5 16:16:50 sys krtld: [ID 234587 kern.notice] 
count = 34
[33 lines elided]
Nov 5 16:16:50 sys genunix: [ID 943528 kern.notice] 
load 'sched/TS_DPTBL' id 9 loaded @ 0x10126438/
0x10438dd8 size 132/2064
Nov 5 16:16:50 sys genunix: [ID 131579 kern.notice] 
installing TS_DPTBL, module id 9.
Nov 5 16:16:50 sys genunix: [ID 324367 kern.notice] 
init 'sched/TS_DPTBL' id 9 loaded @ 0x10126438/
0x10438dd8 size 132/2064</screen>
</listitem><listitem><para>0x20000000 - Prints even more detailed messages. This value
doesn't print any additional information beyond what the <literal>0x40000000</literal> flag
does during system boot. However, this value does print additional information
about releasing the module when the module is unloaded.</para>
</listitem>
</itemizedlist><para>These values can be added together to set the final value.</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When a module is either not loading as expected, or the system
seems to hang while loading modules. Note that when <literal>0x40000000</literal> is
set, system boot is slowed down considerably by the number of messages written
to the console.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-29"><title>General I/O Parameters</title><sect2 id="chapter2-30"><title><literal>maxphys</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the maximum size of physical I/O requests. If a driver
encounters a request larger than this size, the driver breaks the request
into <literal>maxphys</literal> sized chunks. File systems can and do impose
their own limit.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>131,072 (sun4u or sun4v)
or 57,344 (x86).  The <literal>sd</literal> driver uses the value of 1,048,576
if the drive supports wide transfers. The <literal>ssd</literal> driver uses
1,048,576 by default.</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>Machine-specific page size to <literal>MAXINT</literal></para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Bytes </para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes, but many file systems load this value into a per-mount
point data structure when the file system is mounted. A number of drivers
load the value at the time a device is attached to a driver-specific data
structure.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When doing I/O to and from raw devices in large chunks. Note
that a DBMS doing OLTP operations issues large numbers of small I/Os. Changing <literal>maxphys</literal> does not result in any performance improvement in that case.</para><para>You might also consider changing this parameter when doing I/O to and
from a UFS file system where large amounts of data (greater than 64 Kbytes)
are being read or written at any one time. The file system should be optimized
to increase contiguity. For example, increase the size of the cylinder groups
and decrease the number of inodes per cylinder group. UFS imposes an internal
limit of 1 Mbyte on the maximum I/O size it transfers.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry><varlistentry><term>Change History</term><listitem><para>For information, see <olink targetptr="gfpvm" remap="internal">maxphys (Solaris
10 Releases)</olink>.</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-31"><title><literal>rlim_fd_max</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the &ldquo;hard&rdquo; limit on file descriptors that
a single process might have open. Overriding this limit requires superuser
privilege.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>65,536</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to <literal>MAXINT</literal></para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>File descriptors</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When the maximum number of open files for a process is not
enough. Other limitations in system facilities can mean that a larger number
of file descriptors is not as useful as it might be. For example:</para><itemizedlist><listitem><para>A 32-bit program using standard I/O is limited to 256 file
descriptors. A 64-bit program using standard I/O can use up to 2 billion descriptors.
Specifically, standard I/O refers to the <olink targetdoc="refman3a" targetptr="stdio-3c" remap="external"><citerefentry><refentrytitle>stdio</refentrytitle><manvolnum>3C</manvolnum></citerefentry></olink> functions in <olink targetdoc="refman3f" targetptr="libc-3lib" remap="external"><citerefentry><refentrytitle>libc</refentrytitle><manvolnum>3LIB</manvolnum></citerefentry></olink>.</para>
</listitem><listitem><para><literal>select</literal> is by default limited to 1024 descriptors
per <literal>fd_set</literal>. For more information, see <olink targetdoc="refman3a" targetptr="select-3c" remap="external"><citerefentry><refentrytitle>select</refentrytitle><manvolnum>3C</manvolnum></citerefentry></olink>. Starting with the Solaris
7 release, 32-bit application code can be recompiled with a larger <literal>fd_set</literal> size (less than or equal to 65,536). A 64-bit application uses
an <literal>fd_set</literal> size of 65,536, which cannot be changed.</para>
</listitem>
</itemizedlist><para>An alternative to changing this on a system wide basis is to use the <olink targetdoc="refman1" targetptr="plimit-1" remap="external"><citerefentry><refentrytitle>plimit</refentrytitle><manvolnum>1</manvolnum></citerefentry></olink> command. If a parent process
has its limits changed by <command>plimit</command>, all children inherit
the increased limit. This alternative is useful for daemons such as <literal>inetd</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry><varlistentry><term>Change History</term><listitem><para>For information, see <olink targetptr="appendixa-31" remap="internal">rlim_fd_max
(Solaris 8 Release)</olink>.</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-32"><title><literal>rlim_fd_cur</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the &ldquo;soft&rdquo; limit on file descriptors that
a single process can have open. A process might adjust its file descriptor
limit to any value up to the &ldquo;hard&rdquo; limit defined by <literal>rlim_fd_max</literal> by using the <literal>setrlimit()</literal> call or by issuing
the <command>limit</command> command in whatever shell it is running. You
do not require superuser privilege to adjust the limit to any value less than
or equal to the hard limit.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>256</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to <literal>MAXINT</literal></para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>File descriptors</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>Compared to <literal>rlim_fd_max</literal>. If <literal>rlim_fd_cur</literal> is greater than <literal>rlim_fd_max</literal>, <literal>rlim_fd_cur</literal> is
reset to <literal>rlim_fd_max</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When the default number of open files for a process is not
enough. Increasing this value means only that it might not be necessary for
a program to use <literal>setrlimit</literal> to increase the maximum number
of file descriptors available to it.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-33"><title>General File System Parameters</title><sect2 id="chapter2-35"><title><literal>ncsize</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the number of entries in the directory name look-up cache
(DNLC). This parameter is used by UFS and NFS to cache elements of path names
that have been resolved.</para><para>Starting with the Solaris 8 6/00 release, the DNLC also caches negative
look-up information, which means it caches a name not found in the cache. </para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>(4 x (<literal>v.v_proc</literal> + <literal>maxusers</literal>)
+ 320) + (4 x (<literal>v.v_proc</literal> + <literal>maxusers</literal>)
+ 320 / 100</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to <literal>MAXINT</literal></para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>DNLC entries</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No </para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None. Larger values cause the time it takes to unmount a file
system to increase as the cache must be flushed of entries for that file system
during the unmount process.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Prior to the Solaris 8 6/00 release, it was difficult to determine
whether the cache was too small. You could make this inference by noting the
number of entries returned by <literal>kstat -n ncstats</literal>. If the
number seems high, given the system workload and file access pattern, this
might be due to the size of the DNLC.</para><para>Starting with the Solaris 8 6/00 release, you can use the <literal>kstat
-n dnlcstats</literal> command to determine when entries have been removed
from the DNLC because it was too small. The sum of the <literal>pick_heuristic</literal> and
the <literal>pick_last</literal> parameters represents otherwise valid entries
that were reclaimed because the cache was too small.</para><para>Excessive values of <literal>ncsize</literal> have an immediate impact
on the system because the system allocates a set of data structures for the
DNLC based on the value of <literal>ncsize</literal>. A system running a 32-bit
kernel allocates 36-byte structures for <literal>ncsize</literal>, while a
system running a 64-bit kernel allocates 64-byte structures for <literal>ncsize</literal>.
The value has a further effect on UFS and NFS, unless <literal>ufs_ninode</literal> and <literal>nfs:nrnode</literal> are explicitly set.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry><varlistentry><term>Change History</term><listitem><para>For information, see <olink targetptr="gdpbi" remap="internal">ncsize (Solaris
10 Release)</olink>.</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-34"><title><literal>rstchown</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Indicates whether the POSIX semantics for the <literal>chown</literal> system
call are in effect. POSIX semantics are as follows:</para><itemizedlist><listitem><para>A process cannot change the owner of a file, unless it is
running with UID 0.</para>
</listitem><listitem><para>A process cannot change the group ownership of a file to a
group in which it is not currently a member, unless it is running as UID 0.</para>
</listitem>
</itemizedlist><para>For more information, see <olink targetdoc="refman2" targetptr="chown-2" remap="external"><citerefentry><refentrytitle>chown</refentrytitle><manvolnum>2</manvolnum></citerefentry></olink>.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>1, indicating that POSIX semantics are used</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 = POSIX semantics not in force or 1 = POSIX semantics used</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Toggle (on/off)</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When POSIX semantics are not wanted. Note that turning off
POSIX semantics opens the potential for various security holes. Doing so also
opens the possibility of a user changing ownership of a file to another user
and being unable to retrieve the file without intervention from the user or
the system administrator.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Obsolete</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-151"><title><literal>dnlc_dir_enable</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Enables large directory caching</para><note><para>This parameter has no effect on NFS file systems.</para>
</note>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>1 (enabled)</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 (disabled) or 1 (enabled)</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes, but do not change this tunable dynamically. You can enable
this parameter if it was originally disabled. Or, you can disable this parameter
if it was originally enabled. However, enabling, disabling, and then enabling
this parameter might lead to stale directory caches.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Directory caching has no known problems. However, if problems
occur, then set <literal>dnlc_dir_enable</literal> to 0 to disable caching.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-152"><title><literal>dnlc_dir_min_size</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the minimum number of entries cached for one directory.</para><note><para>This parameter has no effect on NFS file systems.</para>
</note>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>40</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to MAXUINT (no maximum)</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Entries</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes, this parameter can be changed at any time.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>If performance problems occur with caching small directories,
then increase <literal>dnlc_dir_min_size</literal>. Note that individual file
systems might have their own range limits for caching directories. For instance,
UFS limits directories to a minimum of <literal>ufs_min_dir_cache</literal> bytes
(approximately 1024 entries), assuming 16 bytes per entry.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-153"><title><literal>dnlc_dir_max_size</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the maximum number of entries cached for one directory.</para><note><para>This parameter has no effect on NFS file systems.</para>
</note>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>MAXUINT (no maximum)</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to MAXUINT </para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes, this parameter can be changed at any time.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>If performance problems occur with large directories, then
decrease <literal>dnlc_dir_max_size</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-158"><title><literal>segmap_percent</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the maximum amount of memory that is used for the fast-access
file system cache. This pool of memory is subtracted from the free memory
list.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>12 percent of free memory at system startup time</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>2 Mbytes to 100 percent of <literal>physmem</literal></para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>% of physical memory</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>If heavy file system activity is expected, and sufficient
free memory is available, you should increase the value of this parameter.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-37"><title>UFS Parameters</title><sect2 id="chapter2-38"><title><literal>bufhwm</literal> and <literal>bufhwm_pct</literal></title><variablelist termlength="narrow"><varlistentry><term>Description</term><listitem><para>Defines the maximum amount of memory for caching I/O buffers.
The buffers are used for writing file system metadata (superblocks, inodes,
indirect blocks, and directories). Buffers are allocated as needed until the
amount of memory (in Kbytes) to be allocated exceed <literal>bufhwm</literal>.
At this point, metadata is purged from the buffer cache until enough buffers
are reclaimed to satisfy the request.</para><para>For historical reasons, <literal>bufhwm</literal> does not require the <literal>ufs:</literal> prefix.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>2 percent of physical memory</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>80 Kbytes to 20 percent of physical memory, or 2 TB, whichever
is less. Consequently, <literal>bufhwm_pct</literal> can be between 1 and
20.</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para><literal>bufhwm</literal>: Kbytes</para><para><literal>bufhwm_pct</literal>: percent of physical memory</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No. <literal>bufhwm</literal> and <literal>bufhwm_pct</literal> are
only evaluated at system initialization to compute hash bucket sizes. The
limit in bytes calculated from these parameters is then stored in a data structure
that adjusts this value as buffers are allocated and deallocated.</para><para>Attempting to adjust this value without following the locking protocol
on a running system can lead to incorrect operation.</para><para>Modifying <literal>bufhwm</literal> or <literal>bufhwm_pct</literal> at
runtime has no effect.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>If <literal>bufhwm</literal> is less than its lower limit
of 80 Kbytes or greater than its upper limit (the lesser of 20 percent of
physical memory, 2 TB, or one quarter (1/4) of the maximum amount of kernel
heap), it is reset to the upper limit. The following message appears on the
system console and in the <filename>/var/adm/messages</filename> file if an
invalid value is attempted:</para><screen>"binit: <replaceable>bufhwm</replaceable> (value attempted) out of range 
(<replaceable>range start..range end</replaceable>). Using <replaceable>N</replaceable> as default."</screen><para>&ldquo;Value attempted&rdquo; refers to the value specified in the<filename>/etc/system</filename> file or
by using a kernel debugger. <replaceable>N</replaceable> is the value computed
by the system based on available system memory.</para><para>Likewise, if <literal>bufhwm_pct</literal> is set to a value that is
outside the allowed range of 1 percent to 20 percent, it is reset to the default
of 2 percent. And, the following message appears on the system console and
in the <filename>/var/adm/messages</filename> file:</para><screen>"binit: <replaceable>bufhwm_pct</replaceable>(value attempted) out of range(0..20).
       Using 2 as default."</screen><para>If both <literal>bufhwm</literal> or <literal>bufhwm_pct</literal> are
set to non-zero values, <literal>bufhwm</literal> takes precedence.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Because buffers are only allocated as they are needed, the
overhead from the default setting is the required allocation of control structures
for the buffer hash headers. These structures consume 52 bytes per potential
buffer on a 32-bit kernel and 96 bytes per potential buffer on a 64-bit kernel.</para><para>On a 512-Mbyte 64-bit kernel, the number of hash chains calculates to
10316 / 32 == 322, which scales up to next power of 2, 512. Therefore, the
hash headers consume 512 x 96 bytes, or 48 Kbytes. The hash header allocations
assume that buffers are 32 Kbytes.</para><para>The amount of memory, which has not been allocated in the buffer pool,
can be found by looking at the <literal>bfreelist</literal> structure in the
kernel with a kernel debugger. The field of interest in the structure is <literal>b_bufsize</literal>, which is the possible remaining memory in bytes. Looking
at it with the <literal>buf</literal> macro by using the <command>mdb</command> command:</para><screen># <userinput>mdb</userinput> <option>k</option>
Loading modules: [ unix krtld genunix ip nfs ipc ]
> <userinput>bfreelist::print "struct buf" b_bufsize</userinput>
b_bufsize = 0x225800</screen><para>The default value for <literal>bufhwm</literal> on this system, with
6 Gbytes of memory, is 122277. You cannot determine the number of header structures
used because the actual buffer size requested is usually larger than 1 Kbyte.
However, some space might be profitably reclaimed from control structure allocation
for this system.</para><para>The same structure on a 512-Mbyte system shows that only 4 Kbytes of
10144 Kbytes has not been allocated. When the <literal>biostats kstat</literal> is
examined with <command>kstat -n biostats</command>, it is determined that
the system had a reasonable ratio of <literal>buffer_cache_hits</literal> to <literal>buffer_cache_lookups</literal> as well. As such, the default setting is reasonable
for that system.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry><varlistentry><term>Change History</term><listitem><para>For information, see <olink targetptr="appendixa-55" remap="internal">bufhwm
 (Solaris 9 Releases)</olink>.</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-39"><title><literal>ndquot</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the number of quota structures for the UFS file system
that should be allocated. Relevant only if quotas are enabled on one or more
UFS file systems. Because of historical reasons, the <literal>ufs:</literal> prefix
is not needed.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>((<literal>maxusers</literal> x 40) / 4) + <literal>max_nprocs</literal></para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to MAXINT</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Quota structures</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None. Excessively large values hang the system. </para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When the default number of quota structures is not enough.
This situation is indicated by the following message displayed on the console
or written in the message log:</para><screen>dquot table full</screen>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-41"><title><literal>ufs_ninode</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the number of inodes to be held in memory. Inodes are
cached globally for UFS, not on a per-file system basis.</para><para>A key parameter in this situation is <literal>ufs_ninode</literal>.
This parameter is used to compute two key limits that affect the handling
of inode caching. A high watermark of <literal>ufs_ninode / 2</literal> and
a low watermark of <literal>ufs_ninode / 4</literal> are computed.</para><para>When the system is done with an inode, one of two things can happen: </para><itemizedlist><listitem><para>The file referred to by the inode is no longer on the system
so the inode is deleted. After it is deleted, the space goes back into the
inode cache for use by another inode (which is read from disk or created for
a new file).</para>
</listitem><listitem><para>The file still exists but is no longer referenced by a running
process. The inode is then placed on the idle queue. Any referenced pages
are still in memory.</para>
</listitem>
</itemizedlist><para>When inodes are idled, the kernel defers the idling process to a later
time. If a file system is a logging file system, the kernel also defers deletion
of inodes. Two kernel threads handle this deferred processing. Each thread
is responsible for one of the queues. </para><para>When the deferred processing is done, the system drops the inode onto
either a delete queue or an idle queue, each of which has a thread that can
run to process it. When the inode is placed on the queue, the queue occupancy
is checked against the low watermark. If the queue occupancy exceeds the low
watermark, the thread associated with the queue is awakened. After the queue
is awakened, the thread runs through the queue and forces any pages associated
with the inode out to disk and frees the inode. The thread stops when it has
removed 50 percent of the inodes on the queue at the time it was awakened.</para><para>A second mechanism is in place if the idle thread is unable to keep
up with the load. When the system needs to find a vnode, it goes through the <literal>ufs_vget</literal> routine. The <emphasis>first</emphasis> thing <literal>vget</literal> does
is check the length of the idle queue. If the length is above the high watermark,
then it takes two inodes off the idle queue and &ldquo;idles&rdquo; them (flushes
pages and frees inodes). <literal>vget</literal> does this <emphasis>before</emphasis> it
gets an inode for its own use.</para><para>The system does attempt to optimize by placing inodes with no in-core
pages at the head of the idle list and inodes with pages at the end of the
idle list. However, the system does no other ordering of the list. Inodes
are always removed from the front of the idle queue.</para><para>The only time that inodes are removed from the queues as a whole is
when a synchronization, unmount, or remount occur. </para><para>For historical reasons, this parameter does not require the <literal>ufs:</literal> prefix.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para><literal>ncsize</literal></para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to MAXINT</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Inodes</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>If <literal>ufs_ninode</literal> is less than or equal to
zero, the value is set to <literal>ncsize</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When the default number of inodes is not enough. If the <literal>maxsize reached</literal> field as reported by <command>kstat -n inode_cache</command> is
larger than the <literal>maxsize</literal> field in the <literal>kstat</literal>,
the value of <literal>ufs_ninode</literal> might be too small. Excessive inode
idling can also be a problem.</para><para>You can identify excessive inode idling by using <command>kstat -n inode_cache</command> to look at the <literal>inode_cache</literal> <literal>kstat</literal>. <literal>Thread idles</literal> are inodes idled by the background threads while <literal>vget idles</literal> are idles by the requesting process before using an inode.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-42"><title><literal>ufs_WRITES</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>If <literal>ufs_WRITES</literal> is non-zero, the number of bytes
outstanding for writes on a file is checked. See <literal>ufs_HW</literal> to
determine whether the write should be issued or deferred until only <literal>ufs_LW</literal> bytes are outstanding. The total number of bytes outstanding is
tracked on a per-file basis so that if the limit is passed for one file, it
won't affect writes to other files.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>1 (enabled)</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 (disabled) or 1 (enabled)</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Toggle (on/off)</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None </para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When you want UFS write throttling turned off entirely. If
sufficient I/O capacity does not exist, disabling this parameter can result
in long service queues for disks.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-43"><title><literal>ufs_LW</literal> and <literal>ufs_HW</literal></title><variablelist><varlistentry><term>Description</term><listitem><para><literal>ufs_HW</literal> specifies the number of bytes outstanding on a single file
barrier value. If the number of bytes outstanding is greater than this value
and <literal>ufs_WRITES</literal> is set, then the write is deferred. The
write is deferred by putting the thread issuing the write to sleep on a condition
variable.</para><para><literal>ufs_LW</literal> is the barrier for the number of bytes outstanding
on a single file below which the condition variable on which other sleeping
processes are toggled. When a write completes and the number of bytes is less
than <literal>ufs_LW</literal>, then the condition variable is toggled, which
causes all threads waiting on the variable to awaken and try to issue their
writes. </para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>8 x 1024 x 1024 for <literal>ufs_LW</literal> and 16 x 1024
x 1024 for <literal>ufs_HW</literal></para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to MAXINT</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Bytes</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>Implicit</term><listitem><para><literal>ufs_LW</literal> and <literal>ufs_HW</literal> have
meaning only if <literal>ufs_WRITES</literal> is not equal to zero. <literal>ufs_HW</literal> and <literal>ufs_LW</literal> should be changed together to avoid
needless churning when processes awaken and find that either they cannot issue
a write (when <literal>ufs_LW</literal> and <literal>ufs_HW</literal> are
too close) or they might have waited longer than necessary (when <literal>ufs_LW</literal> and <literal>ufs_HW</literal> are too far apart).</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Consider changing these values when file systems consist of
striped volumes. The aggregate bandwidth available can easily exceed the current
value of <literal>ufs_HW</literal>. Unfortunately, this parameter is not a
per-file system setting.</para><para>You might also consider changing this parameter when <literal>ufs_throttles</literal> is a non-trivial number. Currently, <literal>ufs_throttles</literal> can
only be accessed with a kernel debugger.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-159"><title><literal>freebehind</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Enables the <literal>freebehind</literal> algorithm. When this
algorithm is enabled, the system bypasses the file system cache on newly read
blocks when sequential I/O is detected during times of heavy memory use.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Boolean</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>1 (enabled)</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 (disabled) or 1 (enabled)</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>The <literal>freebehind</literal> algorithm can occur too
easily. If no significant sequential file system activity is expected, disabling <literal>freebehind</literal> makes sure that all files, no matter how large, will
be candidates for retention in the file system page cache. For more fine-grained
tuning, see <literal>smallfile</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-160"><title><literal>smallfile</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Determines the size threshold of files larger than this value
are candidates for no cache retention under the <literal>freebehind</literal> algorithm.</para><para>Large memory systems contain enough memory to cache thousands of 10-Mbyte
files without making severe memory demands. However, this situation is highly
application dependent.</para><para>The goal of the <literal>smallfile</literal> and <literal>freebehind</literal> parameters
is to reuse cached information, without causing memory shortfalls by caching
too much.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>32,768</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to 2,147,483,647</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Increase <literal>smallfile</literal> if an application does
sequential reads on medium-sized files and can most likely benefit from buffering,
and the system is not otherwise under pressure for free memory. Medium-sized
files are 32 Kbytes to 2 Gbytes in size.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-47"><title>TMPFS Parameters</title><sect2 id="chapter2-129"><title><literal>tmpfs:tmpfs_maxkmem</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the maximum amount of kernel memory that TMPFS can use
for its data structures (tmpnodes and directory entries).</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned long</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>One page or 4 percent of physical memory, whichever is greater.</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>Number of bytes in one page (8192 for sun4u or sun4v systems,
4096 for all other systems) to 25 percent of the available kernel memory at
the time TMPFS was first used.</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Bytes</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Increase if the following message is displayed on the console
or written in the messages file:</para><screen>tmp_memalloc: tmpfs over memory limit</screen><para>The current amount of memory used by TMPFS for its data structures is
held in the <literal>tmp_kmemspace</literal> field. This field can be examined
with a kernel debugger.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry><varlistentry><term>Change History</term><listitem><para>For information, see <olink targetptr="gfpvy" remap="internal">tmpfs:tmpfs_maxkmem
(Solaris 10 Releases)</olink>.</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-49"><title><literal>tmpfs:tmpfs_minfree</literal></title><variablelist termlength="narrow"><varlistentry><term>Description</term><listitem><para>Defines the minimum amount of swap space that TMPFS leaves for
the rest of the system. </para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed long</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>256</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to maximum swap space size</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>To maintain a reasonable amount of swap space on  systems
with large amounts of TMPFS usage, you can increase this number. The limit
has been reached when the console or messages file displays the following
message:</para><screen><replaceable>fs-name</replaceable>: File system full, swap space limit exceeded</screen>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry><varlistentry><term>Change History</term><listitem><para>For information, see <olink targetptr="appendixa-26" remap="internal">tmpfs:tmpfs_minfree
(Solaris 8 Releases)</olink>.</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-50"><title>Pseudo Terminals</title><para>Pseudo terminals, <literal>pty</literal>s, are used for two purposes
in Solaris software:</para><itemizedlist><listitem><para>Supporting remote logins by using the <command>telnet</command>, <command>rlogin</command>, or <command>rsh</command> commands</para>
</listitem><listitem><para>Providing the interface through which the X Window system
creates command interpreter windows</para>
</listitem>
</itemizedlist><para>The default number of pseudo-terminals is sufficient for a desktop workstation.
So, tuning focuses on the number of <literal>pty</literal>s available for
remote logins.</para><para>Previous versions of Solaris required that steps be taken to explicitly
configure the system for the preferred number of <literal>pty</literal>s.
Starting with the Solaris 8 release, a new mechanism removes the necessity
for tuning in most cases. The default number of <literal>pty</literal>s is
now based on the amount of memory on the system. This default should be changed
only to restrict or increase the number of users who can log in to the system.</para><para>Three related variables are used in the configuration process:</para><itemizedlist><listitem><para><literal>pt_cnt</literal> &ndash; Default maximum number of <literal>pty</literal>s.</para>
</listitem><listitem><para><literal>pt_pctofmem</literal> &ndash; Percentage of kernel
memory that can be dedicated to <literal>pty</literal> support structures.
A value of zero means that no remote users can log in to the system.</para>
</listitem><listitem><para><literal>pt_max_pty</literal> &ndash; Hard maximum for number
of <literal>pty</literal>s.</para>
</listitem>
</itemizedlist><para><literal>pt_cnt</literal> has a default value of zero, which tells the
system to limit logins based on the amount of memory specified in <literal>pct_pctofmem</literal>, unless <literal>pt_max_pty</literal> is set. If <literal>pt_cnt</literal> is
non-zero, <literal>pty</literal>s are allocated until this limit is reached.
When that threshold is crossed, the system looks at <literal>pt_max_pty</literal>.
If <literal>pt_max_pty</literal> has a non-zero value, it is compared to <literal>pt_cnt</literal>. The <literal>pty</literal> allocation is allowed if <literal>pt_cnt</literal> is less than <literal>pt_max_pty</literal>. If <literal>pt_max_pty</literal> is
zero, <literal>pt_cnt</literal> is compared to the number of <literal>pty</literal>s
supported based on <literal>pt_pctofmem</literal>. If <literal>pt_cnt</literal> is
less than this value, the <literal>pty</literal> allocation is allowed. Note
that the limit based on <literal>pt_pctofmem</literal> only comes into play
if both <literal>pt_cnt</literal> and <literal>ptms_ptymax</literal> have
default values of zero.</para><para>To put a hard limit on <literal>pty</literal>s that is different than
the maximum derived from <literal>pt_pctofmem</literal>, set <literal>pt_cnt</literal> and <literal>ptms_ptymax</literal> in <filename>/etc/system</filename> to the preferred
number of <filename>pty</filename>s. The setting of <literal>ptms_pctofmem</literal> is
not relevant in this case.</para><para>To dedicate a different percentage of system memory to <literal>pty</literal> support
and let the operating system manage the explicit limits, do the following: </para><itemizedlist><listitem><para>Do not set <literal>pt_cnt</literal> or <literal>ptms_ptymax</literal> in <filename>/etc/system</filename>.</para>
</listitem><listitem><para>Set <literal>pt_pctofmem</literal> in <filename>/etc/system</filename> to
the preferred percentage. For example, set <literal>pt_pctofmem=10</literal> for
a 10 percent setting.</para>
</listitem>
</itemizedlist><para>Note that the memory is not actually allocated until it is used in support
of a <literal>pty</literal>. Once memory is allocated, it remains allocated. </para><sect2 id="chapter2-149"><title><literal>pt_cnt</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>The number of available <filename>/dev/pts</filename> entries
is dynamic up to a limit determined by the amount of physical memory available
on the system. <literal>pt_cnt</literal> is one of three variables that determines
the minimum number of logins that the system can accommodate. The default
maximum number of <filename>/dev/pts</filename> devices the system can support
is determined at boot time by computing the number of <literal>pty</literal> structures
that can fit in a percentage of system memory (see <literal>pt_pctofmem</literal>).
If <literal>pt_cnt</literal> is zero, the system allocates up to that maximum.
If <literal>pt_cnt</literal> is non-zero, the system allocates to the greater
of <literal>pt_cnt</literal> and the default maximum. </para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>0</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to <literal>maxpid</literal></para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Logins/windows</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When you want to explicitly control the number of users who
can remotely log in to the system.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-130"><title><literal>pt_pctofmem</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the maximum percentage of physical memory that can be
consumed by data structures to support <filename>/dev/pts</filename> entries.
A system running a 64-bit kernel consumes 176 bytes per <literal>/dev/pts</literal> entry.
A system running a 32-bit kernel consumes 112 bytes per <filename>/dev/pts</filename> entry.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>5</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to 100</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Percentage</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When you want to either restrict or increase the number of
users who can log in to the system. A value of zero means that no remote users
can log in to the system.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-131"><title><literal>pt_max_pty</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Defines the maximum number of <literal>ptys</literal> the system
offers</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>0 (Uses system-defined maximum)</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to MAXUINT</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Logins/windows</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>Implicit</term><listitem><para>Should be greater than or equal to <literal>pt_cnt</literal>.
Value is not checked until the number of <literal>ptys</literal> allocated
exceeds the value of <literal>pt_cnt</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When you want to place an absolute ceiling on the number of
logins supported, even if the system could handle more based on its current
configuration values.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-52"><title>STREAMS Parameters</title><sect2 id="chapter2-53"><title><literal>nstrpush</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the number of modules that can be inserted into (pushed
onto) a STREAM.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>9</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>9 to 16</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Modules</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>At the direction of your software vendor. No messages are
displayed when a STREAM exceeds its permitted push count. A value of <literal>EINVAL</literal> is returned to the program that attempted the push.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-54"><title><literal>strmsgsz</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the maximum number of bytes that a single system call
can pass to a STREAM to be placed in the data part of a message. Any <literal>write</literal> exceeding this size is broken into multiple messages. For more
information, see <olink targetdoc="refman2" targetptr="write-2" remap="external"><citerefentry><refentrytitle>write</refentrytitle><manvolnum>2</manvolnum></citerefentry></olink>.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>65,536</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to 262,144</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Bytes</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When <literal>putmsg</literal> calls return <literal>ERANGE</literal>.
For more information, see <olink targetdoc="refman2" targetptr="putmsg-2" remap="external"><citerefentry><refentrytitle>putmsg</refentrytitle><manvolnum>2</manvolnum></citerefentry></olink>.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-132"><title><literal>strctlsz</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the maximum number of bytes that a single system call
can pass to a STREAM to be placed in the control part of a message</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>1024</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to MAXINT</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Bytes</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>At the direction of your software vendor. <olink targetdoc="refman2" targetptr="putmsg-2" remap="external"><citerefentry><refentrytitle>putmsg</refentrytitle><manvolnum>2</manvolnum></citerefentry></olink> calls return <literal>ERANGE</literal> if
they attempt to exceed this limit.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-56"><title>System V Message Queues</title><para>System V message queues provide a message-passing interface that enables
the exchange of messages by queues created in the kernel. Interfaces are provided
in the Solaris environment to enqueue and dequeue messages. Messages can have
a type associated with them. Enqueueing places messages at the end of a queue.
Dequeuing removes the first message of a specific type from the queue or the
first message if no type is specified.</para><para>For information about System V message queues in the Solaris 10 release,
see <olink targetptr="chapter1-33" remap="internal">System V IPC Configuration</olink>.</para><para>For detailed information on tuning these system resources, see <olink targetdoc="sysadrm" targetptr="rmctrls-1" remap="external">Chapter 6, <citetitle remap="chapter">Resource
Controls (Overview),</citetitle> in <citetitle remap="book">System Administration
Guide:  Virtualization Using the Solaris Operating System</citetitle></olink>.</para><para>For legacy information about the obsolete System V message queues, see <olink targetptr="appendixa-6" remap="internal">Parameters That Are Obsolete or Have Been Removed</olink>.</para>
</sect1><sect1 id="chapter2-63"><title>System V Semaphores</title><para>System V semaphores provide counting semaphores in the Solaris OS. A <emphasis>semaphore</emphasis> is a counter used to provide access to a shared data
object for multiple processes. In addition to the standard set and release
operations for semaphores, System V semaphores can have values that are incremented
and decremented as needed (for example, to represent the number of resources
available). System V semaphores also provide the ability to do operations
on a group of semaphores simultaneously as well as to have the system undo
the last operation by a process if the process dies.</para><para>For information about the changes to semaphore resources in the Solaris
10 release, see <olink targetptr="chapter1-33" remap="internal">System V IPC Configuration</olink>.</para><para>For detailed information about using the new resource controls in the
Solaris 10 release, see <olink targetdoc="sysadrm" targetptr="rmctrls-1" remap="external">Chapter
6, <citetitle remap="chapter">Resource Controls (Overview),</citetitle> in <citetitle remap="book">System Administration Guide:  Virtualization Using the Solaris
Operating System</citetitle></olink>.</para><para>For legacy information about the obsolete System V semaphore parameters,
see <olink targetptr="appendixa-6" remap="internal">Parameters That Are Obsolete or Have Been
Removed</olink>.</para>
</sect1><sect1 id="chapter2-73"><title>System V Shared Memory</title><para>System V shared memory allows the creation of a segment by a process.
Cooperating processes can attach to the memory segment (subject to access
permissions on the segment) and gain access to the data contained in the segment.
This capability is implemented as a loadable module. Entries in the <literal>/etc/system</literal> file must contain the <literal>shmsys</literal>: prefix. Starting
with the Solaris 7 release, the <literal>keyserv</literal> daemon uses System
V shared memory.</para><para>A special kind of shared memory known as <emphasis>intimate shared memory</emphasis> (ISM)
is used by DBMS vendors to maximize performance. When a shared memory segment
is made into an ISM segment, the memory for the segment is locked. This feature
enables a faster I/O path to be followed and improves memory usage. A number
of kernel resources describing the segment are then shared between all processes
that attach to the segment in ISM mode.</para><para>For information about the changes to shared memory resources in the
Solaris 10 release, see <olink targetptr="chapter1-33" remap="internal">System V IPC Configuration</olink>.</para><para>For detailed information about using the new resource controls in the
Solaris 10 release, see <olink targetdoc="sysadrm" targetptr="rmctrls-1" remap="external">Chapter
6, <citetitle remap="chapter">Resource Controls (Overview),</citetitle> in <citetitle remap="book">System Administration Guide:  Virtualization Using the Solaris
Operating System</citetitle></olink>.</para><para>For legacy information about the obsolete System V shared memory parameters,
see <olink targetptr="appendixa-6" remap="internal">Parameters That Are Obsolete or Have Been
Removed</olink>.</para><sect2 id="chapter2-97"><title><literal>segspt_minfree</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Identifies pages of system memory that cannot be allocated for
ISM shared memory.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Unsigned long</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>5 percent of available system memory when the first ISM segment
is created</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to 50 percent of physical memory</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Pages</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None. Values that are too small can cause the system to hang
or performance to severely degrade when memory is consumed with ISM segments.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>On database servers with large amounts of physical memory
using ISM, the value of this parameter can be decreased. If ISM segments are
not used, this parameter has no effect. A maximum value of 128 Mbytes (0x4000)
is almost certainly sufficient on large memory machines.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-98"><title>Scheduling</title><sect2 id="chapter2-100"><title><literal>rechoose_interval</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the number of clock ticks before a process is deemed
to have lost all affinity for the last CPU it ran on. After this interval
expires, any CPU is considered a candidate for scheduling a thread. This parameter
is relevant only for threads in the timesharing class. Real-time threads are
scheduled on the first available CPU. </para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>3</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to MAXINT</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When caches are large, or when the system is running a critical
process or a set of processes that seem to suffer from excessive cache misses
not caused by data access patterns.</para><para>Consider using the processor set capabilities available as of the Solaris
2.6 release or processor binding before changing this parameter. For more
information, see <olink targetdoc="refman1m" targetptr="psrset-1m" remap="external"><citerefentry><refentrytitle>psrset</refentrytitle><manvolnum>1M</manvolnum></citerefentry></olink> or <olink targetdoc="refman1m" targetptr="pbind-1m" remap="external"><citerefentry><refentrytitle>pbind</refentrytitle><manvolnum>1M</manvolnum></citerefentry></olink>.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-82"><title>Timers</title><sect2 id="chapter2-83"><title><literal>hires_tick</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>When set, this parameter causes the Solaris OS to use a system
clock rate of 1000 instead of the default value of 100.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>0</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 (disabled) or 1 (enabled)</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No. Causes new system timing variable to be set at boot time.
Not referenced after boot.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When you want timeouts with a resolution of less than 10 milliseconds,
and greater than or equal to 1 millisecond.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-133"><title><literal>timer_max</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Specifies the number of <trademark>POSIX</trademark> timers available.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Signed integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>32</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to MAXINT</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No. Increasing the value can cause a system crash.</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When the default number of timers offered by the system is
inadequate. Applications receive an <literal>EAGAIN</literal> error when executing <literal>timer_create</literal> system calls.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-94"><title>sun4u or sun4v Specific Parameters</title><sect2 id="chapter2-95"><title><literal>consistent_coloring</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Starting with the Solaris 2.6 release, the ability to use different
page placement policies on the <trademark class="registered">UltraSPARC</trademark> (<literal>sun4u</literal>) platform was introduced. A page placement policy attempts
to allocate physical page addresses to maximize the use of the L2 cache. Whatever
algorithm is chosen as the default algorithm, that algorithm can potentially
provide less optimal results than another algorithm for a particular application
set. This parameter changes the placement algorithm selected for all processes
on the system.</para><para>Based on the size of the L2 cache, memory is divided into bins. The
page placement code allocates a page from a bin when a page fault first occurs
on an unmapped page. The page chosen depends on which of the three possible
algorithms are used:</para><itemizedlist><listitem><para>Page coloring &ndash; Various bits of the virtual address
are used to determine the bin from which the page is selected. This is the
default algorithm in the Solaris 8 release. <literal>consistent_coloring</literal> is
set to zero to use this algorithm. No per-process history exists for this
algorithm. </para>
</listitem><listitem><para>Virtual addr=physical address &ndash; Consecutive pages in
the program selects pages from consecutive bins. <literal>consistent_coloring</literal> is
set to 1 to use this algorithm. No per-process history exists for this algorithm. </para>
</listitem><listitem><para>Bin-hopping &ndash; Consecutive pages in the program generally
allocate pages from every other bin, but the algorithm occasionally skips
more bins. <literal>consistent_coloring</literal> is set to 2 to use this
algorithm. Each process starts at a randomly selected bin, and a per-process
memory of the last bin allocated is kept.</para>
</listitem>
</itemizedlist>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None. Values larger than 2 cause a number of <literal>WARNING:
AS_2_BIN: bad consistent coloring value</literal> messages to appear on the
console. The system hangs immediately thereafter. A power-cycle is required
to recover.</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>When the primary workload of the system is a set of long-running
high-performance computing (HPC) applications. Changing this value might provide
better performance. File servers, database servers, and systems with a number
of active processes (for example, compile or time sharing servers) do not
benefit from changes.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-135"><title><literal>tsb_alloc_hiwater_factor</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Initializes <literal>tsb_alloc_hiwater</literal> to impose an
upper limit on the amount of physical memory that can be allocated for translation
storage buffers (TSBs) as follows:</para><para><literal>tsb_alloc_hiwater</literal> = physical memory (bytes) / <literal>tsb_alloc_hiwater_factor</literal></para><para>When the memory that is allocated to TSBs is equal to the value of <literal>tsb_alloc_hiwater</literal>, the TSB memory allocation algorithm attempts
to reclaim TSB memory as pages are unmapped.</para><para>Exercise caution when using this factor to increase the value of <literal>tsb_alloc_hiwater</literal>. To prevent system hangs, the resulting high water value must be
considerably lower than the value of <literal>swapfs_minfree</literal> and <literal>segspt_minfree</literal>.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>32</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>1 to MAXINIT</para><para>Note that a factor of 1 makes all physical memory available for allocation
to TSBs, which could cause the system to hang. A factor that is too high will
not leave memory available for allocation to TSBs, decreasing system performance.</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Change the value of this parameter if the system has many
processes that attach to very large shared memory segments. Under most circumstances,
tuning of this variable is not necessary.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-165"><title><literal>default_tsb_size</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Selects size of the initial translation storage buffers (TSBs)
allocated to all processes.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>Default is 0 (8 Kbytes)</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>Possible values are:</para><informaltable frame="topbot"><tgroup cols="2" colsep="0" rowsep="0"><colspec colname="colspec0" colwidth="50*"/><colspec colname="colspec1" colwidth="50*"/><thead><row rowsep="1"><entry><para>Value</para>
</entry><entry><para>Description</para>
</entry>
</row>
</thead><tbody><row><entry><para>0</para>
</entry><entry><para>8 Kbytes</para>
</entry>
</row><row><entry><para>1</para>
</entry><entry><para>16 Kbytes</para>
</entry>
</row><row><entry><para>3</para>
</entry><entry><para>32 Kbytes</para>
</entry>
</row><row><entry><para>4</para>
</entry><entry><para>128 Kbytes</para>
</entry>
</row><row><entry><para>5</para>
</entry><entry><para>256 Kbytes</para>
</entry>
</row><row><entry><para>6</para>
</entry><entry><para>512 Kbytes</para>
</entry>
</row><row><entry><para>7</para>
</entry><entry><para>1 Mbyte</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Generally, you do not need to change this value. However,
doing so might provide some advantages if the majority of processes on the
system have a larger than average working set, or if resident set size (RSS)
sizing is disabled.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-162"><title><literal>enable_tsb_rss_sizing</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Enables a resident set size (RSS) based TSB sizing heuristic. </para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Boolean</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>1 (TSBs can be resized)</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 (TSBs remain at <literal>tsb_default_size</literal>) or
1 (TSBs can be resized)</para><para>If set to 0, then <literal>tsb_rss_factor</literal> is ignored.</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Can be set to 0 to prevent growth of the TSBs. Under most
circumstances, this parameter should be left at the default setting.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-128"><title><literal>tsb_rss_factor</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Controls the RSS to TSB span ratio of the RSS sizing heuristic.
This factor divided by 512 yields the percentage of the TSB span which  must
be resident in memory before the TSB is considered as a candidate for resizing.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>384, resulting in a value of 75%. Thus, when the TSB is 3/4
full, its size will be increased. Note that some virtual addresses typically
map to the same slot in the TSB. Therefore, conflicts can occur before the
TSB is at 100% full.</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 to 512</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>If the system is experiencing an excessive number of traps
due to TSB misses, for example, due to virtual address conflicts in the TSB,
you might consider decreasing this value toward 0.</para><para>For example, changing <literal>tsb_rss_factor</literal> to 256 (effectively,
50%) instead of 384 (effectively, 75%) might help eliminate virtual address
conflicts in the TSB in some cases, but will use more kernel memory, particularly
on a heavily loaded system.</para><para>TSB activity can be monitored with the <command>trapstat</command> <option>T</option> command.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-156"><title>Solaris Volume Manager Parameters</title><sect2 id="chapter2-157"><title><literal>md_mirror:md_resync_bufsz</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Sets the size of the buffer used for resynchronizing RAID 1 volumes
(mirrors) as the number of 512-byte blocks in the buffer. Setting larger values
can increase resynchronization speed.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Integer</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>The default value is 1024. Larger systems could use higher
values to increase mirror resynchronization speed.</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>128 to 2048</para>
</listitem>
</varlistentry><varlistentry><term>Units</term><listitem><para>Blocks (512 bytes)</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>If you use Solaris Volume Manager RAID 1 volumes (mirrors),
and you want to increase the speed of mirror resynchronizations. Assuming
that you have adequate memory for overall system performance, you can increase
this value without causing other performance problems.</para><para>If you need to increase the speed of mirror resynchronizations, increase
the value of this parameter incrementally (using 128-block increments) until
performance is satisfactory. On fairly large or new systems, a value of 2048
seems to be optimal. High values on older systems might hang the system.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry><varlistentry><term>Change History</term><listitem><para>For information, see <olink targetptr="gbbsj" remap="internal">md_mirror:md_resync_bufsz</olink>.</para>
</listitem>
</varlistentry>
</variablelist>
</sect2><sect2 id="chapter2-161"><title><literal>md:mirrored_root_flag</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>Overrides Solaris Volume Manager requirements for replica quorum
and forces Solaris Volume Manager to start if any valid state database replicas
are available.</para><para>The default value is disabled, which requires that a majority of all
replicas are available and synchronized before Solaris Volume Manager will
start.</para>
</listitem>
</varlistentry><varlistentry><term>Data Type</term><listitem><para>Boolean values</para>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>0 (disabled)</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 (disabled) or 1 (enabled)</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>No</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>Use of this parameter is not supported.</para><para>Some people using Solaris Volume Manager accept the risk of enabling
this parameter if all three of the following conditions apply:</para><itemizedlist><listitem><para>When root (<filename>/</filename>) or other system-critical
file systems are mirrored</para>
</listitem><listitem><para>Only two disks or controllers are available</para>
</listitem><listitem><para>An unattended reboot of the system is required</para>
</listitem>
</itemizedlist><para>If this parameter is enabled, the system might boot with a stale replica
that inaccurately represents the system state (including which mirror sides
are good or in Maintenance state). This situation could result in data corruption
or system corruption.</para><para>Change this parameter only if system availability is more important
than data consistency and integrity. Closely monitor the system for any failures.
You can mitigate the risk by keeping the number of failed, Maintenance, or
hot-swapped volumes as low as possible.</para><para>For more information about state database replicas, see <olink targetdoc="logvolmgradmin" targetptr="about-state-db-replicas-1" remap="external">Chapter 6, <citetitle remap="chapter">State Database (Overview),</citetitle> in <citetitle remap="book">Solaris Volume Manager Administration Guide</citetitle></olink>.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1><sect1 id="chapter2-164"><title>Network Driver Parameters</title><sect2 id="chapter2-44"><title><literal>intr_blank_time</literal> and <literal>intr_blank_packets</literal></title><variablelist><varlistentry><term>Description</term><listitem><para>These parameters affect on-board network throughput and latency
on SPARC systems.</para><para>If interrupt blanking is disabled, packets are processed by the driver
as soon as they arrive, resulting in higher network throughput and lower latency,
but with higher CPU utilization. With interrupt blanking disabled, processor
utilization can be as high as 80&ndash;90 percent in some high-load web server
environments.</para><para>If interrupt blanking is enabled, packets are processed when the interrupt
is issued. Enabling interrupt blanking can result in reduced processor utilization
and network throughput, but higher network latency.</para><para>Both parameters should be set at the same time. You can set these parameters
by using the <command>ndd</command> command as follows: </para><screen># <userinput>ndd -set /dev/eri intr_blank_time 0</userinput>
# <userinput>ndd -set /dev/eri intr_blank_packets 0</userinput></screen><para>You can add them to the <filename>/etc/system</filename> file as follows:</para><screen>set eri:intr_blank_time 0
set eri:intr_blank_packets 0</screen>
</listitem>
</varlistentry><varlistentry><term>Default</term><listitem><para>Both parameters are enabled on SPARC systems with an <literal>eri</literal> driver.</para><para>Both parameters are disabled on SPARC systems with an <literal>hme</literal> driver.</para>
</listitem>
</varlistentry><varlistentry><term>Range</term><listitem><para>0 (disabled) or 1 (enabled)</para>
</listitem>
</varlistentry><varlistentry><term>Dynamic?</term><listitem><para>Yes</para>
</listitem>
</varlistentry><varlistentry><term>Validation</term><listitem><para>None</para>
</listitem>
</varlistentry><varlistentry><term>When to Change</term><listitem><para>The value of the interrupt blanking parameter is a trade-off
between network throughput and processor utilization. If higher processor
utilization is acceptable for achieving higher network throughput, then disable
interrupt blanking. If lower processor utilization is preferred and higher
network latency is the penalty, then enable interrupt blanking.</para>
</listitem>
</varlistentry><varlistentry><term>Commitment Level</term><listitem><para>Unstable</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1>
</chapter>
<chapter id="chp-typeopexpr"><title>Types, Operators, and Expressions</title><highlights><para>D provides the ability to access and manipulate a variety of data objects: variables and data structures can be created and modified, data objects defined in the operating system kernel and user processes can be accessed, and integer, floating-point, and string constants can be declared. D provides a superset of the ANSI-C operators that are used to manipulate objects and create complex expressions. This chapter describes the detailed set of rules for types, operators, and expressions.</para>
</highlights><sect1 id="chp-typeopexpr-1"><title>Identifier Names and Keywords</title><para>D identifier names are composed of upper case and lower case letters, digits, and underscores where the first character must be a letter or underscore. All identifier names beginning with an underscore (<literal>_</literal>) are reserved for use by the D system libraries. You should avoid using such names in your D programs. By convention, D programmers typically use mixed-case names for variables and all upper case names for constants.</para><para>D language keywords are special identifiers reserved for use in the programming language syntax itself. These names are always specified in lower case and may not be used for the names of D variables.</para><table remap="1" frame="topbot" id="tbl-keywords"><title>D Keywords</title><tgroup cols="3" colsep="0" rowsep="0"><?PubTbl tgroup dispwid="8.99in"?><colspec colname="colspec0" colwidth="32.74*"/><colspec colname="colspec1" colwidth="33.35*"/><colspec colname="colspec2" colwidth="32.89*"/><tbody><row><?PubTbl row breakpenalty="10000"?><entry><para><literal>auto</literal><superscript>*</superscript><literal></literal></para>
</entry><entry><para><literal>goto</literal><superscript>*</superscript><literal></literal></para>
</entry><entry><para><literal>sizeof</literal></para>
</entry>
</row><row><?PubTbl row breakpenalty="10000"?><entry><para><literal>break</literal><superscript>*</superscript><literal></literal></para>
</entry><entry><para><literal>if</literal><superscript>*</superscript><literal></literal></para>
</entry><entry><para><literal>static</literal><superscript>*</superscript><literal></literal></para>
</entry>
</row><row><?PubTbl row breakpenalty="10000"?><entry><para><literal>case</literal><superscript>*</superscript><literal></literal></para>
</entry><entry><para><literal>import</literal><superscript>*</superscript><literal></literal><superscript>+</superscript><literal></literal></para>
</entry><entry><para><literal>string</literal><superscript>+</superscript><literal></literal></para>
</entry>
</row><row><?PubTbl row breakpenalty="10000"?><entry><para><literal>char</literal></para>
</entry><entry><para><literal>inline</literal></para>
</entry><entry><para><literal>stringof</literal><superscript>+</superscript><literal></literal></para>
</entry>
</row><row><?PubTbl row breakpenalty="10000"?><entry><para><literal>const</literal></para>
</entry><entry><para><literal>int</literal></para>
</entry><entry><para><literal>struct</literal></para>
</entry>
</row><row><?PubTbl row breakpenalty="10000"?><entry><para><literal>continue</literal><superscript>*</superscript><literal></literal></para>
</entry><entry><para><literal>long</literal></para>
</entry><entry><para><literal>switch</literal><superscript>*</superscript><literal></literal></para>
</entry>
</row><row><?PubTbl row breakpenalty="10000"?><entry><para><literal>counter</literal><superscript>*</superscript><literal></literal><superscript>+</superscript><literal></literal></para>
</entry><entry><para><literal>offsetof</literal><superscript>+</superscript><literal></literal></para>
</entry><entry><para><literal>this</literal><superscript>+</superscript><literal></literal></para>
</entry>
</row><row><?PubTbl row breakpenalty="10000"?><entry><para><literal>default</literal><superscript>*</superscript><literal></literal></para>
</entry><entry><para><literal>probe</literal><superscript>*</superscript><literal></literal><superscript>+</superscript><literal></literal></para>
</entry><entry><para><literal>translator</literal><superscript>+</superscript><literal></literal></para>
</entry>
</row><row><?PubTbl row breakpenalty="10000"?><entry><para><literal>do</literal><superscript>*</superscript><literal></literal></para>
</entry><entry><para><literal>provider</literal><superscript>*</superscript><literal></literal><superscript>+</superscript><literal></literal></para>
</entry><entry><para><literal>typedef</literal></para>
</entry>
</row><row><?PubTbl row breakpenalty="10000"?><entry><para><literal>double</literal></para>
</entry><entry><para><literal>register</literal><superscript>*</superscript><literal></literal></para>
</entry><entry><para><literal>union</literal></para>
</entry>
</row><row><?PubTbl row breakpenalty="10000"?><entry><para><literal>else</literal><superscript>*</superscript><literal></literal></para>
</entry><entry><para><literal>restrict</literal><superscript>*</superscript><literal></literal></para>
</entry><entry><para><literal>unsigned</literal></para>
</entry>
</row><row><?PubTbl row breakpenalty="10000"?><entry><para><literal>enum</literal></para>
</entry><entry><para><literal>return</literal><superscript>*</superscript><literal></literal></para>
</entry><entry><para><literal>void</literal></para>
</entry>
</row><row><?PubTbl row breakpenalty="10000"?><entry><para><literal>extern</literal></para>
</entry><entry><para><literal>self</literal><superscript>+</superscript><literal></literal></para>
</entry><entry><para><literal>volatile</literal></para>
</entry>
</row><row><?PubTbl row breakpenalty="10000"?><entry colname="colspec0"><para><literal>float</literal></para>
</entry><entry colname="colspec1"><para><literal>short</literal></para>
</entry><entry colname="colspec2"><para><literal>while</literal><superscript>*</superscript><literal></literal></para>
</entry>
</row><row><?PubTbl row breakpenalty="10000"?><entry colname="colspec0"><para><literal>for</literal><superscript>*</superscript><literal></literal></para>
</entry><entry colname="colspec1"><para><literal>signed</literal></para>
</entry><entry colname="colspec2"><para><literal>xlate</literal><superscript>+</superscript><literal></literal></para>
</entry>
</row>
</tbody>
</tgroup>
</table><para>D reserves for use as keywords a superset of the ANSI-C keywords. The keywords reserved for future use by the D language are marked with &ldquo;<literal></literal><superscript>*</superscript><literal></literal>&rdquo;. The D compiler will produce a syntax error if you attempt to use a keyword that is reserved for future use. The keywords defined by D but not defined by ANSI-C are marked with &ldquo;<literal></literal><superscript>+</superscript><literal></literal>&rdquo;. D provides the complete set of types and operators found in ANSI-C. The major difference in D programming is the absence of control-flow constructs. Keywords associated with control-flow in ANSI-C are reserved for future use in D.</para>
</sect1><sect1 id="chp-typeopexpr-2"><title>Data Types and Sizes</title><para>D provides fundamental data types for integers and floating-point constants. Arithmetic may only be performed on integers in D programs. Floating-point constants may be used to initialize data structures, but floating-point arithmetic is not permitted in D. D provides a 32-bit and 64-bit data model for use in writing programs. The data model used when executing your program is the native data model associated with the active operating system kernel. You can determine the native data model for your system using <command>isainfo</command> <option>b</option>.</para><para>The names of the integer types and their sizes in each of the two data models are shown in the following table. Integers are always represented in twos-complement form in the native byte-encoding order of your system.</para><table frame="topbot" id="tbl-ints"><title>D Integer Data Types</title><tgroup cols="3" colsep="0" rowsep="0"><?PubTbl tgroup dispwid="9.04in"?><colspec colname="colspec0" colwidth="32.32*"/><colspec colname="colspec1" colwidth="33.38*"/><colspec colname="colspec2" colwidth="33.29*"/><thead><row><entry rowsep="1"><para>Type Name</para>
</entry><entry rowsep="1"><para>32&ndash;bit Size</para>
</entry><entry rowsep="1"><para>64&ndash;bit Size</para>
</entry>
</row>
</thead><tbody><row><entry><para><literal>char</literal></para>
</entry><entry><para>1 byte</para>
</entry><entry><para>1 byte</para>
</entry>
</row><row><entry><para><literal>short</literal></para>
</entry><entry><para>2 bytes</para>
</entry><entry><para>2 bytes</para>
</entry>
</row><row><entry><para><literal>int</literal></para>
</entry><entry><para>4 bytes</para>
</entry><entry><para>4 bytes</para>
</entry>
</row><row><entry><para><literal>long</literal></para>
</entry><entry><para>4 bytes</para>
</entry><entry><para>8 bytes</para>
</entry>
</row><row><entry colname="colspec0"><para><literal>long long</literal></para>
</entry><entry colname="colspec1"><para>8 bytes</para>
</entry><entry colname="colspec2"><para>8 bytes</para>
</entry>
</row>
</tbody>
</tgroup>
</table><para>Integer types may be prefixed with the <literal>signed</literal> or <literal>unsigned</literal> qualifier. If no sign qualifier is present, the type is assumed to be signed. The D compiler also provides the type aliases listed in the following table:</para><table frame="topbot" id="tbl-intdefs"><title>D Integer Type Aliases</title><tgroup cols="2" colsep="0" rowsep="0"><?PubTbl tgroup dispwid="6.93in"?><colspec colwidth="1.25in"/><colspec colwidth="3.00in"/><thead><row rowsep="1"><entry><para>Type Name</para>
</entry><entry><para>Description</para>
</entry>
</row>
</thead><tbody><row><entry><para><literal>int8_t</literal></para>
</entry><entry><para>1 byte signed integer</para>
</entry>
</row><row><entry><para><literal>int16_t</literal></para>
</entry><entry><para>2 byte signed integer</para>
</entry>
</row><row><entry><para><literal>int32_t</literal></para>
</entry><entry><para>4 byte signed integer</para>
</entry>
</row><row><entry><para><literal>int64_t</literal></para>
</entry><entry><para>8 byte signed integer</para>
</entry>
</row><row><entry><para><literal>intptr_t</literal></para>
</entry><entry><para>Signed integer of size equal to a pointer</para>
</entry>
</row><row><entry><para><literal>uint8_t</literal></para>
</entry><entry><para>1 byte unsigned integer</para>
</entry>
</row><row><entry><para><literal>uint16_t</literal></para>
</entry><entry><para>2 byte unsigned integer</para>
</entry>
</row><row><entry><para><literal>uint32_t</literal></para>
</entry><entry><para>4 byte unsigned integer</para>
</entry>
</row><row><entry><para><literal>uint64_t</literal></para>
</entry><entry><para>8 byte unsigned integer</para>
</entry>
</row><row><entry><para><literal>uintptr_t</literal></para>
</entry><entry><para>Unsigned integer of size equal to a pointer</para>
</entry>
</row>
</tbody>
</tgroup>
</table><para>These type aliases are equivalent to using the name of the corresponding base type in the previous table and are appropriately defined for each data model. For example, the type name <literal>uint8_t</literal> is an alias for the type <literal>unsigned char</literal>. See <olink targetptr="chp-types" remap="internal">Chapter&nbsp;8, Type and Constant Definitions</olink> for information on how to define your own type aliases for use in your D programs.</para><para>D provides floating-point types for compatibility with ANSI-C declarations and types. Floating-point operators are not supported in D, but floating-point data objects can be traced and formatted using the <function>printf</function> function. The floating-point types listed in the following table may be used:</para><table frame="topbot" id="tbl-fps"><title>D Floating-Point Data Types</title><tgroup cols="3" colsep="0" rowsep="0"><?PubTbl tgroup dispwid="9.04in"?><colspec colname="colspec0" colwidth="32.32*"/><colspec colname="colspec1" colwidth="33.38*"/><colspec colname="colspec2" colwidth="33.29*"/><thead><row><entry rowsep="1"><para>Type Name</para>
</entry><entry rowsep="1"><para>32&ndash;bit Size</para>
</entry><entry rowsep="1"><para>64&ndash;bit Size</para>
</entry>
</row>
</thead><tbody><row><entry><para><literal>float</literal></para>
</entry><entry><para>4 bytes</para>
</entry><entry><para>4 bytes</para>
</entry>
</row><row><entry><para><literal>double</literal></para>
</entry><entry><para>8 bytes</para>
</entry><entry><para>8 bytes</para>
</entry>
</row><row><entry><para><literal>long double</literal></para>
</entry><entry><para>16 bytes</para>
</entry><entry><para>16 bytes</para>
</entry>
</row>
</tbody>
</tgroup>
</table><para>D also provides the special type <literal>string</literal> to represent ASCII strings. Strings are discussed in more detail in <olink targetptr="chp-strings" remap="internal">Chapter&nbsp;6, Strings</olink>.</para>
</sect1><sect1 id="chp-typeopexpr-3"><title>Constants</title><para>Integer constants can be written in decimal (<literal>12345</literal>), octal (<literal>012345</literal>), or hexadecimal (<literal>0x12345</literal>). Octal (base 8) constants must be prefixed with a leading zero. Hexadecimal (base 16) constants must be prefixed with either <literal>0x</literal> or <literal>0X</literal>. Integer constants are assigned the smallest type among <literal>int</literal>, <literal>long</literal>, and <literal>long long</literal> that can represent their value. If the value is negative, the signed version of the type is used. If the value is positive and too large to fit in the signed type representation, the unsigned type representation is used. You can apply one of the following suffixes to any integer constant to explicitly specify its D type:</para><informaltable frame="none"><tgroup cols="2" colsep="0" rowsep="0"><?PubTbl tgroup dispwid="8.97in"?><colspec colwidth="1.00in"/><colspec colwidth="3.50in"/><tbody><row><entry><para><literal>u</literal> or <literal>U</literal></para>
</entry><entry><para><literal>unsigned</literal> version of the type selected by the compiler</para>
</entry>
</row><row><entry><para><literal>l</literal> or <literal>L</literal></para>
</entry><entry><para><literal>long</literal></para>
</entry>
</row><row><entry><para><literal>ul</literal> or <literal>UL</literal></para>
</entry><entry><para><literal>unsigned long</literal></para>
</entry>
</row><row><entry><para><literal>ll</literal> or <literal>LL</literal></para>
</entry><entry><para><literal>long long</literal></para>
</entry>
</row><row><entry><para><literal>ull</literal> or <literal>ULL</literal></para>
</entry><entry><para><literal>unsigned long long</literal></para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable><para>Floating-point constants are always written in decimal and must contain either a decimal point (<literal>12.345</literal>) or an exponent (<literal>123e45</literal>) or both (<literal>123.34e-5</literal>). Floating-point constants are assigned the type <literal>double</literal> by default. You can apply one of the following suffixes to any floating-point constant to explicitly specify its D type:</para><informaltable frame="none"><tgroup cols="2" colsep="0" rowsep="0"><?PubTbl tgroup dispwid="8.97in"?><colspec colwidth="1.00in"/><colspec colwidth="3.50in"/><tbody><row><entry><para><literal>f</literal> or <literal>F</literal></para>
</entry><entry><para><literal>float</literal></para>
</entry>
</row><row><entry><para><literal>l</literal> or <literal>L</literal></para>
</entry><entry><para><literal>long double</literal></para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable><para>Character constants are written as a single character or escape sequence enclosed in a pair of single quotes (<literal>'a'</literal>). Character constants are assigned the type <literal>int</literal> and are equivalent to an integer constant whose value is determined by that character's value in the ASCII character set. You can refer to <olink targetdoc="refman5" targetptr="ascii-5" remap="external"><citerefentry><refentrytitle>ascii</refentrytitle><manvolnum>5</manvolnum></citerefentry></olink> for a list of characters and their values. You can also use any of the special escape sequences shown in the following table in your character constants. D supports the same escape sequences found in ANSI-C.</para><table frame="topbot" id="tbl-escs"><title>D Character Escape Sequences</title><tgroup cols="4" colsep="0" rowsep="0"><colspec colwidth="0.50in"/><colspec colwidth="2.00in"/><colspec colwidth="0.50in"/><colspec colwidth="2.00in"/><tbody><row><entry><para><literal>\a</literal></para>
</entry><entry><para>alert</para>
</entry><entry><para><literal>\\</literal></para>
</entry><entry><para>backslash</para>
</entry>
</row><row><entry><para><literal>\b</literal></para>
</entry><entry><para>backspace</para>
</entry><entry><para><literal>\?</literal></para>
</entry><entry><para>question mark</para>
</entry>
</row><row><entry><para><literal>\f</literal></para>
</entry><entry><para>formfeed</para>
</entry><entry><para><literal>\'</literal></para>
</entry><entry><para>single quote</para>
</entry>
</row><row><entry><para><literal>\n</literal></para>
</entry><entry><para>newline</para>
</entry><entry><para><literal>\&rdquo;</literal></para>
</entry><entry><para>double quote</para>
</entry>
</row><row><entry><para><literal>\r</literal></para>
</entry><entry><para>carriage return</para>
</entry><entry><para><literal>\0</literal><replaceable>oo</replaceable></para>
</entry><entry><para>octal value 0<replaceable>oo</replaceable></para>
</entry>
</row><row><entry><para><literal>\t</literal></para>
</entry><entry><para>horizontal tab</para>
</entry><entry><para><literal>\x</literal><replaceable>hh</replaceable></para>
</entry><entry><para>hexadecimal value 0x<replaceable>hh</replaceable></para>
</entry>
</row><row><entry><para><literal>\v</literal></para>
</entry><entry><para>vertical tab</para>
</entry><entry><para><literal>\0</literal></para>
</entry><entry><para>null character</para>
</entry>
</row>
</tbody>
</tgroup>
</table><para>You can include more than one character specifier inside single quotes to create integers whose individual bytes are initialized according to the corresponding character specifiers. The bytes are read left-to-right from your character constant and assigned to the resulting integer in the order corresponding to the native endian-ness of your operating environment. Up to eight character specifiers can be included in a single character constant.</para><para>Strings constants of any length can be composed by enclosing them in a pair of double quotes (<literal>"hello"</literal>). A string constant may not contain a literal newline character. To create strings containing newlines, use the <literal>\n</literal> escape sequence instead of a literal newline. String constants may contain any of the special character escape sequences shown for character constants above. Similar to ANSI-C, strings are represented as arrays of characters terminated by a null character (<literal>\0</literal>) that is implicitly added to each string constant that you declare. String constants are assigned the special D type <literal>string</literal>. The D compiler provides a set of special features for comparing and tracing character arrays that are declared as strings, as described in <olink targetptr="chp-strings" remap="internal">Chapter&nbsp;6, Strings</olink>.</para>
</sect1><sect1 id="chp-typeopexpr-4"><title>Arithmetic Operators</title><para>D provides the binary arithmetic operators shown in the following table for use in your programs. These operators all have the same meaning for integers as they do in ANSI-C.</para><table frame="topbot" id="tbl-arithops"><title>D Binary Arithmetic Operators</title><tgroup cols="2" colsep="0" rowsep="0"><colspec colname="colspec5" colwidth="0.50in"/><colspec colname="colspec6" colwidth="4.00in"/><tbody><row><entry colname="colspec5"><para><literal>+</literal></para>
</entry><entry colname="colspec6"><para>integer addition</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>-</literal></para>
</entry><entry colname="colspec6"><para>integer subtraction</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>*</literal></para>
</entry><entry colname="colspec6"><para>integer multiplication</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>/</literal></para>
</entry><entry colname="colspec6"><para>integer division</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>%</literal></para>
</entry><entry colname="colspec6"><para>integer modulus</para>
</entry>
</row>
</tbody>
</tgroup>
</table><para>Arithmetic in D may only be performed on integer operands, or on pointers, as discussed in <olink targetptr="chp-pointers" remap="internal">Chapter&nbsp;5, Pointers and Arrays</olink>. Arithmetic may not be performed on floating-point operands in D programs. The DTrace execution environment does not take any action on integer overflow or underflow. You must check for these conditions yourself in situations where overflow and underflow can occur.</para><para>The DTrace execution environment does automatically check for and report division by zero errors resulting from improper use of the <literal>/</literal> and <literal>%</literal> operators. If a D program executes an invalid division operation, DTrace will automatically disable the affected instrumentation and report the error. Errors detected by DTrace have no effect on other DTrace users or on the operating system kernel, so you don't need to worry about causing any damage if your D program inadvertently contains one of these errors.</para><para>In addition to these binary operators, the <literal>+</literal> and <literal>-</literal> operators may also be used as unary operators as well; these operators have higher precedence than any of the binary arithmetic operators. The order of precedence and associativity properties for all the D operators is presented in <olink targetptr="tbl-prec" remap="internal">Table&nbsp;2&ndash;11</olink>. You can control precedence by grouping expressions in parentheses <literal>( )</literal>.</para>
</sect1><sect1 id="chp-typeopexpr-5"><title>Relational Operators</title><para>D provides the binary relational operators shown in the following table for use in your programs. These operators all have the same meaning as they do in ANSI-C.</para><table frame="topbot" id="tbl-relops"><title>D Relational Operators</title><tgroup cols="2" colsep="0" rowsep="0"><?PubTbl tgroup dispwid="7.52in"?><colspec colname="colspec5" colwidth="0.50in"/><colspec colname="colspec6" colwidth="4.00in"/><tbody><row><entry colname="colspec5"><para><literal>&lt;</literal></para>
</entry><entry colname="colspec6"><para>left-hand operand is less than right-operand</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>&lt;=</literal></para>
</entry><entry colname="colspec6"><para>left-hand operand is less than or equal to right-hand operand</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>&gt;</literal></para>
</entry><entry colname="colspec6"><para>left-hand operand is greater than right-hand operand</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>&gt;=</literal></para>
</entry><entry colname="colspec6"><para>left-hand operand is greater than or equal to right-hand operand</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>==</literal></para>
</entry><entry colname="colspec6"><para>left-hand operand is equal to right-hand operand</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>!=</literal></para>
</entry><entry colname="colspec6"><para>left-hand operand is not equal to right-hand operand</para>
</entry>
</row>
</tbody>
</tgroup>
</table><para>Relational operators are most frequently used to write D predicates. Each operator evaluates to a value of type <literal>int</literal> which is equal to one if the condition is true, or zero if it is false.</para><para>Relational operators may be applied to pairs of integers, pointers, or strings. If pointers are compared, the result is equivalent to an integer comparison of the two pointers interpreted as unsigned integers. If strings are compared, the result is determined as if by performing a <olink targetdoc="refman3a" targetptr="strcmp-3c" remap="external"><citerefentry><refentrytitle>strcmp</refentrytitle><manvolnum>3C</manvolnum></citerefentry></olink> on the two operands. Here are some example D string comparisons and their results:</para><informaltable frame="none"><tgroup cols="2" colsep="0" rowsep="0"><colspec colwidth=""/><colspec colwidth=""/><tbody><row><entry><para><literal>"coffee" &lt; "espresso"</literal></para>
</entry><entry><para>... returns 1 (true)</para>
</entry>
</row><row><entry><para><literal>"coffee" == "coffee"</literal></para>
</entry><entry><para>... returns 1 (true)</para>
</entry>
</row><row><entry><para><literal>"coffee" &gt;= "mocha"</literal></para>
</entry><entry><para>... returns 0 (false)</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable><para>Relational operators may also be used to compare a data object associated with an enumeration type with any of the enumerator tags defined by the enumeration. Enumerations are a facility for creating named integer constants and are described in more detail in <olink targetptr="chp-types" remap="internal">Chapter&nbsp;8, Type and Constant Definitions</olink>.</para>
</sect1><sect1 id="chp-typeopexpr-6"><title>Logical Operators</title><para>D provides the following binary logical operators for use in your programs. The first two operators are equivalent to the corresponding ANSI-C operators.</para><table frame="topbot" id="tbl-logops"><title>D Logical Operators</title><tgroup cols="2" colsep="0" rowsep="0"><?PubTbl tgroup dispwid="7.52in"?><colspec colname="colspec5" colwidth="0.50in"/><colspec colname="colspec6" colwidth="4.00in"/><tbody><row><entry colname="colspec5"><para><literal>&amp;&amp;</literal></para>
</entry><entry colname="colspec6"><para>logical <firstterm>AND</firstterm>: true if both operands are true</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>||</literal></para>
</entry><entry colname="colspec6"><para>logical <firstterm>OR</firstterm>: true if one or both operands are true</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>^^</literal></para>
</entry><entry colname="colspec6"><para>logical <firstterm>XOR</firstterm>: true if exactly one operand is true</para>
</entry>
</row>
</tbody>
</tgroup>
</table><para>Logical operators are most frequently used in writing D predicates. The logical AND operator performs short-circuit evaluation: if the left-hand operand is false, the right-hand expression is not evaluated. The logical OR operator also performs short-circuit evaluation: if the left-hand operand is true, the right-hand expression is not evaluated. The logical XOR operator does not short-circuit: both expression operands are always evaluated.</para><para>In addition to the binary logical operators, the unary <literal>!</literal> operator may be used to perform a logical negation of a single operand: it converts a zero operand into a one, and a non-zero operand into a zero. By convention, D programmers use <literal>!</literal> when working with integers that are meant to represent boolean values, and <literal>== 0</literal> when working with non-boolean integers, although both expressions are equivalent in meaning.</para><para>The logical operators may be applied to operands of integer or pointer types. The logical operators interpret pointer operands as unsigned integer values. As with all logical and relational operators in D, operands are true if they have a non-zero integer value and false if they have a zero integer value.</para>
</sect1><sect1 id="chp-typeopexpr-7"><title>Bitwise Operators</title><para>D provides the following binary operators for manipulating individual bits inside of integer operands. These operators all have the same meaning as in ANSI-C.</para><table frame="topbot" id="tbl-bitops"><title>D Bitwise Operators</title><tgroup cols="2" colsep="0" rowsep="0"><?PubTbl tgroup dispwid="8.03in"?><colspec colname="colspec5" colwidth="0.50in"/><colspec colname="colspec6" colwidth="4.00in"/><tbody><row><entry colname="colspec5"><para><literal>&amp;</literal></para>
</entry><entry colname="colspec6"><para>bitwise AND</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>|</literal></para>
</entry><entry colname="colspec6"><para>bitwise OR</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>^</literal></para>
</entry><entry colname="colspec6"><para>bitwise XOR</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>&lt;&lt;</literal></para>
</entry><entry colname="colspec6"><para>shift the left-hand operand left by the number of bits specified by the right-hand operand</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>&gt;&gt;</literal></para>
</entry><entry colname="colspec6"><para>shift the left-hand operand right by the number of bits specified by the right-hand operand</para>
</entry>
</row>
</tbody>
</tgroup>
</table><para>The binary <literal>&amp;</literal> operator is used to clear bits from an integer operand. The binary <literal>|</literal> operator is used to set bits in an integer operand. The binary <literal>^</literal> operator returns one in each bit position where exactly one of the corresponding operand bits is set.</para><para>The shift operators are used to move bits left or right in a given integer operand. Shifting left fills empty bit positions on the right-hand side of the result with zeroes. Shifting right using an unsigned integer operand fills empty bit positions on the left-hand side of the result with zeroes. Shifting right using a signed integer operand fills empty bit positions on the left-hand side with the value of the sign bit, also known as an <firstterm>arithmetic shift</firstterm> operation.</para><para>Shifting an integer value by a negative number of bits or by a number of bits larger than the number of bits in the left-hand operand itself produces an undefined result. The D compiler will produce an error message if the compiler can detect this condition when you compile your D program.</para><para>In addition to the binary logical operators, the unary <literal>~</literal> operator may be used to perform a bitwise negation of a single operand: it converts each zero bit in the operand into a one bit, and each one bit in the operand into a zero bit.</para>
</sect1><sect1 id="chp-typeopexpr-8"><title>Assignment Operators</title><para>D provides the following binary assignment operators for modifying D variables. You can only modify D variables and arrays. Kernel data objects and constants may not be modified using the D assignment operators. The assignment operators have the same meaning as they do in ANSI-C.</para><table frame="topbot" id="tbl-asgnops"><title>D Assignment Operators</title><tgroup cols="2" colsep="0" rowsep="0"><?PubTbl tgroup dispwid="8.03in"?><colspec colname="colspec5" colwidth="0.50in"/><colspec colname="colspec6" colwidth="4.00in"/><tbody><row><entry colname="colspec5"><para><literal>=</literal></para>
</entry><entry colname="colspec6"><para>set the left-hand operand equal to the right-hand expression value</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>+=</literal></para>
</entry><entry colname="colspec6"><para>increment the left-hand operand by the right-hand expression value</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>-=</literal></para>
</entry><entry colname="colspec6"><para>decrement the left-hand operand by the right-hand expression value</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>*=</literal></para>
</entry><entry colname="colspec6"><para>multiply the left-hand operand by the right-hand expression value</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>/=</literal></para>
</entry><entry colname="colspec6"><para>divide the left-hand operand by the right-hand expression value</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>%=</literal></para>
</entry><entry colname="colspec6"><para>modulo the left-hand operand by the right-hand expression value</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>|=</literal></para>
</entry><entry colname="colspec6"><para>bitwise OR the left-hand operand with the right-hand expression value</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>&amp;=</literal></para>
</entry><entry colname="colspec6"><para>bitwise AND the left-hand operand with the right-hand expression value</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>^=</literal></para>
</entry><entry colname="colspec6"><para>bitwise XOR the left-hand operand with the right-hand expression value</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>&lt;&lt;=</literal></para>
</entry><entry colname="colspec6"><para>shift the left-hand operand left by the number of bits specified by the right-hand expression value</para>
</entry>
</row><row><entry colname="colspec5"><para><literal>&gt;&gt;=</literal></para>
</entry><entry colname="colspec6"><para>shift the left-hand operand right by the number of bits specified by the right-hand expression value</para>
</entry>
</row>
</tbody>
</tgroup>
</table><para>Aside from the assignment operator <literal>=</literal>, the other assignment operators are provided as shorthand for using the <literal>=</literal> operator with one of the other operators described earlier. For example, the expression <literal>x = x + 1</literal> is equivalent to the expression <literal>x += 1</literal>, except that the expression <literal>x</literal> is evaluated once. These assignment operators obey the same rules for operand types as the binary forms described earlier.</para><para>The result of any assignment operator is an expression equal to the new value of the left-hand expression. You can use the assignment operators or any of the operators described so far in combination to form expressions of arbitrary complexity. You can use parentheses <literal>( )</literal> to group terms in complex expressions.</para>
</sect1><sect1 id="chp-typeopexpr-9"><title>Increment and Decrement Operators</title><para>D provides the special unary <literal>++</literal> and <literal>--</literal> operators for incrementing and decrementing pointers and integers. These operators have the same meaning as in ANSI-C. These operators can only be applied to variables, and may be applied either before or after the variable name. If the operator appears before the variable name, the variable is first modified and then the resulting expression is equal to the new value of the variable. For example, the following two expressions produce identical results:</para><informaltable frame="none"><tgroup cols="2" colsep="0" rowsep="0"><?PubTbl tgroup dispwid="8.05in"?><colspec colwidth="0.99*"/><colspec colwidth="1.01*"/><tbody><row><entry><para><literal>x += 1;</literal></para>
</entry><entry><para><literal>y = ++x;</literal></para>
</entry>
</row><row><entry><para><literal>y = x;</literal></para>
</entry><entry><para></para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable><para>If the operator appears after the variable name, then the variable is modified after its current value is returned for use in the expression. For example, the following two expressions produce identical results:</para><informaltable frame="none"><tgroup cols="2" colsep="0" rowsep="0"><?PubTbl tgroup dispwid="8.05in"?><colspec colwidth="0.99*"/><colspec colwidth="1.01*"/><tbody><row><entry><para><literal>y = x;</literal></para>
</entry><entry><para><literal>y = x--;</literal></para>
</entry>
</row><row><entry><para><literal>x -= 1;</literal></para>
</entry><entry><para></para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable><para>You can use the increment and decrement operators to create new variables without declaring them. If a variable declaration is omitted and the increment or decrement operator is applied to a variable, the variable is implicitly declared to be of type <literal>int64_t</literal>.</para><para>The increment and decrement operators can be applied to integer or pointer variables. When applied to integer variables, the operators increment or decrement the corresponding value by one. When applied to pointer variables, the operators increment or decrement the pointer address by the size of the data type referenced by the pointer. Pointers and pointer arithmetic in D are discussed in <olink targetptr="chp-pointers" remap="internal">Chapter&nbsp;5, Pointers and Arrays</olink>.</para>
</sect1><sect1 id="chp-typeopexpr-10"><title>Conditional Expressions</title><para>Although D does not provide support for if-then-else constructs, it does provide support for simple conditional expressions using the <literal>?</literal> and <literal>:</literal> operators. These operators enable a triplet of expressions to be associated where the first expression is used to conditionally evaluate one of the other two. For example, the following D statement could be used to set a variable <literal>x</literal> to one of two strings depending on the value of <literal>i</literal>:</para><programlisting>x = i == 0 ? "zero" : "non-zero";</programlisting><para>In this example, the expression <literal>i == 0</literal> is first evaluated to determine whether it is true or false. If the first expression is true, the second expression is evaluated and the <literal>?:</literal> expression returns its value. If the first expression is false, the third expression is evaluated and the <literal>?:</literal> expression return its value.</para><para>As with any D operator, you can use multiple <literal>?:</literal> operators in a single expression to create more complex expressions. For example, the following expression would take a <literal>char</literal> variable <literal>c</literal> containing one of the characters 0-9, a-z, or A-Z and return the value of this character when interpreted as a digit in a hexadecimal (base 16) integer:</para><programlisting>hexval = (c &gt;= '0' &amp;&amp; c &lt;= '9') ? c - '0' :
    (c &gt;= 'a' &amp;&amp; c &lt;= 'z') ? c + 10 - 'a' : c + 10 - 'A';</programlisting><para>The first expression used with <literal>?:</literal> must be a pointer or integer in order to be evaluated for its truth value. The second and third expressions may be of any compatible types. You may not construct a conditional expression where, for example, one path returns a string and another path returns an integer. The second and third expressions also may not invoke a tracing function such as <function>trace</function> or <function>printf</function>. If you want to conditionally trace data, use a predicate instead, as discussed in <olink targetptr="chp-intro" remap="internal">Chapter&nbsp;1, Introduction</olink>.</para>
</sect1><sect1 id="chp-typeopexpr-11"><title>Type Conversions</title><para>When expressions are constructed using operands of different but compatible types, type conversions are performed in order to determine the type of the resulting expression. The D rules for type conversions are the same as the arithmetic conversion rules for integers in ANSI-C. These rules are sometimes referred to as the <firstterm>usual arithmetic conversions</firstterm>.</para><para>A simple way to describe the conversion rules is as follows: each integer type is ranked in the order <literal>char, short, int, long, long long</literal>, with the corresponding unsigned types assigned a rank above its signed equivalent but below the next integer type. When you construct an expression using two integer operands such as <literal>x + y</literal> and the operands are of different integer types, the operand type with the highest rank is used as the result type.</para><para>If a conversion is required, the operand of lower rank is first <firstterm>promoted</firstterm> to the type of higher rank. Promotion does not actually change the value of the operand: it simply extends the value to a larger container according to its sign. If an unsigned operand is promoted, the unused high-order bits of the resulting integer are filled with zeroes. If a signed operand is promoted, the unused high-order bits are filled by performing sign extension. If a signed type is converted to an unsigned type, the signed type is first sign-extended and then assigned the new unsigned type determined by the conversion.</para><para>Integers and other types can also be explicitly <firstterm>cast</firstterm> from one type to another. In D, pointers and integers can be cast to any integer or pointer types, but not to other types. Rules for casting and promoting strings and character arrays are discussed in <olink targetptr="chp-strings" remap="internal">Chapter&nbsp;6, Strings</olink>. An integer or pointer cast is formed using an expression such as:</para><programlisting>y = (int)x;</programlisting><para>where the destination type is enclosed in parentheses and used to prefix the source expression. Integers are cast to types of higher rank by performing promotion. Integers are cast to types of lower rank by zeroing the excess high-order bits of the integer.</para><para>Because D does not permit floating-point arithmetic, no floating-point operand conversion or casting is permitted and no rules for implicit floating-point conversion are defined.</para>
</sect1><sect1 id="chp-typeopexpr-12"><title>Precedence</title><para>The D rules for operator precedence and associativity are described in the following table. These rules are somewhat complex, but are necessary to provide precise compatibility with the ANSI-C operator precedence rules. The table entries are in order from highest precedence to lowest precedence.</para><table frame="topbot" id="tbl-prec"><title>D Operator Precedence and Associativity</title><tgroup cols="2" colsep="0" rowsep="0"><?PubTbl tgroup dispwid="8.25in"?><colspec colwidth="4.00in"/><colspec colwidth="1.00in"/><thead><row rowsep="1"><entry><para>Operators</para>
</entry><entry><para>Associativity</para>
</entry>
</row>
</thead><tbody><row><entry><para><literal>() [] -&gt; .</literal></para>
</entry><entry><para>left to right</para>
</entry>
</row><row><entry><para><literal>! ~ ++ -- + - * &amp; (</literal><replaceable>type</replaceable><literal>) sizeof stringof offsetof xlate</literal></para>
</entry><entry><para>right to left</para>
</entry>
</row><row><entry><para><literal>* / %</literal></para>
</entry><entry><para>left to right</para>
</entry>
</row><row><entry><para><literal>+ -</literal></para>
</entry><entry><para>left to right</para>
</entry>
</row><row><entry><para><literal>&lt;&lt; &gt;&gt;</literal></para>
</entry><entry><para>left to right</para>
</entry>
</row><row><entry><para><literal>&lt; &lt;= &gt; &gt;=</literal></para>
</entry><entry><para>left to right</para>
</entry>
</row><row><entry><para><literal>== !=</literal></para>
</entry><entry><para>left to right</para>
</entry>
</row><row><entry><para><literal>&amp;</literal></para>
</entry><entry><para>left to right</para>
</entry>
</row><row><entry><para><literal>^</literal></para>
</entry><entry><para>left to right</para>
</entry>
</row><row><entry><para><literal>|</literal></para>
</entry><entry><para>left to right</para>
</entry>
</row><row><entry><para><literal>&amp;&amp;</literal></para>
</entry><entry><para>left to right</para>
</entry>
</row><row><entry><para><literal>^^</literal></para>
</entry><entry><para>left to right</para>
</entry>
</row><row><entry><para><literal>||</literal></para>
</entry><entry><para>left to right</para>
</entry>
</row><row><entry><para><literal>?:</literal></para>
</entry><entry><para>right to left</para>
</entry>
</row><row><entry><para><literal>= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;=</literal></para>
</entry><entry><para>right to left</para>
</entry>
</row><row><entry><para><literal>,</literal></para>
</entry><entry><para>left to right</para>
</entry>
</row>
</tbody>
</tgroup>
</table><para>There are several operators in the table that we have not yet discussed; these will be covered in subsequent chapters:</para><informaltable frame="none"><tgroup cols="2" colsep="0" rowsep="0"><colspec colname="colspec11" colwidth="1.00in"/><colspec colname="colspec12" colwidth="4.00in"/><tbody><row><entry><para><literal>sizeof</literal></para>
</entry><entry><para>Computes the size of an object (<olink targetptr="chp-structs" remap="internal">Chapter&nbsp;7, Structs and Unions</olink>)</para>
</entry>
</row><row><entry><para><literal>offsetof</literal></para>
</entry><entry><para>Computes the offset of a type member (<olink targetptr="chp-structs" remap="internal">Chapter&nbsp;7, Structs and Unions</olink>)</para>
</entry>
</row><row><entry><para><literal>stringof</literal></para>
</entry><entry><para>Converts the operand to a string (<olink targetptr="chp-strings" remap="internal">Chapter&nbsp;6, Strings</olink>)</para>
</entry>
</row><row><entry colname="colspec11"><para><literal>xlate</literal></para>
</entry><entry colname="colspec12"><para>Translates a data type (<olink targetptr="chp-xlate" remap="internal">Chapter&nbsp;40, Translators</olink>)</para>
</entry>
</row><row><entry><para>unary <literal>&amp;</literal></para>
</entry><entry><para>Computes the address of an object (<olink targetptr="chp-pointers" remap="internal">Chapter&nbsp;5, Pointers and Arrays</olink>)</para>
</entry>
</row><row><entry><para>unary <literal>*</literal></para>
</entry><entry><para>Dereferences
a pointer to an object (<olink targetptr="chp-pointers" remap="internal">Chapter&nbsp;5, Pointers and Arrays</olink>)</para>
</entry>
</row><row><entry><para><literal>-&gt;</literal> and <literal>.</literal></para>
</entry><entry><para>Accesses a member of a structure or union type (<olink targetptr="chp-structs" remap="internal">Chapter&nbsp;7, Structs and Unions</olink>)</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable><para>The comma (<literal>,</literal>) operator listed in the table is for compatibility with the ANSI-C comma operator, which can be used to evaluate a set of expressions in left-to-right order and return the value of the rightmost expression. This operator is provided strictly for compatibility with C and should generally not be used.</para><para>The <literal>()</literal> entry in the table of operator precedence represents a function call; examples of calls to functions such as <function>printf</function> and <function>trace</function> are presented in <olink targetptr="chp-intro" remap="internal">Chapter&nbsp;1, Introduction</olink>. A comma is also used in D to list arguments to functions and to form lists of associative array keys. This comma is not the same as the comma operator and does <emphasis>not</emphasis> guarantee left-to-right evaluation. The D compiler provides no guarantee as to the order of evaluation of arguments to a function or keys to an associative array. You should be careful of using expressions with interacting side-effects, such as the pair of expressions <literal>i</literal> and <literal>i++</literal>, in these contexts.</para><para>The <literal>[]</literal> entry in the table of operator precedence represents an array or associative array reference. Examples of associative arrays are presented in <olink targetptr="chp-intro" remap="internal">Chapter&nbsp;1, Introduction</olink>. A special kind of associative array called an <firstterm>aggregation</firstterm> is described in <olink targetptr="chp-aggs" remap="internal">Chapter&nbsp;9, Aggregations</olink>. The <literal>[]</literal> operator can also be used to index into fixed-size C arrays as well, as described in <olink targetptr="chp-pointers" remap="internal">Chapter&nbsp;5, Pointers and Arrays</olink>.</para>
</sect1>
</chapter>
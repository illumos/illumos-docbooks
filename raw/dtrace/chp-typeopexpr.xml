<chapter xml:id="chp-typeopexpr">
<title>Types, Operators, and Expressions</title>
<para><phrase role="first-word">D provides the ability</phrase> to access and
manipulate a variety of data objects: variables and data structures can be
created and modified, data objects defined in the operating system kernel and
user processes can be accessed, and integer, floating-point, and string
constants can be declared. D provides a superset of the ANSI-C operators that
are used to manipulate objects and create complex expressions. This chapter
describes the detailed set of rules for types, operators, and
expressions.</para>
<sect1 xml:id="chp-typeopexpr-1">
<title>Identifier Names and Keywords</title>
<para>D identifier names are composed of upper case and lower case letters,
digits, and underbars where the first character must be a letter or underbar.
All identifier names beginning with an underbar (<literal>_</literal>) are
reserved for use by the D system libraries. You should avoid using such names in
your D programs. By convention, D programmers typically use mixed-case names for
variables and all upper case names for constants.</para>
<para>D language keywords are special identifiers reserved for use in the
programming language syntax itself. These names are always specified in lower
case and may not be used for the names of D variables.</para>
<table remap="1" frame="topbot" xml:id="tbl-keywords">
<title>D Keywords</title>
<tgroup cols="3" colsep="0" rowsep="0">
<colspec colname="colspec0" colwidth="32.74*" />
<colspec colname="colspec1" colwidth="33.35*" />
<colspec colname="colspec2" colwidth="32.89*" />
<tbody>
	<row>
		<entry><para><literal>auto</literal><superscript>*</superscript><literal></literal></para></entry>
		<entry><para><literal>goto</literal><superscript>*</superscript><literal></literal></para></entry>
		<entry><para><literal>sizeof</literal></para></entry>
	</row>
	<row>
		<entry><para><literal>break</literal><superscript>*</superscript><literal></literal></para></entry>
		<entry><para><literal>if</literal><superscript>*</superscript><literal></literal></para></entry>
		<entry><para><literal>static</literal><superscript>*</superscript><literal></literal></para></entry>
	</row>
	<row>
		<entry><para><literal>case</literal><superscript>*</superscript><literal></literal></para></entry>
		<entry><para><literal>import</literal><superscript>*</superscript><literal></literal><superscript>+</superscript><literal></literal></para></entry>
		<entry><para><literal>string</literal><superscript>+</superscript><literal></literal></para></entry>
	</row>
	<row>
		<entry><para><literal>char</literal></para></entry>
		<entry><para><literal>inline</literal></para></entry>
		<entry><para><literal>stringof</literal><superscript>+</superscript><literal></literal></para></entry>
	</row>
	<row>
		<entry><para><literal>const</literal></para></entry>
		<entry><para><literal>int</literal></para></entry>
		<entry><para><literal>struct</literal></para></entry>
	</row>
	<row>
		<entry><para><literal>continue</literal><superscript>*</superscript><literal></literal></para></entry>
		<entry><para><literal>long</literal></para></entry>
		<entry><para><literal>switch</literal><superscript>*</superscript><literal></literal></para></entry>
	</row>
	<row>
		<entry><para><literal>counter</literal><superscript>*</superscript><literal></literal><superscript>+</superscript><literal></literal></para></entry>
		<entry><para><literal>offsetof</literal><superscript>+</superscript><literal></literal></para></entry>
		<entry><para><literal>this</literal><superscript>+</superscript><literal></literal></para></entry>
	</row>
	<row>
		<entry><para><literal>default</literal><superscript>*</superscript><literal></literal></para></entry>
		<entry><para><literal>probe</literal><superscript>*</superscript><literal></literal><superscript>+</superscript><literal></literal></para></entry>
		<entry><para><literal>translator</literal><superscript>+</superscript><literal></literal></para></entry>
	</row>
	<row>
		<entry><para><literal>do</literal><superscript>*</superscript><literal></literal></para></entry>
		<entry><para><literal>provider</literal><superscript>*</superscript><literal></literal><superscript>+</superscript><literal></literal></para></entry>
		<entry><para><literal>typedef</literal></para></entry>
	</row>
	<row>
		<entry><para><literal>double</literal></para></entry>
		<entry><para><literal>register</literal><superscript>*</superscript><literal></literal></para></entry>
		<entry><para><literal>union</literal></para></entry>
	</row>
	<row>
		<entry><para><literal>else</literal><superscript>*</superscript><literal></literal></para></entry>
		<entry><para><literal>restrict</literal><superscript>*</superscript><literal></literal></para></entry>
		<entry><para><literal>unsigned</literal></para></entry>
	</row>
	<row>
		<entry><para><literal>enum</literal></para></entry>
		<entry><para><literal>return</literal><superscript>*</superscript><literal></literal></para></entry>
		<entry><para><literal>void</literal></para></entry>
	</row>
	<row>
		<entry><para><literal>extern</literal></para></entry>
		<entry><para><literal>self</literal><superscript>+</superscript><literal></literal></para></entry>
		<entry><para><literal>volatile</literal></para></entry>
	</row>
	<row>
		<entry colname="colspec0"><para><literal>float</literal></para></entry>
		<entry colname="colspec1"><para><literal>short</literal></para></entry>
		<entry colname="colspec2"><para><literal>while</literal><superscript>*</superscript><literal></literal></para></entry>
	</row>
	<row>
		<entry colname="colspec0"><para><literal>for</literal><superscript>*</superscript><literal></literal></para></entry>
		<entry colname="colspec1"><para><literal>signed</literal></para></entry>
		<entry colname="colspec2"><para><literal>xlate</literal><superscript>+</superscript><literal></literal></para></entry>
	</row>
</tbody>
</tgroup>
</table><para>D reserves for use as keywords a superset of the ANSI-C keywords. The keywords reserved for future use by the D language are marked with &ldquo;<literal></literal><superscript>*</superscript><literal></literal>&rdquo;. The D compiler will produce a syntax error if you attempt to use a keyword that is reserved for future use. The keywords defined by D but not defined by ANSI-C are marked with &ldquo;<literal></literal><superscript>+</superscript><literal></literal>&rdquo;. D provides the complete set of types and operators found in ANSI-C. The major difference in D programming is the absence of control-flow constructs. Keywords associated with control-flow in ANSI-C are reserved for future use in D.</para>
</sect1>
<sect1 xml:id="chp-typeopexpr-2">
<title>Data Types and Sizes</title>
<para>D provides fundamental data types for integers and floating-point constants. Arithmetic may only be performed on integers in D programs. Floating-point constants may be used to initialize data structures, but floating-point arithmetic is not permitted in D. D provides a 32-bit and 64-bit data model for use in writing programs. The data model used when executing your program is the native data model associated with the active operating system kernel. You can determine the native data model for your system using <command>isainfo</command> <option>b</option>.</para>
<para>The names of the integer types and their sizes in each of the two data models are shown in the following table. Integers are always represented in twos-complement form in the native byte-encoding order of your system.</para>
<table frame="topbot" xml:id="tbl-ints">
<title>D Integer Data Types</title>
<tgroup cols="3" colsep="0" rowsep="0">
<colspec colname="colspec0" colwidth="1*" />
<colspec colname="colspec1" colwidth="1*" />
<colspec colname="colspec2" colwidth="1*" />
<thead valign="top">
	<row>
		<entry rowsep="1"><para>Type Name</para></entry>
		<entry rowsep="1"><para>32&ndash;bit Size</para></entry>
		<entry rowsep="1"><para>64&ndash;bit Size</para></entry>
	</row>
</thead>
<tbody>
	<row>
		<entry><para><literal>char</literal></para></entry>
		<entry><para>1 byte</para></entry>
		<entry><para>1 byte</para></entry>
	</row>
	<row>
		<entry><para><literal>short</literal></para></entry>
		<entry><para>2 bytes</para></entry>
		<entry><para>2 bytes</para></entry>
	</row>
	<row>
		<entry><para><literal>int</literal></para></entry>
		<entry><para>4 bytes</para></entry>
		<entry><para>4 bytes</para></entry>
	</row>
	<row>
		<entry><para><literal>long</literal></para></entry>
		<entry><para>4 bytes</para></entry>
		<entry><para>8 bytes</para></entry>
	</row>
	<row>
		<entry colname="colspec0"><para><literal>long long</literal></para></entry>
		<entry colname="colspec1"><para>8 bytes</para></entry>
		<entry colname="colspec2"><para>8 bytes</para></entry>
	</row>
</tbody>
</tgroup>
</table>
<para>Integer types may be prefixed with the <literal>signed</literal> or <literal>unsigned</literal> qualifier. If no sign qualifier is present, the type is assumed to be signed. The D compiler also provides the type aliases listed in the following table:</para>
<table frame="topbot" xml:id="tbl-intdefs">
<title>D Integer Type Aliases</title>
<tgroup cols="2" colsep="0" rowsep="0">
<colspec colwidth="1*" />
<colspec colwidth="2*" />
<thead>
	<row rowsep="1">
		<entry><para>Type Name</para></entry>
		<entry><para>Description</para></entry>
	</row>
</thead>
<tbody>
	<row>
		<entry><para><literal>int8_t</literal></para></entry>
		<entry><para>1 byte signed integer</para></entry>
	</row>
	<row>
		<entry><para><literal>int16_t</literal></para></entry>
		<entry><para>2 byte signed integer</para></entry>
	</row>
	<row>
		<entry><para><literal>int32_t</literal></para></entry>
		<entry><para>4 byte signed integer</para></entry>
	</row>
	<row>
		<entry><para><literal>int64_t</literal></para></entry>
		<entry><para>8 byte signed integer</para></entry>
	</row>
	<row>
		<entry><para><literal>intptr_t</literal></para></entry>
		<entry><para>Signed integer of size equal to a pointer</para></entry>
	</row>
	<row>
		<entry><para><literal>uint8_t</literal></para></entry>
		<entry><para>1 byte unsigned integer</para></entry>
	</row>
	<row>
		<entry><para><literal>uint16_t</literal></para></entry>
		<entry><para>2 byte unsigned integer</para></entry>
	</row>
	<row>
		<entry><para><literal>uint32_t</literal></para></entry>
		<entry><para>4 byte unsigned integer</para></entry>
	</row>
	<row>
		<entry><para><literal>uint64_t</literal></para></entry>
		<entry><para>8 byte unsigned integer</para></entry>
	</row>
	<row>
		<entry><para><literal>uintptr_t</literal></para></entry>
		<entry><para>Unsigned integer of size equal to a pointer</para></entry>
	</row>
</tbody>
</tgroup>
</table>
<para>These type aliases are equivalent to using the name of the corresponding base type in the previous table and are appropriately defined for each data model. For example, the type name <literal>uint8_t</literal> is an alias for the type <literal>unsigned char</literal>. See <xref linkend="chp-types" /> for information on how to define your own type aliases for use in your D programs.</para>
<para>D provides floating-point types for compatibility with ANSI-C declarations and types. Floating-point operators are not supported in D, but floating-point data objects can be traced and formatted using the <function>printf</function> function. The floating-point types listed in the following table may be used:</para>
<table frame="topbot" xml:id="tbl-fps">
<title>D Floating-Point Data Types</title>
<tgroup cols="3" colsep="0" rowsep="0">
	<colspec colname="colspec0" colwidth="1*" />
	<colspec colname="colspec1" colwidth="1*" />
	<colspec colname="colspec2" colwidth="1*" />
	<thead>
		<row>
			<entry rowsep="1"><para>Type Name</para></entry>
			<entry rowsep="1"><para>32&ndash;bit Size</para></entry>
			<entry rowsep="1"><para>64&ndash;bit Size</para></entry>
		</row>
	</thead>
	<tbody>
		<row>
			<entry><para><literal>float</literal></para></entry>
			<entry><para>4 bytes</para></entry>
			<entry><para>4 bytes</para></entry>
		</row>
		<row>
			<entry><para><literal>double</literal></para></entry>
			<entry><para>8 bytes</para></entry>
			<entry><para>8 bytes</para></entry>
		</row>
		<row>
			<entry><para><literal>long double</literal></para></entry>
			<entry><para>16 bytes</para></entry>
			<entry><para>16 bytes</para></entry>
		</row>
	</tbody>
</tgroup>
</table>
<para>D also provides the special type <literal>string</literal> to represent ASCII strings. Strings are
discussed in more detail in <xref linkend="chp-strings" />.</para>
</sect1>
<sect1 xml:id="chp-typeopexpr-3">
<title>Constants</title>
<para>Integer constants can be written in decimal (<literal>12345</literal>), octal (<literal>012345</literal>), or hexadecimal (<literal>0x12345</literal>). Octal (base 8) constants must be prefixed with a leading zero. Hexadecimal (base 16) constants must be prefixed with either <literal>0x</literal> or <literal>0X</literal>. Integer constants are assigned the smallest type among <literal>int</literal>, <literal>long</literal>, and <literal>long long</literal> that can represent their value. If the value is negative, the signed version of the type is used. If the value is positive and too large to fit in the signed type representation, the unsigned type representation is used. You can apply one of the following suffixes to any integer constant to explicitly specify its D type:</para>
<informaltable frame="none">
<tgroup cols="2" colsep="0" rowsep="0">
<colspec colwidth="1*" />
<colspec colwidth="3.5*" />
<tbody>
	<row>
		<entry><para><literal>u</literal> or <literal>U</literal></para></entry>
		<entry><para><literal>unsigned</literal> version of the type selected by the compiler</para></entry>
	</row>
	<row>
		<entry><para><literal>l</literal> or <literal>L</literal></para></entry>
		<entry><para><literal>long</literal></para></entry>
	</row>
	<row>
		<entry><para><literal>ul</literal> or <literal>UL</literal></para></entry>
		<entry><para><literal>unsigned long</literal></para></entry>
	</row>
	<row>
		<entry><para><literal>ll</literal> or <literal>LL</literal></para></entry>
		<entry><para><literal>long long</literal></para></entry>
	</row>
	<row>
		<entry><para><literal>ull</literal> or <literal>ULL</literal></para></entry>
		<entry><para><literal>unsigned long long</literal></para></entry>
	</row>
</tbody>
</tgroup>
</informaltable>
<para>Floating-point constants are always written in decimal and must contain either a decimal point
(<literal>12.345</literal>) or an exponent (<literal>123e45</literal>) or both (<literal>123.34e-5</literal>).
Floating-point constants are assigned the type <literal>double</literal> by default. You can apply one of the
following suffixes to any floating-point constant to explicitly specify its D type:</para>
<informaltable frame="none">
<tgroup cols="2" colsep="0" rowsep="0">
<colspec colwidth="1*" />
<colspec colwidth="3.5*" />
<tbody>
	<row>
		<entry><para><literal>f</literal> or <literal>F</literal></para></entry>
		<entry><para><literal>float</literal></para></entry>
	</row>
	<row>
		<entry><para><literal>l</literal> or <literal>L</literal></para></entry>
		<entry><para><literal>long double</literal></para></entry>
	</row>
</tbody>
</tgroup>
</informaltable>
<para>Character constants are written as a single character or escape sequence enclosed in a pair of single
quotes (<literal>'a'</literal>). Character constants are assigned the type <literal>int</literal> and are
equivalent to an integer constant whose value is determined by that character's value in the ASCII character
set. You can refer to <citerefentry><refentrytitle>ascii</refentrytitle><manvolnum>5</manvolnum></citerefentry> for a list of
characters and their values. You can also use any of the special escape sequences shown in the following table
in your character constants. D supports the same escape sequences found in ANSI-C.</para>
<table frame="topbot" xml:id="tbl-escs">
<title>D Character Escape Sequences</title>
<tgroup cols="4" colsep="0" rowsep="0">
<colspec colwidth="1*" />
<colspec colwidth="4*" />
<colspec colwidth="1*" />
<colspec colwidth="4*" />
<tbody>
	<row>
		<entry><para><literal>\a</literal></para></entry>
		<entry><para>alert</para></entry>
		<entry><para><literal>\\</literal></para></entry>
		<entry><para>backslash</para></entry>
	</row>
	<row>
		<entry><para><literal>\b</literal></para></entry>
		<entry><para>backspace</para></entry>
		<entry><para><literal>\?</literal></para></entry>
		<entry><para>question mark</para></entry>
	</row>
	<row>
		<entry><para><literal>\f</literal></para></entry>
		<entry><para>formfeed</para></entry>
		<entry><para><literal>\'</literal></para></entry>
		<entry><para>single quote</para></entry>
	</row>
	<row>
		<entry><para><literal>\n</literal></para></entry>
		<entry><para>newline</para></entry>
		<entry><para><literal>\&rdquo;</literal></para></entry>
		<entry><para>double quote</para></entry>
	</row>
	<row>
		<entry><para><literal>\r</literal></para></entry>
		<entry><para>carriage return</para></entry>
		<entry><para><literal>\0</literal><replaceable>oo</replaceable></para></entry>
		<entry><para>octal value 0<replaceable>oo</replaceable></para></entry>
	</row>
	<row>
		<entry><para><literal>\t</literal></para></entry>
		<entry><para>horizontal tab</para></entry>
		<entry><para><literal>\x</literal><replaceable>hh</replaceable></para></entry>
		<entry><para>hexadecimal value 0x<replaceable>hh</replaceable></para></entry>
	</row>
	<row>
		<entry><para><literal>\v</literal></para></entry>
		<entry><para>vertical tab</para></entry>
		<entry><para><literal>\0</literal></para></entry>
		<entry><para>null character</para></entry>
	</row>
</tbody>
</tgroup>
</table>
<para>You can include more than one character specifier inside single quotes to
create integers whose individual bytes are initialized according to the
corresponding character specifiers. The bytes are read left-to-right from your
character constant and assigned to the resulting integer in the order
corresponding to the native endianness of your operating environment. Up to
eight character specifiers can be included in a single character
constant.</para>
<para>Strings constants of any length can be composed by enclosing them in a
pair of double quotes (<literal>"hello"</literal>). A string constant may not
contain a literal newline character. To create strings containing newlines, use
the <literal>\n</literal> escape sequence instead of a literal newline. String
constants may contain any of the special character escape sequences shown for
character constants above. Similar to ANSI-C, strings are represented as arrays
of characters terminated by a null character (<literal>\0</literal>) that is
implicitly added to each string constant that you declare. String constants are
assigned the special D type <literal>string</literal>. The D compiler provides a
set of special features for comparing and tracing character arrays that are
declared as strings, as described in <xref linkend="chp-strings" />.</para>
</sect1>
<sect1 xml:id="chp-typeopexpr-4">
<title>Arithmetic Operators</title>
<para>D provides the binary arithmetic operators shown in the following table
for use in your programs. These operators all have the same meaning for integers
as they do in ANSI-C.</para>
<table frame="topbot" xml:id="tbl-arithops">
<title>D Binary Arithmetic Operators</title>
<tgroup cols="2" colsep="0" rowsep="0">
<colspec colname="colspec5" colwidth="1*" />
<colspec colname="colspec6" colwidth="8*" align="justify" />
<tbody valign="top">
	<row>
		<entry colname="colspec5"><para><literal>+</literal></para></entry>
		<entry colname="colspec6"><para>integer addition</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>-</literal></para></entry>
		<entry colname="colspec6"><para>integer subtraction</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>*</literal></para></entry>
		<entry colname="colspec6"><para>integer multiplication</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>/</literal></para></entry>
		<entry colname="colspec6"><para>integer division</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>%</literal></para></entry>
		<entry colname="colspec6"><para>integer modulus</para></entry>
	</row>
</tbody>
</tgroup>
</table>
<para>Arithmetic in D may only be performed on integer operands, or on pointers,
as discussed in <xref linkend="chp-pointers" />. Arithmetic may not be performed
on floating-point operands in D programs. The DTrace execution environment does
not take any action on integer overflow or underflow. You must check for these
conditions yourself in situations where overflow and underflow can occur.</para>
<para>The DTrace execution environment does automatically check for and report
division by zero errors resulting from improper use of the <literal>/</literal>
and <literal>%</literal> operators. If a D program executes an invalid division
operation, DTrace will automatically disable the affected instrumentation and
report the error. Errors detected by DTrace have no effect on other DTrace users
or on the operating system kernel, so you don't need to worry about causing any
damage if your D program inadvertently contains one of these errors.</para>
<para>In addition to these binary operators, the <literal>+</literal> and
<literal>-</literal> operators may also be used as unary operators as well;
these operators have higher precedence than any of the binary arithmetic
operators. The order of precedence and associativity properties for all the D
operators is presented in <xref linkend="tbl-prec" />. You can control
precedence by grouping expressions in parentheses <literal>( )</literal>.</para>
</sect1>
<sect1 xml:id="chp-typeopexpr-5">
<title>Relational Operators</title>
<para>D provides the binary relational operators shown in the following table
for use in your programs. These operators all have the same meaning as they do
in ANSI-C.</para>
<table frame="topbot" xml:id="tbl-relops">
<title>D Relational Operators</title>
<tgroup cols="2" colsep="0" rowsep="0">
<colspec colname="colspec5" colwidth="1*" />
<colspec colname="colspec6" colwidth="8*" align="justify" />
<tbody valign="top">
	<row>
		<entry colname="colspec5"><para><literal>&lt;</literal></para></entry>
		<entry colname="colspec6"><para>left-hand operand is less than right-operand</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>&lt;=</literal></para></entry>
		<entry colname="colspec6"><para>left-hand operand is less than or equal to right-hand operand</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>&gt;</literal></para></entry>
		<entry colname="colspec6"><para>left-hand operand is greater than right-hand operand</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>&gt;=</literal></para></entry>
		<entry colname="colspec6"><para>left-hand operand is greater than or equal to right-hand operand</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>==</literal></para></entry>
		<entry colname="colspec6"><para>left-hand operand is equal to right-hand operand</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>!=</literal></para></entry>
		<entry colname="colspec6"><para>left-hand operand is not equal to right-hand operand</para></entry>
	</row>
</tbody>
</tgroup>
</table>
<para>Relational operators are most frequently used to write D predicates. Each operator evaluates to a value
of type <literal>int</literal> which is equal to one if the condition is true, or zero if it is false.</para>
<para>Relational operators may be applied to pairs of integers, pointers, or strings. If pointers are
compared, the result is equivalent to an integer comparison of the two pointers interpreted as unsigned
integers. If strings are compared, the result is determined as if by performing a
<citerefentry><refentrytitle>strcmp</refentrytitle><manvolnum>3C</manvolnum></citerefentry> on the two
operands. Here are some example D string comparisons and their results:</para>
<informaltable frame="none">
<tgroup cols="2" colsep="0" rowsep="0">
<colspec colwidth="1*" />
<colspec colwidth="1*" />
<tbody>
	<row>
		<entry><para><literal>"coffee" &lt; "espresso"</literal></para></entry>
		<entry><para>... returns 1 (true)</para></entry>
	</row>
	<row>
		<entry><para><literal>"coffee" == "coffee"</literal></para></entry>
		<entry><para>... returns 1 (true)</para></entry>
	</row>
	<row>
		<entry><para><literal>"coffee" &gt;= "mocha"</literal></para></entry>
		<entry><para>... returns 0 (false)</para></entry>
	</row>
</tbody>
</tgroup>
</informaltable>
<para>Relational operators may also be used to compare a data object associated
with an enumeration type with any of the enumerator tags defined by the
enumeration. Enumerations are a facility for creating named integer constants
and are described in more detail in <xref linkend="chp-types" />.</para>
</sect1>
<sect1 xml:id="chp-typeopexpr-6">
<title>Logical Operators</title>
<para>D provides the following binary logical operators for use in your
programs. The first two operators are equivalent to the corresponding ANSI-C
operators.</para>
<table frame="topbot" xml:id="tbl-logops">
<title>D Logical Operators</title>
<tgroup cols="2" colsep="0" rowsep="0">
<colspec colname="colspec5" colwidth="1*" />
<colspec colname="colspec6" colwidth="8*" align="justify" />
<tbody valign="top">
	<row>
		<entry colname="colspec5"><para><literal>&amp;&amp;</literal></para></entry>
		<entry colname="colspec6"><para>logical <firstterm>AND</firstterm>: true if both operands are true</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>||</literal></para></entry>
		<entry colname="colspec6"><para>logical <firstterm>OR</firstterm>: true if one or both operands are true</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>^^</literal></para></entry>
		<entry colname="colspec6"><para>logical <firstterm>XOR</firstterm>: true if exactly one operand is true</para></entry>
	</row>
</tbody>
</tgroup>
</table>
<para>Logical operators are most frequently used in writing D predicates. The
logical AND operator performs short-circuit evaluation: if the left-hand operand
is false, the right-hand expression is not evaluated. The logical OR operator
also performs short-circuit evaluation: if the left-hand operand is true, the
right-hand expression is not evaluated. The logical XOR operator does not
short-circuit: both expression operands are always evaluated.</para>
<para>In addition to the binary logical operators, the unary
<literal>!</literal> operator may be used to perform a logical negation of a
single operand: it converts a zero operand into a one, and a non-zero operand
into a zero. By convention, D programmers use <literal>!</literal> when working
with integers that are meant to represent boolean values, and
<literal>== 0</literal> when working with non-boolean integers, although both
expressions are equivalent in meaning.</para>
<para>The logical operators may be applied to operands of integer or pointer
types. The logical operators interpret pointer operands as unsigned integer
values. As with all logical and relational operators in D, operands are true if
they have a non-zero integer value and false if they have a zero integer
value.</para>
</sect1>
<sect1 xml:id="chp-typeopexpr-7">
<title>Bitwise Operators</title>
<para>D provides the following binary operators for manipulating individual bits
inside of integer operands. These operators all have the same meaning as in
ANSI-C.</para>
<table frame="topbot" xml:id="tbl-bitops">
<title>D Bitwise Operators</title>
<tgroup cols="2" colsep="0" rowsep="0">
<colspec colname="colspec5" colwidth="1*" />
<colspec colname="colspec6" colwidth="8*" align="justify" />
<tbody valign="top">
	<row>
		<entry colname="colspec5"><para><literal>&amp;</literal></para></entry>
		<entry colname="colspec6"><para>bitwise AND</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>|</literal></para></entry>
		<entry colname="colspec6"><para>bitwise OR</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>^</literal></para></entry>
		<entry colname="colspec6"><para>bitwise XOR</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>&lt;&lt;</literal></para></entry>
		<entry colname="colspec6"><para>shift the left-hand operand left by the number of bits specified by the right-hand operand</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>&gt;&gt;</literal></para></entry>
		<entry colname="colspec6"><para>shift the left-hand operand right by the number of bits specified by the right-hand operand</para></entry>
	</row>
</tbody>
</tgroup>
</table>
<para>The binary <literal>&amp;</literal> operator is used to clear bits from an
integer operand. The binary <literal>|</literal> operator is used to set bits in
an integer operand. The binary <literal>^</literal> operator returns one in each
bit position where exactly one of the corresponding operand bits is set.</para>
<para>The shift operators are used to move bits left or right in a given integer
operand. Shifting left fills empty bit positions on the right-hand side of the
result with zeroes. Shifting right using an unsigned integer operand fills empty
bit positions on the left-hand side of the result with zeroes. Shifting right
using a signed integer operand fills empty bit positions on the left-hand side
with the value of the sign bit, also known as an <firstterm>arithmetic
shift</firstterm> operation.</para>
<para>Shifting an integer value by a negative number of bits or by a number of
bits larger than the number of bits in the left-hand operand itself produces an
undefined result. The D compiler will produce an error message if the compiler
can detect this condition when you compile your D program.</para>
<para>In addition to the binary logical operators, the unary
<literal>~</literal> operator may be used to perform a bitwise negation of a
single operand: it converts each zero bit in the operand into a one bit, and
each one bit in the operand into a zero bit.</para>
</sect1>
<sect1 xml:id="chp-typeopexpr-8">
<title>Assignment Operators</title>
<para>D provides the following binary assignment operators for modifying D
variables. You can only modify D variables and arrays. Kernel data objects and
constants may not be modified using the D assignment operators. The assignment
operators have the same meaning as they do in ANSI-C.</para>
<table frame="topbot" xml:id="tbl-asgnops">
<title>D Assignment Operators</title>
<tgroup cols="2" colsep="0" rowsep="0">
<colspec colname="colspec5" colwidth="1*" />
<colspec colname="colspec6" colwidth="8*" />
<tbody>
	<row>
		<entry colname="colspec5"><para><literal>=</literal></para></entry>
		<entry colname="colspec6"><para>set the left-hand operand equal to the right-hand expression value</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>+=</literal></para></entry>
		<entry colname="colspec6"><para>increment the left-hand operand by the right-hand expression value</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>-=</literal></para></entry>
		<entry colname="colspec6"><para>decrement the left-hand operand by the right-hand expression value</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>*=</literal></para></entry>
		<entry colname="colspec6"><para>multiply the left-hand operand by the right-hand expression value</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>/=</literal></para></entry>
		<entry colname="colspec6"><para>divide the left-hand operand by the right-hand expression value</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>%=</literal></para></entry>
		<entry colname="colspec6"><para>modulo the left-hand operand by the right-hand expression value</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>|=</literal></para></entry>
		<entry colname="colspec6"><para>bitwise OR the left-hand operand with the right-hand expression value</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>&amp;=</literal></para></entry>
		<entry colname="colspec6"><para>bitwise AND the left-hand operand with the right-hand expression value</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>^=</literal></para></entry>
		<entry colname="colspec6"><para>bitwise XOR the left-hand operand with the right-hand expression value</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>&lt;&lt;=</literal></para></entry>
		<entry colname="colspec6"><para>shift the left-hand operand left by the number of bits specified by the right-hand expression value</para></entry>
	</row>
	<row>
		<entry colname="colspec5"><para><literal>&gt;&gt;=</literal></para></entry>
		<entry colname="colspec6"><para>shift the left-hand operand right by the number of bits specified by the right-hand expression value</para></entry>
	</row>
</tbody>
</tgroup>
</table>
<para>Aside from the assignment operator <literal>=</literal>, the other
assignment operators are provided as shorthand for using the
<literal>=</literal> operator with one of the other operators described earlier.
For example, the expression <literal>x = x + 1</literal> is equivalent to the
expression <literal>x += 1</literal>, except that the expression
<literal>x</literal> is evaluated once. These assignment operators obey the same
rules for operand types as the binary forms described earlier.</para>
<para>The result of any assignment operator is an expression equal to the new
value of the left-hand expression. You can use the assignment operators or any
of the operators described so far in combination to form expressions of
arbitrary complexity. You can use parentheses <literal>( )</literal> to group
terms in complex expressions.</para>
</sect1>
<sect1 xml:id="chp-typeopexpr-9">
<title>Increment and Decrement Operators</title>
<para>D provides the special unary <literal>++</literal> and
<literal>--</literal> operators for incrementing and decrementing pointers and
integers. These operators have the same meaning as in ANSI-C. These operators
can only be applied to variables, and may be applied either before or after the
variable name. If the operator appears before the variable name, the variable is
first modified and then the resulting expression is equal to the new value of
the variable. For example, the following two expressions produce identical
results:</para>
<informaltable frame="none">
<tgroup cols="2" colsep="0" rowsep="0">
<colspec colwidth="1*" />
<colspec colwidth="1*" />
<tbody>
	<row>
		<entry><para><literal>x += 1;</literal></para></entry>
		<entry><para><literal>y = ++x;</literal></para></entry>
	</row>
	<row>
		<entry><para><literal>y = x;</literal></para></entry>
		<entry><para></para></entry>
	</row>
</tbody>
</tgroup>
</informaltable>
<para>If the operator appears after the variable name, then the variable is
modified after its current value is returned for use in the expression. For
example, the following two expressions produce identical results:</para>
<informaltable frame="none">
<tgroup cols="2" colsep="0" rowsep="0">
<colspec colwidth="1*" />
<colspec colwidth="1*" />
<tbody>
	<row>
		<entry><para><literal>y = x;</literal></para></entry>
		<entry><para><literal>y = x--;</literal></para></entry>
	</row>
	<row>
		<entry><para><literal>x -= 1;</literal></para></entry>
		<entry><para></para></entry>
	</row>
</tbody>
</tgroup>
</informaltable>
<para>You can use the increment and decrement operators to create new variables
without declaring them. If a variable declaration is omitted and the increment
or decrement operator is applied to a variable, the variable is implicitly
declared to be of type <literal>int64_t</literal>.</para>
<para>The increment and decrement operators can be applied to integer or pointer
variables. When applied to integer variables, the operators increment or
decrement the corresponding value by one. When applied to pointer variables, the
operators increment or decrement the pointer address by the size of the data
type referenced by the pointer. Pointers and pointer arithmetic in D are
discussed in <xref linkend="chp-pointers" />.</para>
</sect1>
<sect1 xml:id="chp-typeopexpr-10">
<title>Conditional Expressions</title>
<para>Although D does not provide support for if-then-else constructs, it does provide support for simple conditional expressions using the <literal>?</literal> and <literal>:</literal> operators. These operators enable a triplet of expressions to be associated where the first expression is used to conditionally evaluate one of the other two. For example, the following D statement could be used to set a variable <literal>x</literal> to one of two strings depending on the value of <literal>i</literal>:</para>
<programlisting>x = i == 0 ? "zero" : "non-zero";</programlisting>
<para>In this example, the expression <literal>i == 0</literal> is first evaluated to determine whether it is true or false. If the first expression is true, the second expression is evaluated and the <literal>?:</literal> expression returns its value. If the first expression is false, the third expression is evaluated and the <literal>?:</literal> expression return its value.</para>
<para>As with any D operator, you can use multiple <literal>?:</literal> operators in a single expression to create more complex expressions. For example, the following expression would take a <literal>char</literal> variable <literal>c</literal> containing one of the characters 0-9, a-z, or A-Z and return the value of this character when interpreted as a digit in a hexadecimal (base 16) integer:</para>
<programlisting>hexval = (c &gt;= '0' &amp;&amp; c &lt;= '9') ? c - '0' :
    (c &gt;= 'a' &amp;&amp; c &lt;= 'z') ? c + 10 - 'a' : c + 10 - 'A';</programlisting>
<para>The first expression used with <literal>?:</literal> must be a pointer or integer in order to be evaluated for its truth value. The second and third expressions may be of any compatible types. You may not construct a conditional expression where, for example, one path returns a string and another path returns an integer. The second and third expressions also may not invoke a tracing function such as <function>trace</function> or <function>printf</function>. If you want to conditionally trace data, use a predicate instead, as discussed in <xref linkend="chp-intro" />.</para>
</sect1>
<sect1 xml:id="chp-typeopexpr-11">
<title>Type Conversions</title>
<para>When expressions are constructed using operands of different but compatible types, type conversions are performed in order to determine the type of the resulting expression. The D rules for type conversions are the same as the arithmetic conversion rules for integers in ANSI-C. These rules are sometimes referred to as the <firstterm>usual arithmetic conversions</firstterm>.</para>
<para>A simple way to describe the conversion rules is as follows: each integer type is ranked in the order <literal>char, short, int, long, long long</literal>, with the corresponding unsigned types assigned a rank above its signed equivalent but below the next integer type. When you construct an expression using two integer operands such as <literal>x + y</literal> and the operands are of different integer types, the operand type with the highest rank is used as the result type.</para>
<para>If a conversion is required, the operand of lower rank is first <firstterm>promoted</firstterm> to the type of higher rank. Promotion does not actually change the value of the operand: it simply extends the value to a larger container according to its sign. If an unsigned operand is promoted, the unused high-order bits of the resulting integer are filled with zeroes. If a signed operand is promoted, the unused high-order bits are filled by performing sign extension. If a signed type is converted to an unsigned type, the signed type is first sign-extended and then assigned the new unsigned type determined by the conversion.</para>
<para>Integers and other types can also be explicitly <firstterm>cast</firstterm> from one type to another. In D, pointers and integers can be cast to any integer or pointer types, but not to other types. Rules for casting and promoting strings and character arrays are discussed in <xref linkend="chp-strings" />. An integer or pointer cast is formed using an expression such as:</para>
<programlisting>y = (int)x;</programlisting>
<para>where the destination type is enclosed in parentheses and used to prefix the source expression. Integers are cast to types of higher rank by performing promotion. Integers are cast to types of lower rank by zeroing the excess high-order bits of the integer.</para>
<para>Because D does not permit floating-point arithmetic, no floating-point operand conversion or casting is permitted and no rules for implicit floating-point conversion are defined.</para>
</sect1>
<sect1 xml:id="chp-typeopexpr-12">
<title>Precedence</title>
<para>The D rules for operator precedence and associativity are described in the following table. These rules are somewhat complex, but are necessary to provide precise compatibility with the ANSI-C operator precedence rules. The table entries are in order from highest precedence to lowest precedence.</para>
<table frame="topbot" xml:id="tbl-prec">
<title>D Operator Precedence and Associativity</title>
<tgroup cols="2" colsep="0" rowsep="0">
<colspec colwidth="4*" />
<colspec colwidth="1*" />
<thead>
	<row rowsep="1">
		<entry><para>Operators</para></entry>
		<entry><para>Associativity</para></entry>
	</row>
</thead>
<tbody>
	<row>
		<entry><para><literal>() [] -&gt; .</literal></para></entry>
		<entry><para>left to right</para></entry>
	</row>
	<row>
		<entry><para><literal>! ~ ++ -- + - * &amp; (</literal><replaceable>type</replaceable><literal>) sizeof stringof offsetof xlate</literal></para></entry>
		<entry><para>right to left</para></entry>
	</row>
	<row>
		<entry><para><literal>* / %</literal></para></entry>
		<entry><para>left to right</para></entry>
	</row>
	<row>
		<entry><para><literal>+ -</literal></para></entry>
		<entry><para>left to right</para></entry>
	</row>
	<row>
		<entry><para><literal>&lt;&lt; &gt;&gt;</literal></para></entry>
		<entry><para>left to right</para></entry>
	</row>
	<row>
		<entry><para><literal>&lt; &lt;= &gt; &gt;=</literal></para></entry>
		<entry><para>left to right</para></entry>
	</row>
	<row>
		<entry><para><literal>== !=</literal></para></entry>
		<entry><para>left to right</para></entry>
	</row>
	<row>
		<entry><para><literal>&amp;</literal></para></entry>
		<entry><para>left to right</para></entry>
	</row>
	<row>
		<entry><para><literal>^</literal></para></entry>
		<entry><para>left to right</para></entry>
	</row>
	<row>
		<entry><para><literal>|</literal></para></entry>
		<entry><para>left to right</para></entry>
	</row>
	<row>
		<entry><para><literal>&amp;&amp;</literal></para></entry>
		<entry><para>left to right</para></entry>
	</row>
	<row>
		<entry><para><literal>^^</literal></para></entry>
		<entry><para>left to right</para></entry>
	</row>
	<row>
		<entry><para><literal>||</literal></para></entry>
		<entry><para>left to right</para></entry>
	</row>
	<row>
		<entry><para><literal>?:</literal></para></entry>
		<entry><para>right to left</para></entry>
	</row>
	<row>
		<entry><para><literal>= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;=</literal></para></entry>
		<entry><para>right to left</para></entry>
	</row>
	<row>
		<entry><para><literal>,</literal></para></entry>
		<entry><para>left to right</para></entry>
	</row>
</tbody>
</tgroup>
</table>
<para>There are several operators in the table that we have not yet discussed; these will be covered in subsequent chapters:</para>
<informaltable frame="none">
<tgroup cols="2" colsep="0" rowsep="0">
<colspec colname="colspec11" colwidth="1*" />
<colspec colname="colspec12" colwidth="4*" />
<tbody>
	<row>
		<entry><para><literal>sizeof</literal></para></entry>
		<entry><para>Computes the size of an object (<xref linkend="chp-structs" />)</para></entry>
	</row>
	<row>
		<entry><para><literal>offsetof</literal></para></entry>
		<entry><para>Computes the offset of a type member (<xref linkend="chp-structs" />)</para></entry>
	</row>
	<row>
		<entry><para><literal>stringof</literal></para></entry>
		<entry><para>Converts the operand to a string (<xref linkend="chp-strings" />)</para></entry>
	</row>
	<row>
		<entry colname="colspec11"><para><literal>xlate</literal></para></entry>
		<entry colname="colspec12"><para>Translates a data type (<xref linkend="chp-xlate" />)</para></entry>
	</row>
	<row>
		<entry><para>unary <literal>&amp;</literal></para></entry>
		<entry><para>Computes the address of an object (<xref linkend="chp-pointers" />)</para></entry>
	</row>
	<row>
		<entry><para>unary <literal>*</literal></para></entry>
		<entry><para>Dereferences a pointer to an object (<xref linkend="chp-pointers" />)</para></entry>
	</row>
	<row>
		<entry><para><literal>-&gt;</literal> and <literal>.</literal></para></entry>
		<entry><para>Accesses a member of a structure or union type (<xref linkend="chp-structs" />)</para></entry>
	</row>
</tbody>
</tgroup>
</informaltable>
<para>The comma (<literal>,</literal>) operator listed in the table is for compatibility with the ANSI-C comma operator, which can be used to evaluate a set of expressions in left-to-right order and return the value of the rightmost expression. This operator is provided strictly for compatibility with C and should generally not be used.</para>
<para>The <literal>()</literal> entry in the table of operator precedence represents a function call; examples of calls to functions such as <function>printf</function> and <function>trace</function> are presented in <xref linkend="chp-intro" />. A comma is also used in D to list arguments to functions and to form lists of associative array keys. This comma is not the same as the comma operator and does <emphasis>not</emphasis> guarantee left-to-right evaluation. The D compiler provides no guarantee as to the order of evaluation of arguments to a function or keys to an associative array. You should be careful of using expressions with interacting side-effects, such as the pair of expressions <literal>i</literal> and <literal>i++</literal>, in these contexts.</para>
<para>The <literal>[]</literal> entry in the table of operator precedence represents an array or associative array reference. Examples of associative arrays are presented in <xref linkend="chp-intro" />. A special kind of associative array called an <firstterm>aggregation</firstterm> is described in <xref linkend="chp-aggs" />. The <literal>[]</literal> operator can also be used to index into fixed-size C arrays as well, as described in <xref linkend="chp-pointers" />.</para>
</sect1>
</chapter>

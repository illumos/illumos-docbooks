<chapter xml:id="block-34861">
<title>Drivers for Block Devices</title>
<para>This chapter describes the structure of block device drivers. The kernel
views a block device as a set of randomly accessible logical blocks. The file
system uses a list of <citerefentry><refentrytitle>buf</refentrytitle><manvolnum>9S</manvolnum></citerefentry> structures
to buffer the data blocks between a block device and the user space. Only
block devices can support a file system.</para>
<para>This chapter provides information on the following subjects:</para>
<itemizedlist>
	<listitem><para><xref linkend="block-1" /></para></listitem>
	<listitem><para><xref linkend="block-82249" /></para></listitem>
	<listitem><para><xref linkend="block-5" /></para></listitem>
	<listitem><para><xref linkend="block-6" /></para></listitem>
	<listitem><para><xref linkend="block-78892" /></para></listitem>
	<listitem><para><xref linkend="block-54698" /></para></listitem>
	<listitem><para><xref linkend="block-25" /></para></listitem>
	<listitem><para><xref linkend="advanced-7" /></para></listitem>
</itemizedlist>
<sect1 xml:id="block-1">
<title>Block Driver Structure Overview</title>
<para><xref linkend="block-fig-3" /> shows
data structures and routines that define the structure of a block device driver.
Device drivers typically include the following elements:</para>
<itemizedlist>
	<listitem><para>Device-loadable driver section</para></listitem>
	<listitem><para>Device configuration section</para></listitem>
	<listitem><para>Device access section</para></listitem>
</itemizedlist>
<para>The shaded device access section in the following figure illustrates entry points for block drivers.</para>
<figure xml:id="block-fig-3">
<title xml:id="block-36477">Block Driver Roadmap</title>
<mediaobject>
	<imageobject><imagedata fileref="figures/block-view" /></imageobject>
	<textobject><simpara>Diagram shows structures and entry points for block device drivers.</simpara></textobject>
</mediaobject>
</figure>
<para><indexterm xml:id="block-ix419"><primary>entry points</primary><secondary sortas="block">for block drivers</secondary></indexterm><indexterm xml:id="block-ix420"><primary>entry points</primary><secondary sortas="block">for block drivers</secondary></indexterm><indexterm xml:id="block-ix421"><primary>block driver entry points</primary></indexterm>Associated with each device driver
is a <citerefentry><refentrytitle>dev_ops</refentrytitle><manvolnum>9S</manvolnum></citerefentry> structure,
which in turn refers to a <citerefentry><refentrytitle>cb_ops</refentrytitle><manvolnum>9S</manvolnum></citerefentry> structure.
See <xref linkend="autoconf-17" /> for
details on driver data structures.</para><para>Block device drivers provide these entry points:</para><itemizedlist><listitem><para><citerefentry><refentrytitle>open</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para>
</listitem><listitem><para><citerefentry><refentrytitle>close</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para>
</listitem><listitem><para><citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para>
</listitem><listitem><para><citerefentry><refentrytitle>print</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para>
</listitem>
</itemizedlist><note><para>Some of the entry points can be replaced by <citerefentry><refentrytitle>nodev</refentrytitle><manvolnum>9F</manvolnum></citerefentry> or <citerefentry><refentrytitle>nulldev</refentrytitle><manvolnum>9F</manvolnum></citerefentry> as appropriate.</para>
</note>
</sect1><sect1 xml:id="block-82249"><title>File I/O</title><indexterm xml:id="block-ix417"><primary>file system I/O</primary>
</indexterm><indexterm xml:id="block-ix418"><primary>I/O</primary><secondary>file system structure</secondary>
</indexterm><para>A file system is a tree-structured hierarchy of directories and files.
Some file systems, such as the UNIX File System (UFS), reside on block-oriented
devices. File systems are created by <citerefentry><refentrytitle>format</refentrytitle><manvolnum>1M</manvolnum></citerefentry> and <citerefentry><refentrytitle>newfs</refentrytitle><manvolnum>1M</manvolnum></citerefentry>.</para><para>When an application issues a <citerefentry><refentrytitle>read</refentrytitle><manvolnum>2</manvolnum></citerefentry> or <citerefentry><refentrytitle>write</refentrytitle><manvolnum>2</manvolnum></citerefentry> system
call to an ordinary file on the UFS file system, the file system can call
the device driver <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry
point for the block device on which the file system resides. The file system
code can call <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> several
times for a single <citerefentry><refentrytitle>read</refentrytitle><manvolnum>2</manvolnum></citerefentry> or <citerefentry><refentrytitle>write</refentrytitle><manvolnum>2</manvolnum></citerefentry> system call.</para><para>The file system code determines the logical device address, or <emphasis>logical
block number</emphasis>, for each ordinary file block. A block I/O request
is then built in the form of a <citerefentry><refentrytitle>buf</refentrytitle><manvolnum>9S</manvolnum></citerefentry> structure
directed at the block device. The driver <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry point then interprets
the <citerefentry><refentrytitle>buf</refentrytitle><manvolnum>9S</manvolnum></citerefentry> structure
and completes the request.</para>
</sect1><sect1 xml:id="block-5"><title>Block Device Autoconfiguration</title><indexterm xml:id="block-ix422"><primary>autoconfiguration</primary><secondary sortas="block">of block devices</secondary>
</indexterm><para><citerefentry><refentrytitle>attach</refentrytitle><manvolnum>9E</manvolnum></citerefentry> should
perform the common initialization tasks for each instance of a device:</para><itemizedlist><listitem><para>Allocating per-instance state structures</para>
</listitem><listitem><para>Mapping the device's registers</para>
</listitem><listitem><para>Registering device interrupts</para>
</listitem><listitem><para>Initializing mutex and condition variables</para>
</listitem><listitem><para>Creating power manageable components</para>
</listitem><listitem><para>Creating minor nodes</para>
</listitem>
</itemizedlist><para>Block device drivers create minor nodes of type <literal>S_IFBLK</literal>.
As a result,  a block special file that represents the node appears in the <filename>/devices</filename> hierarchy.</para><para><indexterm xml:id="block-ix423"><primary>block driver</primary><secondary>autoconfiguration of</secondary></indexterm><indexterm xml:id="block-ix424"><primary>block driver</primary><secondary>slice number</secondary></indexterm><indexterm xml:id="block-ix425"><primary>slice number for block devices</primary></indexterm>Logical device
names for block devices appear in the <filename>/dev/dsk</filename> directory,
and consist of a controller number, bus-address number, disk number, and slice
number. These names are created by the <citerefentry><refentrytitle>devfsadm</refentrytitle><manvolnum>1M</manvolnum></citerefentry> program if the node type
is set to <literal>DDI_NT_BLOCK</literal> or <literal>DDI_NT_BLOCK_CHAN</literal>. <literal>DDI_NT_BLOCK_CHAN</literal> should be specified if the device communicates
on a channel, that is, a bus with an additional level of addressability. 
SCSI disks are a good example. <literal>DDI_NT_BLOCK_CHAN</literal> causes
a bus-address field (t<emphasis>N</emphasis>) to appear in the logical name. <literal>DDI_NT_BLOCK</literal> should be used for most other devices.</para><para><indexterm><primary><literal>nblocks</literal> property</primary><secondary>use in block device drivers</secondary></indexterm><indexterm><primary><literal>Nblocks</literal> property</primary><secondary>use in block device drivers</secondary></indexterm><indexterm><primary>properties</primary><secondary><literal>nblocks</literal> property</secondary></indexterm><indexterm><primary>properties</primary><secondary><literal>Nblocks</literal> property</secondary></indexterm>A minor device refers to a partition on the disk. For each minor
device, the driver must create an <literal>nblocks</literal> or <literal>Nblocks</literal> property.
This integer property gives the number of blocks supported by the minor device
expressed in units of <literal>DEV_BSIZE</literal>, that is, 512 bytes. The
file system uses the <literal>nblocks</literal> and <literal>Nblocks</literal> properties
to determine device limits. <literal>Nblocks</literal> is the 64-bit version
of <literal>nblocks</literal>. <literal>Nblocks</literal> should be used with
storage devices that can hold over 1 Tbyte of storage per disk. See <xref linkend="properties-8" /> for more information.</para><para><xref linkend="block-29600" /> shows
a typical <citerefentry><refentrytitle>attach</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry
point with emphasis on creating the device's minor node and the <literal>Nblocks</literal> property.
Note that because this example uses <literal>Nblocks</literal> and not <literal>nblocks</literal>,  <citerefentry><refentrytitle>ddi_prop_update_int64</refentrytitle><manvolnum>9F</manvolnum></citerefentry> is called instead of <citerefentry><refentrytitle>ddi_prop_update_int</refentrytitle><manvolnum>9F</manvolnum></citerefentry>.</para><para><indexterm><primary><function>makedevice</function> function</primary></indexterm><indexterm><primary><function>ddi_driver_major</function> function</primary></indexterm><indexterm><primary><function>getmajor</function> function</primary></indexterm><indexterm><primary><function>ddi_driver_major</function> function</primary></indexterm><indexterm><primary>getting major numbers</primary><secondary>example of</secondary></indexterm><indexterm><primary>major numbers</primary><secondary>example of</secondary></indexterm>As a side note, this example shows the use of <citerefentry><refentrytitle>makedevice</refentrytitle><manvolnum>9F</manvolnum></citerefentry> to create
a device number for <function>ddi_prop_update_int64</function>. The <literal>makedevice</literal> function makes use of <citerefentry><refentrytitle>ddi_driver_major</refentrytitle><manvolnum>9F</manvolnum></citerefentry>, which generates a major
number from a pointer to a <varname role="structname">dev_info_t</varname> structure.
Using <function>ddi_driver_major</function> is similar to using <citerefentry><refentrytitle>getmajor</refentrytitle><manvolnum>9F</manvolnum></citerefentry>, which gets
a <varname role="structname">dev_t</varname> structure pointer.</para><example xml:id="block-29600"><title>Block Driver <function>attach</function> Routine</title><programlisting>static int
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    int instance = ddi_get_instance(dip);
    switch (cmd) {
      case DDI_ATTACH:
      /*
       * allocate a state structure and initialize it
       * map the devices registers
       * add the device driver's interrupt handler(s)
       * initialize any mutexes and condition variables
       * read label information if the device is a disk
       * create power manageable components
       *
       * Create the device minor node. Note that the node_type
       * argument is set to DDI_NT_BLOCK.
       */
      if (ddi_create_minor_node(dip, "<replaceable>minor_name</replaceable>", S_IFBLK,
          instance, DDI_NT_BLOCK, 0) == DDI_FAILURE) {
          /* free resources allocated so far */
          /* Remove any previously allocated minor nodes */
          ddi_remove_minor_node(dip, NULL);
          return (DDI_FAILURE);
      }
      /*
       * Create driver properties like "Nblocks". If the device
       * is a disk, the Nblocks property is usually calculated from
       * information in the disk label.  Use "Nblocks" instead of
       * "nblocks" to ensure the property works for large disks.
       */
      xsp-&gt;Nblocks = <replaceable>size</replaceable>;
      /* size is the size of the device in 512 byte blocks */
      maj_number = ddi_driver_major(dip);
      if (ddi_prop_update_int64(makedevice(maj_number, instance), dip, 
          "Nblocks", xsp-&gt;Nblocks) != DDI_PROP_SUCCESS) {
          cmn_err(CE_CONT, "%s: cannot create Nblocks property\n",
              ddi_get_name(dip));
          /* free resources allocated so far */
          return (DDI_FAILURE);
      }
      xsp-&gt;open = 0;
      xsp-&gt;nlayered = 0;
      /* ... */
      return (DDI_SUCCESS);

      case DDI_RESUME:
          /* For information, see Chapter 12, "Power Management," in this book. */
      default:
          return (DDI_FAILURE);
    }
}</programlisting>
</example>
</sect1><sect1 xml:id="block-6"><title>Controlling Device Access</title><para>This section describes the entry points for <function>open</function> and <function>close</function> functions in block device drivers. See <xref linkend="character-21002" /> for
more information on <citerefentry><refentrytitle>open</refentrytitle><manvolnum>9E</manvolnum></citerefentry> and <citerefentry><refentrytitle>close</refentrytitle><manvolnum>9E</manvolnum></citerefentry>.</para><sect2 xml:id="block-7"><title><function>open</function> Entry Point (Block Drivers)</title><para><indexterm xml:id="block-ix426"><primary>block driver entry points</primary><secondary><function>open</function> function</secondary></indexterm><indexterm xml:id="block-ix427"><primary>device access functions</primary><secondary>block drivers</secondary></indexterm><indexterm xml:id="block-ix428"><primary><function>open</function> entry point</primary><secondary>block drivers</secondary></indexterm><indexterm xml:id="block-ix429"><primary><function>mount</function> function</primary><secondary>block drivers</secondary></indexterm>The <citerefentry><refentrytitle>open</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry point is used to gain
access to a given device. The <citerefentry><refentrytitle>open</refentrytitle><manvolnum>9E</manvolnum></citerefentry> routine
of a block driver is called when a user thread issues an <citerefentry><refentrytitle>open</refentrytitle><manvolnum>2</manvolnum></citerefentry> or <citerefentry><refentrytitle>mount</refentrytitle><manvolnum>2</manvolnum></citerefentry> system call on a block special
file associated with the minor device, or when a layered driver calls  <citerefentry><refentrytitle>open</refentrytitle><manvolnum>9E</manvolnum></citerefentry>. See <xref linkend="block-82249" /> for more information.</para>
<para>The <function>open</function> entry point should check for the following conditions:</para>
<itemizedlist>
	<listitem><para>The device can be opened, that is, the device is online and ready.</para></listitem>
	<listitem><para>The device can be opened as requested. The device supports the operation. The device's current state does not conflict with the request.</para></listitem>
	<listitem><para>The caller has permission to open the device.</para></listitem>
</itemizedlist>
<para>The following example demonstrates a block driver <citerefentry><refentrytitle>open</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry point.</para>
<example xml:id="block-40232">
<title>Block Driver <citerefentry><refentrytitle>open</refentrytitle><manvolnum>9E</manvolnum></citerefentry> Routine</title>
<programlisting>static int
xxopen(dev_t *devp, int flags, int otyp, cred_t *credp)
{
    minor_t         instance;
    struct xxstate        *xsp;

    instance = getminor(*devp);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL)
        return (ENXIO);
    mutex_enter(&amp;xsp-&gt;mu);
    /*
     * only honor FEXCL. If a regular open or a layered open
     * is still outstanding on the device, the exclusive open
     * must fail.
     */
    if ((flags &amp; FEXCL) &amp;&amp; (xsp-&gt;open || xsp-&gt;nlayered)) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (EAGAIN);
    }
    switch (otyp) {
      case OTYP_LYR:
          xsp-&gt;nlayered++;
          break;
      case OTYP_BLK:
          xsp-&gt;open = 1;
          break;
      default:
          mutex_exit(&amp;xsp-&gt;mu);
          return (EINVAL);
    }
    mutex_exit(&amp;xsp-&gt;mu);
    return (0);
}</programlisting>
</example><para>The <literal>otyp</literal> argument is used to specify the type of
open on the device. <literal>OTYP_BLK</literal> is the typical open type for
a block device. A device can be opened several times with <literal>otyp</literal> set
to <literal>OTYP_BLK</literal>.  <citerefentry><refentrytitle>close</refentrytitle><manvolnum>9E</manvolnum></citerefentry> is called only once when
the final close of type <literal>OTYP_BLK</literal> has occurred for the device. <literal>otyp</literal> is set to <literal>OTYP_LYR</literal> if the device is being
used as a layered device. For every open of type <literal>OTYP_LYR</literal>,
the layering driver issues a corresponding close of type <literal>OTYP_LYR</literal>.
The example keeps track of each type of open so the driver can determine when
the device is not being used in <citerefentry><refentrytitle>close</refentrytitle><manvolnum>9E</manvolnum></citerefentry>.</para>
</sect2>
<sect2 xml:id="block-8">
<title><function>close</function> Entry Point (Block Drivers)</title>
<para><indexterm xml:id="block-ix430"><primary><function>close</function> entry point</primary><secondary>block drivers</secondary></indexterm><indexterm xml:id="block-ix431"><primary>block driver entry points</primary><secondary><function>close</function> function</secondary></indexterm>The <citerefentry><refentrytitle>close</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry point uses the same
arguments as  <citerefentry><refentrytitle>open</refentrytitle><manvolnum>9E</manvolnum></citerefentry> with
one exception. <literal>dev</literal> is the device number rather than a pointer
to the device number.</para><para>The <function>close</function> routine should verify <literal>otyp</literal> in
the same way as was described for the <citerefentry><refentrytitle>open</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry point. In the following example, <function>close</function> must determine when the device can really be closed. Closing
is affected by the number of block opens and layered opens.</para><example xml:id="block-15508"><title>Block Device <citerefentry><refentrytitle>close</refentrytitle><manvolnum>9E</manvolnum></citerefentry> Routine</title><programlisting>static int
xxclose(dev_t dev, int flag, int otyp, cred_t *credp)
{
    minor_t instance;
    struct xxstate *xsp;

    instance = getminor(dev);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL)
        return (ENXIO);
    mutex_enter(&amp;xsp-&gt;mu);
    switch (otyp) {
      case OTYP_LYR:
          xsp-&gt;nlayered--;
          break;
      case OTYP_BLK:
          xsp-&gt;open = 0;
          break;
      default:
          mutex_exit(&amp;xsp-&gt;mu);
         return (EINVAL);
    }

    if (xsp-&gt;open || xsp-&gt;nlayered) {
        /* not done yet */
        mutex_exit(&amp;xsp-&gt;mu);
        return (0);
    }
    /* cleanup (rewind tape, free memory, etc.) */
    /* wait for I/O to drain */
    mutex_exit(&amp;xsp-&gt;mu);

    return (0);
}</programlisting>
</example>
</sect2><sect2 xml:id="block-20"><title><function>strategy</function> Entry Point</title><para><indexterm><primary><function>strategy</function> entry point</primary><secondary>block drivers</secondary></indexterm>The <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry point
is used to read and write data buffers to and from a block device. The name <emphasis>strategy</emphasis> refers to the fact that this entry point might implement
some optimal strategy for ordering requests to the device.</para><para><indexterm><primary>block driver entry points</primary><secondary><function>strategy</function> function</secondary></indexterm><citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> can be written
to process one request at a time, that is, a synchronous transfer. <function>strategy</function> can also be written to queue multiple requests to the device,
as in an asynchronous transfer. When choosing a method, the abilities and
limitations of the device should be taken into account.</para><para>The <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> routine
is passed a pointer to a <citerefentry><refentrytitle>buf</refentrytitle><manvolnum>9S</manvolnum></citerefentry> structure.
This structure describes the transfer request, and contains status information
on return. <citerefentry><refentrytitle>buf</refentrytitle><manvolnum>9S</manvolnum></citerefentry> and <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> are the focus
of block device operations.</para>
</sect2><sect2 xml:id="block-3"><title><literal>buf</literal> Structure</title><para><indexterm><primary><varname role="structname">buf</varname> structure</primary><secondary>description of</secondary></indexterm><indexterm><primary>block driver</primary><secondary><varname role="structname">buf</varname> structure</secondary></indexterm>The following <varname role="structname">buf</varname> structure members are
important to block drivers:</para><programlisting>int           b_flags;       /* Buffer Status */
struct buf    *av_forw;      /* Driver work list link */
struct buf    *av_back;      /* Driver work list link */
size_t        b_bcount;      /* # of bytes to transfer */
union {
    caddr_t   b_addr;        /* Buffer's virtual address */
} b_un;
daddr_t       b_blkno;       /* Block number on device */
diskaddr_t    b_lblkno;      /* Expanded block number on device */
size_t        b_resid;       /* # of bytes not transferred after error */
int           b_error;       /* Expanded error field */
void          *b_private;    /* &ldquo;opaque&rdquo; driver private area */
dev_t         b_edev;        /* expanded dev field */</programlisting>
<para>where:</para>
<variablelist>
	<varlistentry>
		<term><varname role="structfield">av_forw</varname> and <varname role="structfield">av_back</varname></term>
		<listitem><para>Pointers that the driver can use to manage a list of buffers by the driver. See <xref linkend="block-54698" /> for a discussion of the <varname role="structfield">av_forw</varname> and <varname role="structfield">av_back</varname> pointers.</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><varname role="structfield">b_bcount</varname></term>
		<listitem><para>Specifies the number of bytes to be transferred by the device.</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><varname role="structfield">b_un.b_addr</varname></term>
		<listitem><para>The kernel virtual address of the data buffer. Only valid after <citerefentry><refentrytitle>bp_mapin</refentrytitle><manvolnum>9F</manvolnum></citerefentry> call.</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><varname role="structfield">b_blkno</varname></term>
		<listitem><para>The starting 32-bit logical block number on the device for
				the data transfer, which is expressed in 512-byte <literal>DEV_BSIZE</literal> units.
				The driver should use either <varname role="structfield">b_blkno</varname> or <varname role="structfield">b_lblkno</varname> but not both.</para>
		</listitem>
	</varlistentry>
	<varlistentry>
		<term><varname role="structfield">b_lblkno</varname></term>
		<listitem><para>The starting 64-bit logical block number on the device for
				the data transfer, which is expressed in 512-byte <literal>DEV_BSIZE</literal> units.
				The driver should use either <varname role="structfield">b_blkno</varname> or <varname role="structfield">b_lblkno</varname> but not both.</para>
		</listitem>
	</varlistentry>
	<varlistentry>
		<term><varname role="structfield">b_resid</varname></term>
		<listitem><para>Set by the driver to indicate the number of bytes that were not transferred because of an error. See <xref linkend="block-33565" /> for an example of setting <varname role="structfield">b_resid</varname>. The <varname role="structfield">b_resid</varname> member is overloaded. <varname role="structfield">b_resid</varname> is also used by <citerefentry><refentrytitle>disksort</refentrytitle><manvolnum>9F</manvolnum></citerefentry>.</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><varname role="structfield">b_error</varname></term>
		<listitem><para>Set to an error number by the driver when a transfer error occurs. <literal>b_error</literal> is set in conjunction with the <varname role="structfield">b_flags</varname> <literal>B_ERROR</literal> bit. See the <citerefentry><refentrytitle>Intro</refentrytitle><manvolnum>9E</manvolnum></citerefentry> man page for details about error values. Drivers should use  <citerefentry><refentrytitle>bioerror</refentrytitle><manvolnum>9F</manvolnum></citerefentry> rather than setting <varname role="structfield">b_error</varname> directly.</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><literal>b_flags</literal></term>
		<listitem>
			<para>Flags with status and transfer attributes of the <varname role="structname">buf</varname> structure. If <literal>B_READ</literal> is set, the <varname role="structname">buf</varname> structure indicates a transfer from the device to memory. Otherwise, this structure indicates a transfer from memory to the device. If the driver encounters an error during data transfer, the driver should set the <literal>B_ERROR</literal> field in the <varname role="structfield">b_flags</varname> member. In addition, the driver should provide a more specific error value in <varname role="structfield">b_error</varname>. Drivers should use  <citerefentry><refentrytitle>bioerror</refentrytitle><manvolnum>9F</manvolnum></citerefentry> rather than setting <literal>B_ERROR</literal>.</para>
			<caution><para>Drivers should never clear <literal>b_flags</literal>.</para></caution>
		</listitem>
	</varlistentry>
	<varlistentry>
		<term><varname role="structfield">b_private</varname></term>
		<listitem><para>For exclusive use by the driver to store driver-private data.</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><varname role="structfield">b_edev</varname></term>
		<listitem><para>Contains the device number of the device that  was used in the transfer.</para></listitem>
	</varlistentry>
</variablelist>
<sect3 xml:id="block-4">
<title><varname role="structname">bp_mapin</varname> Structure</title>
<para>A <varname role="structname">buf</varname> structure pointer can be passed into
the device driver's <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> routine.
However, the data buffer referred to by <varname role="structfield">b_un.b_addr</varname> is
not necessarily mapped in the kernel's address space. Therefore, the driver
cannot directly access the data. Most block-oriented devices have DMA capability
and therefore do not need to access the data buffer directly. Instead, these
devices use the DMA mapping routines to enable the device's DMA engine to
do the data transfer. For details about using DMA, see <xref linkend="dma-29901" />.</para>
<para>If a driver needs to access the data buffer directly, that driver must
first map the buffer into the kernel's address space by using <citerefentry><refentrytitle>bp_mapin</refentrytitle><manvolnum>9F</manvolnum></citerefentry>.  <citerefentry><refentrytitle>bp_mapout</refentrytitle><manvolnum>9F</manvolnum></citerefentry> should be
used when the driver no longer needs to access the data directly.</para>
<caution><para><citerefentry><refentrytitle>bp_mapout</refentrytitle><manvolnum>9F</manvolnum></citerefentry> should
only be called on buffers that have  been  allocated and are owned by the
device driver. <function>bp_mapout</function> must not be called on buffers
that are passed to the driver through the <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry point, such as a file
system. <citerefentry><refentrytitle>bp_mapin</refentrytitle><manvolnum>9F</manvolnum></citerefentry> does
not keep a reference count. <citerefentry><refentrytitle>bp_mapout</refentrytitle><manvolnum>9F</manvolnum></citerefentry> removes any kernel  mapping
 on which  a layer over the device driver might rely.</para>
</caution>
</sect3>
</sect2>
</sect1><sect1 xml:id="block-78892"><title>Synchronous Data Transfers (Block Drivers)</title><para><indexterm xml:id="block-ix437"><primary>I/O</primary><secondary>synchronous data transfers</secondary></indexterm><indexterm><primary>synchronous data transfers</primary><secondary>block drivers</secondary></indexterm>This section
presents a simple method for performing synchronous I/O transfers. This method
assumes that the hardware is a simple disk device that can transfer only one
data buffer at a time by using DMA. Another assumption is that the disk can
be spun up and spun down by software command. The device driver's  <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> routine waits
for the current request to be completed before accepting a new request. The
device interrupts when the transfer is complete. The device also interrupts
if an error occurs.</para><para>The steps for performing a synchronous data transfer for a block driver
are as follows:</para>
<orderedlist>
	<listitem>
		<para>Check for invalid <citerefentry><refentrytitle>buf</refentrytitle><manvolnum>9S</manvolnum></citerefentry> requests.</para>
		<para>Check the <citerefentry><refentrytitle>buf</refentrytitle><manvolnum>9S</manvolnum></citerefentry> structure that is passed to <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> for validity. All drivers should check the following conditions:</para>
		<itemizedlist>
			<listitem><para>The request begins at a valid block. The driver converts the <varname role="structfield">b_blkno</varname> field to the correct device offset and then determines whether the offset is valid for the device.</para></listitem>
			<listitem><para>The request does not go beyond the last block on the device.</para></listitem>
			<listitem><para>Device-specific requirements are met.</para></listitem>
		</itemizedlist>
		<para><indexterm xml:id="block-ix438"><primary><function>biodone</function> function</primary></indexterm>If an error is encountered, the driver should indicate the appropriate error with  <citerefentry><refentrytitle>bioerror</refentrytitle><manvolnum>9F</manvolnum></citerefentry>. The driver should then complete the request by calling <citerefentry><refentrytitle>biodone</refentrytitle><manvolnum>9F</manvolnum></citerefentry>. <function>biodone</function> notifies the caller of  <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> that the transfer is complete. In this case, the transfer has stopped because of an error.</para>
	</listitem>
	<listitem>
		<para>Check whether the device is busy.</para>
		<para>Synchronous data transfers allow single-threaded access to the device. The device driver enforces this access in two ways:</para>
		<itemizedlist>
			<listitem><para>The driver maintains a busy flag that is guarded by a mutex.</para></listitem>
			<listitem><para>The driver waits on a condition variable with <citerefentry><refentrytitle>cv_wait</refentrytitle><manvolnum>9F</manvolnum></citerefentry>, when the device is busy.</para></listitem>
		</itemizedlist>
		<para>If the device is busy, the thread waits until the interrupt handler indicates that the device is not longer busy. The available status can be indicated by either the <citerefentry><refentrytitle>cv_broadcast</refentrytitle><manvolnum>9F</manvolnum></citerefentry> or the <citerefentry><refentrytitle>cv_signal</refentrytitle><manvolnum>9F</manvolnum></citerefentry> function. See <xref linkend="mt-17026" /> for details on condition variables.</para>
		<para>When the device is no longer busy, the <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> routine marks the device as available. <function>strategy</function> then prepares the buffer and the device for the transfer.</para>
	</listitem>
	<listitem>
		<para>Set up the buffer for DMA.</para>
		<para>Prepare the data buffer for a DMA transfer by using <citerefentry><refentrytitle>ddi_dma_alloc_handle</refentrytitle><manvolnum>9F</manvolnum></citerefentry> to allocate a DMA handle. Use <citerefentry><refentrytitle>ddi_dma_buf_bind_handle</refentrytitle><manvolnum>9F</manvolnum></citerefentry> to bind the data buffer to the handle. For information on setting up DMA resources and related data structures, see <xref linkend="dma-29901" />.</para></listitem>
	<listitem>
		<para>Begin the transfer.</para><para>At this point, a pointer to the <citerefentry><refentrytitle>buf</refentrytitle><manvolnum>9S</manvolnum></citerefentry> structure is saved in the state structure of the device. The interrupt routine can then complete the transfer by calling <citerefentry><refentrytitle>biodone</refentrytitle><manvolnum>9F</manvolnum></citerefentry>.</para>
		<para>The device driver then accesses device registers to initiate a data transfer. In most cases, the driver should protect the device registers from other threads by using mutexes. In this case, because <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> is single-threaded, guarding the device registers is not necessary. See <xref linkend="mt-17026" /> for details about data locks.</para>
		<para>When the executing thread has started the device's DMA engine, the driver can return execution control to the calling routine, as follows:</para>
		<programlisting>static int
xxstrategy(struct buf *bp)
{
    struct xxstate *xsp;
    struct device_reg *regp;
    minor_t instance;
    ddi_dma_cookie_t cookie;
    instance = getminor(bp-&gt;b_edev);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL) {
        bioerror(bp, ENXIO);
        biodone(bp);
        return (0);
    }
    /* validate the transfer request */
    if ((bp-&gt;b_blkno &gt;= xsp-&gt;Nblocks) || (bp-&gt;b_blkno &lt; 0)) {
        bioerror(bp, EINVAL);    
        biodone(bp);
        return (0);
    }
    /*
     * Hold off all threads until the device is not busy.
     */
    mutex_enter(&amp;xsp-&gt;mu);
    while (xsp-&gt;busy) {
        cv_wait(&amp;xsp-&gt;cv, &amp;xsp-&gt;mu);
    }
    xsp-&gt;busy = 1;
    mutex_exit(&amp;xsp-&gt;mu);
    /* 
     * If the device has power manageable components, 
     * mark the device busy with pm_busy_components(9F),
     * and then ensure that the device 
     * is powered up by calling pm_raise_power(9F).
     *
     * Set up DMA resources with ddi_dma_alloc_handle(9F) and
     * ddi_dma_buf_bind_handle(9F).
     */
    xsp-&gt;bp = bp;
    regp = xsp-&gt;regp;
    ddi_put32(xsp-&gt;data_access_handle, &amp;regp-&gt;dma_addr,
        cookie.dmac_address);
    ddi_put32(xsp-&gt;data_access_handle, &amp;regp-&gt;dma_size,
        (uint32_t)cookie.dmac_size);
    ddi_put8(xsp-&gt;data_access_handle, &amp;regp-&gt;csr,
        ENABLE_INTERRUPTS | START_TRANSFER);
    return (0);
}</programlisting>
	</listitem>
	<listitem>
		<para>Handle the interrupting device.</para>
		<para>When the device finishes the data transfer, the driver generates an interrupt, which eventually results in the driver's interrupt routine being called. Most drivers specify the state structure of the device as the argument to the interrupt routine when registering interrupts. See the <citerefentry><refentrytitle>ddi_add_intr</refentrytitle><manvolnum>9F</manvolnum></citerefentry> man page and <xref linkend="interrupt-14" />. The interrupt routine can then access the <citerefentry><refentrytitle>buf</refentrytitle><manvolnum>9S</manvolnum></citerefentry> structure being transferred, plus any other information that is available from the state structure.</para>
		<para>The interrupt handler should check the device's status register to determine whether the transfer completed without error. If an error occurred, the handler should indicate the appropriate error with  <citerefentry><refentrytitle>bioerror</refentrytitle><manvolnum>9F</manvolnum></citerefentry>. The handler should also clear the pending interrupt for the device and then complete the transfer by calling <citerefentry><refentrytitle>biodone</refentrytitle><manvolnum>9F</manvolnum></citerefentry>.</para>
		<para>As the final task, the handler clears the busy flag. The handler then calls <citerefentry><refentrytitle>cv_signal</refentrytitle><manvolnum>9F</manvolnum></citerefentry> or <citerefentry><refentrytitle>cv_broadcast</refentrytitle><manvolnum>9F</manvolnum></citerefentry> on the condition variable, signaling that the device is no longer busy. This notification enables other threads waiting for the device in <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> to proceed with the next data transfer.</para>
		<para>The following example shows a synchronous interrupt routine.</para>
	</listitem>
</orderedlist>
<example xml:id="block-ex-19">
<title>Synchronous Interrupt Routine for Block Drivers</title>
<programlisting>static u_int
xxintr(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct buf *bp;
    uint8_t status;
    mutex_enter(&amp;xsp-&gt;mu);
    status = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);
    if (!(status &amp; INTERRUPTING)) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_INTR_UNCLAIMED);
    }
    /* Get the buf responsible for this interrupt */
    bp = xsp-&gt;bp;
    xsp-&gt;bp = NULL;
    /*
     * This example is for a simple device which either
     * succeeds or fails the data transfer, indicated in the
     * command/status register.
     */
    if (status &amp; DEVICE_ERROR) {
        /* failure */
        bp-&gt;b_resid = bp-&gt;b_bcount;
        bioerror(bp, EIO);
    } else {
        /* success */
        bp-&gt;b_resid = 0;
    }
    ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr,
        CLEAR_INTERRUPT);
    /* The transfer has finished, successfully or not */
    biodone(bp);
    /*
     * If the device has power manageable components that were
     * marked busy in strategy(9F), mark them idle now with
     * pm_idle_component(9F)
     * Release any resources used in the transfer, such as DMA
     * resources ddi_dma_unbind_handle(9F) and
     * ddi_dma_free_handle(9F).
     *
     * Let the next I/O thread have access to the device.
     */
    xsp-&gt;busy = 0;
    cv_signal(&amp;xsp-&gt;cv);
    mutex_exit(&amp;xsp-&gt;mu);
    return (DDI_INTR_CLAIMED);
}</programlisting>
</example>
</sect1>
<sect1 xml:id="block-54698">
<title>Asynchronous Data Transfers (Block Drivers)</title>
<para><indexterm xml:id="block-ix439"><primary>I/O</primary><secondary>asynchronous data transfers</secondary></indexterm><indexterm><primary>asynchronous data transfers</primary><secondary>block drivers</secondary></indexterm>This section
presents a method for performing asynchronous I/O transfers. The driver queues
the I/O requests and then returns control to the caller. Again, the assumption
is that the hardware is a simple disk device that allows one transfer at a
time. The device interrupts when a data transfer has completed. An interrupt
also takes place if an error occurs. The basic steps for performing asynchronous
data transfers are:</para><orderedlist><listitem><para>Check for invalid <citerefentry><refentrytitle>buf</refentrytitle><manvolnum>9S</manvolnum></citerefentry> requests.</para>
</listitem><listitem><para>Enqueue the request.</para>
</listitem><listitem><para>Start the first transfer.</para>
</listitem><listitem><para>Handle the interrupting device.</para>
</listitem>
</orderedlist><sect2 xml:id="fblew"><title>Checking for Invalid <varname role="structname">buf</varname> Requests</title><para>As in the synchronous case, the device driver should check the <citerefentry><refentrytitle>buf</refentrytitle><manvolnum>9S</manvolnum></citerefentry> structure passed to  <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> for validity.
See <xref linkend="block-78892" /> for
more details.</para>
</sect2><sect2 xml:id="fbleu"><title>Enqueuing the Request</title><para>Unlike synchronous data transfers, a driver does not wait for an asynchronous
request to complete. Instead, the driver adds the request to a queue. The
head of the queue can be the current transfer. The head of the queue can also
be a separate field in the state structure for holding the active request,
as in <xref linkend="fblfb" />.</para>
<para>If the queue is initially empty, then the hardware is not busy and <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> starts the
transfer before returning. Otherwise, if a transfer completes with a non-empty
queue, the interrupt routine begins a new transfer.  <xref linkend="fblfb" /> places the decision of whether to start a new transfer into a separate
routine for convenience.</para><para>The driver can use the <varname role="structfield">av_forw</varname> and the <varname role="structfield">av_back</varname> members of the <citerefentry><refentrytitle>buf</refentrytitle><manvolnum>9S</manvolnum></citerefentry> structure to manage a list of transfer requests. A
single pointer can be used to manage a singly linked list, or both pointers
can be used together to build a doubly linked list. The device hardware specification
specifies which type of list management, such as insertion policies, is used
to optimize the performance of the device. The transfer list is a per-device
list, so the head and tail of the list are stored in the state structure.</para><para>The following example provides multiple threads with access to the driver
shared data, such as the transfer list. You must identify the shared data
and must protect the data with a mutex. See <xref linkend="mt-17026" /> for more details about mutex locks.</para>
<example xml:id="fblfb">
<title>Enqueuing Data Transfer Requests for Block Drivers</title>
<programlisting>static int
xxstrategy(struct buf *bp)
{
    struct xxstate *xsp;
    minor_t instance;
    instance = getminor(bp-&gt;b_edev);
    xsp = ddi_get_soft_state(statep, instance);
    /* ... */
    /* validate transfer request */
    /* ... */
    /*
     * Add the request to the end of the queue. Depending on the device, a sorting
     * algorithm, such as disksort(9F) can be used if it improves the
     * performance of the device.
     */
    mutex_enter(&amp;xsp-&gt;mu);
    bp-&gt;av_forw = NULL;
    if (xsp-&gt;list_head) {
        /* Non-empty transfer list */
        xsp-&gt;list_tail-&gt;av_forw = bp;
        xsp-&gt;list_tail = bp;
    } else {
        /* Empty Transfer list */
        xsp-&gt;list_head = bp;
        xsp-&gt;list_tail = bp;
    }
    mutex_exit(&amp;xsp-&gt;mu);
    /* Start the transfer if possible */
    (void) xxstart((caddr_t)xsp);
    return (0);
}</programlisting>
</example>
</sect2><sect2 xml:id="fblev"><title>Starting the First Transfer</title><para>Device drivers that implement queuing usually have a <function>start</function> routine. <function>start</function> dequeues the next request and starts the data transfer to
or from the device. In this example, <function>start</function> processes
all requests regardless of the state of the device, whether busy or free.</para><note><para><function>start</function> must be written to be called from any
context. <function>start</function> can be called by both the strategy routine
in kernel context and the interrupt routine in interrupt context.</para>
</note><para><function>start</function> is called by <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> every time <function>strategy</function> queues
a request so that an idle device can be started. If the device is busy, <function>start</function> returns immediately.</para><para><function>start</function> is also called by the interrupt handler before
the handler returns from a claimed interrupt so that a nonempty queue can
be serviced. If the queue is empty, <function>start</function> returns immediately.</para><para>Because <function>start</function> is a private driver routine, <function>start</function> can take any arguments and can return any type. The following
code sample is written to be used as a DMA callback, although that portion
is not shown. Accordingly, the example must take a <literal>caddr_t</literal> as
an argument and return an <literal>int</literal>. See <xref linkend="dma-200" /> for more information about DMA
callback routines.</para><example xml:id="fblfa"><title>Starting the First Data Request for a Block Driver</title><programlisting>static int
xxstart(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct buf *bp;

    mutex_enter(&amp;xsp-&gt;mu);
    /*
     * If there is nothing more to do, or the device is
     * busy, return.
     */
    if (xsp-&gt;list_head == NULL || xsp-&gt;busy) {
       mutex_exit(&amp;xsp-&gt;mu);
       return (0);
    }
    xsp-&gt;busy = 1;
    /* Get the first buffer off the transfer list */
    bp = xsp-&gt;list_head;
    /* Update the head and tail pointer */
    xsp-&gt;list_head = xsp-&gt;list_head-&gt;av_forw;
    if (xsp-&gt;list_head == NULL)
       xsp-&gt;list_tail = NULL;
    bp-&gt;av_forw = NULL;
    mutex_exit(&amp;xsp-&gt;mu);
    /* 
     * If the device has power manageable components, 
     * mark the device busy with pm_busy_components(9F),
     * and then ensure that the device 
     * is powered up by calling pm_raise_power(9F).
     *
     * Set up DMA resources with ddi_dma_alloc_handle(9F) and
     * ddi_dma_buf_bind_handle(9F).
     */
    xsp-&gt;bp = bp;
    ddi_put32(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;dma_addr,
        cookie.dmac_address);
    ddi_put32(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;dma_size,
        (uint32_t)cookie.dmac_size);
    ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr,
        ENABLE_INTERRUPTS | START_TRANSFER);
    return (0);
}</programlisting>
</example>
</sect2><sect2 xml:id="fbles"><title>Handling the Interrupting Device</title><para>The interrupt routine is similar to the asynchronous version, with the
addition of the call to <function>start</function> and the removal of the
call to <citerefentry><refentrytitle>cv_signal</refentrytitle><manvolnum>9F</manvolnum></citerefentry>.</para>
<example xml:id="block-33565">
<title>Block Driver Routine for Asynchronous Interrupts</title>
<programlisting>static u_int
xxintr(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct buf *bp;
    uint8_t status;
    mutex_enter(&amp;xsp-&gt;mu);
    status = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);
    if (!(status &amp; INTERRUPTING)) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_INTR_UNCLAIMED);
    }
    /* Get the buf responsible for this interrupt */
    bp = xsp-&gt;bp;
    xsp-&gt;bp = NULL;
    /*
     * This example is for a simple device which either
     * succeeds or fails the data transfer, indicated in the
     * command/status register.
     */
    if (status &amp; DEVICE_ERROR) {
        /* failure */
        bp-&gt;b_resid = bp-&gt;b_bcount;
        bioerror(bp, EIO);
    } else {
        /* success */
        bp-&gt;b_resid = 0;
    }
    ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr,
        CLEAR_INTERRUPT);
    /* The transfer has finished, successfully or not */
    biodone(bp);
    /*
     * If the device has power manageable components that were
     * marked busy in strategy(9F), mark them idle now with
     * pm_idle_component(9F)
     * Release any resources used in the transfer, such as DMA
     * resources (ddi_dma_unbind_handle(9F) and
     * ddi_dma_free_handle(9F)).
     *
     * Let the next I/O thread have access to the device.
     */
    xsp-&gt;busy = 0;
    mutex_exit(&amp;xsp-&gt;mu);
    (void) xxstart((caddr_t)xsp);
    return (DDI_INTR_CLAIMED);
}</programlisting>
</example>
</sect2>
</sect1>
<sect1 xml:id="block-25">
<title><function>dump</function> and <function>print</function> Entry Points</title>
<para>This section discusses the <citerefentry><refentrytitle>dump</refentrytitle><manvolnum>9E</manvolnum></citerefentry> and <citerefentry><refentrytitle>print</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry points.</para>
<sect2 xml:id="block-26">
<title><function>dump</function> Entry Point (Block Drivers)</title>
<para><indexterm xml:id="block-ix440"><primary><function>dump</function> entry point</primary><secondary>block drivers</secondary></indexterm>The <citerefentry><refentrytitle>dump</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry point is used to copy
a portion of virtual address space directly to the specified device in the
case of a system failure. <function>dump</function> is also used to copy the
state of the kernel out to disk during a checkpoint operation. See the <citerefentry><refentrytitle>cpr</refentrytitle><manvolnum>7</manvolnum></citerefentry> and <citerefentry><refentrytitle>dump</refentrytitle><manvolnum>9E</manvolnum></citerefentry> man pages for more information.
The entry point must be capable of performing this operation without the use
of interrupts, because interrupts are disabled during  the checkpoint operation.</para><programlisting>int dump(dev_t <replaceable>dev</replaceable>, caddr_t <replaceable>addr</replaceable>, daddr_t <replaceable>blkno</replaceable>, int <replaceable>nblk</replaceable>)</programlisting><para>where:</para><variablelist><varlistentry><term><replaceable>dev</replaceable></term><listitem><para>Device number of the device to receive the dump.</para>
</listitem>
</varlistentry><varlistentry><term><replaceable>addr</replaceable></term><listitem><para>Base kernel virtual address at which to start the dump.</para>
</listitem>
</varlistentry><varlistentry><term><replaceable>blkno</replaceable></term><listitem><para>Block at which the dump is to start.</para>
</listitem>
</varlistentry><varlistentry><term><replaceable>nblk</replaceable></term><listitem><para>Number of blocks to dump.</para>
</listitem>
</varlistentry>
</variablelist><para>The dump depends upon the existing driver working properly.</para>
</sect2>
<sect2 xml:id="block-27">
<title><function>print</function> Entry Point (Block Drivers)</title>
<programlisting>int print(dev_t <replaceable>dev</replaceable>, char *<replaceable>str</replaceable>)</programlisting>
<para><indexterm xml:id="block-ix441"><primary>error messages, printing</primary></indexterm><indexterm xml:id="block-ix442"><primary><function>print</function> entry point</primary><secondary>block drivers</secondary></indexterm><indexterm xml:id="block-ix443"><primary><function>cmn_err</function> function</primary><secondary>example of</secondary></indexterm>The <citerefentry><refentrytitle>print</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry point is called by
the system to display a message about an exception that has been detected. <citerefentry><refentrytitle>print</refentrytitle><manvolnum>9E</manvolnum></citerefentry> should call <citerefentry><refentrytitle>cmn_err</refentrytitle><manvolnum>9F</manvolnum></citerefentry> to post the
message to the console on behalf of the system. The following example demonstrates
a typical <function>print</function> entry point.</para>
<programlisting>static int
xxprint(dev_t dev, char *str)
{
    cmn_err(CE_CONT, &ldquo;xx: %s\n&rdquo;, str);
    return (0);
}</programlisting>
</sect2>
</sect1>
<sect1 xml:id="advanced-7">
<title>Disk Device Drivers</title>
<para>Disk devices represent an important class of block device drivers.</para>
<sect2 xml:id="advanced-8">
<title>Disk <literal>ioctl</literal>s</title>
<para><indexterm xml:id="fblgy"><primary>I/O</primary><secondary>disk controls</secondary></indexterm><indexterm xml:id="fblgi"><primary>disk</primary><secondary>I/O controls</secondary></indexterm>illumos disk drivers need to support a minimum set of <literal>ioctl</literal> commands
specific to illumos disk drivers. These I/O controls are specified in the <citerefentry><refentrytitle>dkio</refentrytitle><manvolnum>7I</manvolnum></citerefentry> manual page. Disk I/O controls
transfer disk information to or from the device driver. An illumos disk device
is supported by disk utility commands such as <citerefentry><refentrytitle>format</refentrytitle><manvolnum>1M</manvolnum></citerefentry> and <citerefentry><refentrytitle>newfs</refentrytitle><manvolnum>1M</manvolnum></citerefentry>. The mandatory illumos disk I/O
controls are as follows:</para>
<variablelist>
	<varlistentry>
		<term><returnvalue>DKIOCINFO</returnvalue></term>
		<listitem><para>Returns information that describes the disk controller</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><returnvalue>DKIOCGAPART</returnvalue></term>
		<listitem><para>Returns a disk's partition map</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><returnvalue>DKIOCSAPART</returnvalue></term>
		<listitem><para>Sets a disk's partition map</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><returnvalue>DKIOCGGEOM</returnvalue></term>
		<listitem><para>Returns a disk's geometry</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><returnvalue>DKIOCSGEOM</returnvalue></term>
		<listitem><para>Sets a disk's geometry</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><returnvalue>DKIOCGVTOC</returnvalue></term>
		<listitem><para>Returns a disk's Volume Table of Contents</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><returnvalue>DKIOCSVTOC</returnvalue></term>
		<listitem><para>Sets a disk's Volume Table of Contents</para></listitem>
	</varlistentry>
</variablelist>
</sect2>
<sect2 xml:id="advanced-9">
<title>Disk Performance</title>
<para><indexterm xml:id="advanced-ix685"><primary>DDI/DKI</primary><secondary sortas="disk">and disk performance</secondary></indexterm><indexterm xml:id="advanced-ix686"><primary>disk</primary><secondary>performance</secondary></indexterm>The illumos DDI/DKI provides facilities to optimize I/O transfers
for improved file system performance. A mechanism manages the list of I/O
requests so as to optimize disk access for a file system. See <xref linkend="block-54698" /> for
a description of enqueuing an I/O request.</para>
<para>The <varname role="structname">diskhd</varname> structure is used to manage a linked list of I/O requests.</para>
<programlisting>struct diskhd {
    long     b_flags;         /* not used, needed for consistency*/
    struct   buf *b_forw,     *b_back;     /* queue of unit queues */
    struct   buf *av_forw,    *av_back;    /* queue of bufs for this unit */
    long     b_bcount;        /* active flag */
};</programlisting>
<para>The <varname role="structname">diskhd</varname> data structure has two <varname role="structfield">buf</varname> pointers that the driver can manipulate. The <varname role="structfield">av_forw</varname> pointer
points to the first active I/O request. The second pointer, <varname role="structfield">av_back</varname>,
points to the last active request on the list.</para>
<para>A pointer to this structure is passed as an argument to <citerefentry><refentrytitle>disksort</refentrytitle><manvolnum>9F</manvolnum></citerefentry>, along with
a pointer to the current <varname role="structname">buf</varname> structure being processed.
The <function>disksort</function> routine sorts the <varname role="structname">buf</varname> requests
to optimize disk seek. The routine then inserts the <varname role="structfield">buf</varname> pointer
into the <varname role="structfield">diskhd</varname> list. The <function>disksort</function> program
uses the value that is in <varname role="structfield">b_resid</varname> of the <varname role="structname">buf</varname> structure as a sort key. The driver is responsible for setting
this value. Most illumos disk drivers use the cylinder group as the sort key.
This approach optimizes the file system read-ahead accesses.</para><para>When data has been added to the <literal>diskhd</literal> list, the
device needs to transfer the data. If the device is not busy processing a
request, the <function>xxstart</function> routine pulls the first <varname role="structname">buf</varname> structure off the <literal>diskhd</literal> list and starts
a transfer.</para><para>If the device is busy, the driver should return from the <function>xxstrategy</function> entry point. When the hardware is done with the data transfer,
an interrupt is generated. The driver's interrupt routine is then called to
service the device. After servicing the interrupt, the driver can then call
the <function>start</function> routine to process the next <varname role="structname">buf</varname> structure
in the <literal>diskhd</literal> list.</para>
</sect2>
</sect1>
</chapter>

<chapter xml:id="eqbqn">
<title>Overview of illumos Device Drivers</title>
<para>This chapter gives an overview of illumos device drivers. The chapter
	provides information on the following subjects:</para>
<itemizedlist>
	<listitem><para><xref linkend="eqbqp" /></para></listitem>
	<listitem><para><xref linkend="eqbqy" /></para></listitem>
	<listitem><para><xref linkend="kernelovr-41" /></para></listitem>
</itemizedlist>
<sect1 xml:id="eqbqp">
<title>Device Driver Basics</title>
<para>This section introduces you to device drivers and their entry points on the illumos platform.</para>
<sect2 xml:id="eqbqt">
<title>What Is a Device Driver?</title>
<para><indexterm xml:id="eqbqq"><primary>device drivers</primary><secondary>definition</secondary></indexterm><indexterm xml:id="eqbqr"><primary>pseudo device driver</primary></indexterm>A <emphasis>device driver</emphasis> is a kernel module that is
responsible for managing the low-level I/O operations of a hardware device.
Device drivers are written with standard interfaces that the kernel can call
to interface with a device. Device drivers can also be software-only, emulating
a device that exists only in software, such as RAM disks, buses, and pseudo-terminals.</para>
<para>A device driver contains all the device-specific code necessary to communicate
with a device. This code includes a standard set of interfaces to the rest
of the system. This interface shields the kernel from device specifics just
as the system call interface protects application programs from platform specifics.
Application programs and the rest of the kernel need little, if any, device-specific
code to address the device. In this way, device drivers make the system more
portable and easier to maintain.</para>
<para>When illumos is initialized, devices
identify themselves and are organized into the  <emphasis>device tree</emphasis>,
a hierarchy of devices. In effect, the device tree is a hardware model for
the kernel. An individual device driver is represented as a node in the tree
with no children. This type of node is referred to as a <emphasis>leaf driver</emphasis>.
A driver that provides services to other drivers is called a <emphasis>bus
nexus driver</emphasis> and is shown as a node with children. As part of the
boot process, physical devices are mapped to drivers in the tree so that the
drivers can be located when needed. For more information on how illumos
accommodates devices, see <xref linkend="kernelovr-77198" />.</para>
<para>Device drivers are classified by how they handle I/O. Device drivers
	fall into three broad categories:</para>
<itemizedlist>
	<listitem>
		<para><emphasis role="strong">Block device drivers</emphasis> &ndash;
			For cases where handling I/O data as asynchronous chunks is appropriate. Typically,
			block drivers are used to manage devices with physically addressable storage
			media, such as disks.</para>
	</listitem>
	<listitem>
		<para><emphasis role="strong">Character device drivers</emphasis> &ndash;
			For devices that perform I/O on a continuous flow of bytes.</para>
		<note><para>A driver can be both block and character at the same time if you set up two different interfaces to the file system. See <xref linkend="kernelovr-4" />.</para></note>
		<para>Included in the character category are drivers that use the STREAMS
			model (see below), programmed I/O, direct memory access, SCSI buses, USB,
			and other network I/O.</para>
	</listitem>
	<listitem>
		<para><emphasis role="strong">STREAMS device drivers</emphasis> &ndash;
			Subset of character drivers that uses the <citerefentry><refentrytitle>streamio</refentrytitle><manvolnum>7I</manvolnum></citerefentry> set of routines for character
			I/O within the kernel.</para>
</listitem>
</itemizedlist>
</sect2><sect2 xml:id="eqbqu"><title>What Is a Device Driver Entry Point?</title><para><indexterm><primary>driver module entry points</primary><see>entry points</see></indexterm><indexterm><primary>entry points</primary><secondary>definition</secondary></indexterm><indexterm><primary>device drivers</primary><secondary>entry points</secondary></indexterm>An <emphasis>entry point</emphasis> is a function within a device
driver that can be called by an external entity to get access to some driver
functionality or to operate a device. Each device driver provides a standard
set of functions as entry points. For the complete list of entry points for
all driver types, see the <citerefentry><refentrytitle>Intro</refentrytitle><manvolnum>9E</manvolnum></citerefentry> man
page. The illumos kernel uses entry points for these general task areas:</para><itemizedlist><listitem><para><emphasis role="strong">Loading and unloading the driver</emphasis></para>
</listitem><listitem><para><emphasis role="strong">Autoconfiguring the device</emphasis> &ndash;
Autoconfiguration is the process of loading a device driver's code and static
data into memory so that the driver is registered with the system.</para>
</listitem><listitem><para><emphasis role="strong">Providing I/O services for the driver</emphasis></para>
</listitem>
</itemizedlist><para>Drivers for different types of devices have different sets of entry
points according to the kinds of operations the devices perform. A driver
for a memory-mapped character-oriented device, for example, supports a <citerefentry><refentrytitle>devmap</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry point,
while a block driver does not support this entry.</para><para><indexterm><primary>naming</primary><secondary>unique prefix for driver symbols</secondary></indexterm><indexterm><primary>prefix</primary><secondary>unique prefix for driver symbols</secondary></indexterm>Use a prefix based on the
name of your driver to give driver functions unique names. Typically, this
prefix is the name of the driver, such as <function>xx_open</function> for
the <citerefentry><refentrytitle>open</refentrytitle><manvolnum>9E</manvolnum></citerefentry>
routine of driver <literal>xx</literal>. See <xref linkend="gfhey" /> for
more information. In subsequent examples in this book, <literal>xx</literal> is
used as the driver prefix.</para>
</sect2>
</sect1>
<sect1 xml:id="eqbqy">
<title>Device Driver Entry Points</title>
<para>This section provides lists of entry points for the following categories:</para>
<itemizedlist>
	<listitem><para><xref linkend="eqbwb" /></para></listitem>
	<listitem><para><xref linkend="eqbrc" /></para></listitem>
	<listitem><para><xref linkend="eqbuw" /></para></listitem>
	<listitem><para><xref linkend="eqbvd" /></para></listitem>
	<listitem><para><xref linkend="eqbuf" /></para></listitem>
	<listitem><para><xref linkend="eqbwc" /></para></listitem>
	<listitem><para><xref linkend="eqbsr" /></para></listitem>
	<listitem><para><xref linkend="eqbwn" /></para></listitem>
</itemizedlist>
<sect2 xml:id="eqbwb">
<title>Entry Points Common to All Drivers</title>
<para>Some operations can be performed by any type of driver, such as the
functions that are required for module loading and for the required autoconfiguration
entry points. This section discusses types of entry points that are common
to all drivers. The common entry points are listed in <xref linkend="eqbur" />
with links to man pages and other relevant discussions.</para>
<sect3 xml:id="eqbvk">
<title>Device Access Entry Points</title>
<para>Drivers for character and block devices export the <citerefentry><refentrytitle>cb_ops</refentrytitle><manvolnum>9S</manvolnum></citerefentry> structure,
which defines the driver entry points for block device access and character
device access.  Both types of drivers are required to support the <citerefentry><refentrytitle>open</refentrytitle><manvolnum>9E</manvolnum></citerefentry> and <citerefentry><refentrytitle>close</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry points.  Block drivers
are required to support <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry>,
while character drivers can choose to implement whatever mix of <citerefentry><refentrytitle>read</refentrytitle><manvolnum>9E</manvolnum></citerefentry>, <citerefentry><refentrytitle>write</refentrytitle><manvolnum>9E</manvolnum></citerefentry>, <citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>9E</manvolnum></citerefentry>, <citerefentry><refentrytitle>mmap</refentrytitle><manvolnum>9E</manvolnum></citerefentry>, or <citerefentry><refentrytitle>devmap</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry points is appropriate
for the type of  device. Character drivers can also support a polling interface
 through <citerefentry><refentrytitle>chpoll</refentrytitle><manvolnum>9E</manvolnum></citerefentry>.
Asynchronous I/O is supported through  <citerefentry><refentrytitle>aread</refentrytitle><manvolnum>9E</manvolnum></citerefentry> and <citerefentry><refentrytitle>awrite</refentrytitle><manvolnum>9E</manvolnum></citerefentry> for block
drivers and those drivers that can use both block and character file systems.</para>
</sect3>
<sect3 xml:id="eqbth">
<title>Loadable Module Entry Points</title>
<para><indexterm><primary><function>_init</function> entry point</primary><secondary>required implementation</secondary></indexterm><indexterm><primary><function>_fini</function> entry point</primary><secondary>required implementation</secondary></indexterm><indexterm><primary><function>_info</function> entry point</primary><secondary>required implementation</secondary></indexterm><indexterm><primary>loading modules</primary></indexterm>All drivers are required to implement the loadable
module entry points <citerefentry><refentrytitle>_init</refentrytitle><manvolnum>9E</manvolnum></citerefentry>, <citerefentry><refentrytitle>_fini</refentrytitle><manvolnum>9E</manvolnum></citerefentry>, and <citerefentry><refentrytitle>_info</refentrytitle><manvolnum>9E</manvolnum></citerefentry> to load,
unload, and report information about the driver module.</para><para>Drivers should allocate and initialize any global resources in <citerefentry><refentrytitle>_init</refentrytitle><manvolnum>9E</manvolnum></citerefentry>. Drivers
should release their resources in <citerefentry><refentrytitle>_fini</refentrytitle><manvolnum>9E</manvolnum></citerefentry>.</para>
<note><para>In illumos, only the loadable module routines must be visible
outside the driver object module. Other routines can have the storage class <filename>static</filename>.</para>
</note>
</sect3><sect3 xml:id="eqbvi"><title>Autoconfiguration Entry Points</title><indexterm><primary>autoconfiguration</primary><secondary>routines</secondary>
</indexterm><para>Drivers are required to implement the <citerefentry><refentrytitle>attach</refentrytitle><manvolnum>9E</manvolnum></citerefentry>, <citerefentry><refentrytitle>detach</refentrytitle><manvolnum>9E</manvolnum></citerefentry>, and <citerefentry><refentrytitle>getinfo</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry points
for device autoconfiguration.  Drivers can also implement the optional entry
point <citerefentry><refentrytitle>probe</refentrytitle><manvolnum>9E</manvolnum></citerefentry> in
cases where devices do not identify themselves during boot-up, such as SCSI
target devices. See <xref linkend="autoconf-17" /> for more information on these routines.</para>
</sect3>
<sect3 xml:id="eqbsz">
<title>Kernel Statistics Entry Points</title>
<para>The illumos platform provides a rich set of interfaces to maintain and
export kernel-level statistics, also known as <emphasis>kstats</emphasis>.
Drivers are free to use these interfaces to export driver and device statistics
that can be used by user applications to observe the internal state of the
driver.  Two entry points are provided for working with kernel statistics:</para>
<itemizedlist>
	<listitem><para><citerefentry><refentrytitle>ks_snapshot</refentrytitle><manvolnum>9E</manvolnum></citerefentry> captures kstats at a specific time.</para></listitem>
	<listitem><para><citerefentry><refentrytitle>ks_update</refentrytitle><manvolnum>9E</manvolnum></citerefentry> can be used to update kstat data at will. <function>ks_update</function> is useful in situations where a device is set up to track kernel data but extracting that data is time-consuming.</para></listitem>
</itemizedlist>
<para>For further information, see the <citerefentry><refentrytitle>kstat_create</refentrytitle><manvolnum>9F</manvolnum></citerefentry> and <citerefentry><refentrytitle>kstat</refentrytitle><manvolnum>9S</manvolnum></citerefentry> man pages. See also <xref linkend="euqcp" />.</para>
</sect3>
<sect3 xml:id="eqbut">
<title>Power Management Entry Point</title>
<para>Drivers for hardware devices that provide Power Management functionality
can support the optional <citerefentry><refentrytitle>power</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry
point. See <xref linkend="powermgt-37437" /> for
details about this entry point.</para>
</sect3>
<sect3 xml:id="eqbur">
<title>Summary of Common Entry Points</title>
<para>The following table lists entry points that can be used by all types
	of drivers.</para>
<table frame="topbot" pgwide="1" xml:id="eqbqz">
<title>Entry Points for All Driver Types</title>
<tgroup cols="3" colsep="0" rowsep="0">
	<colspec colwidth="25.88*"/>
	<colspec colname="colspec2" colwidth="10.66*"/>
	<colspec colname="colspec0" colwidth="54.81*"/>
	<thead>
		<row rowsep="1">
			<entry><para>Category / Entry Point</para></entry>
			<entry><para>Usage</para></entry>
			<entry><para>Description</para></entry>
		</row>
	</thead>
	<tbody>
		<row>
			<entry><para><literal>cb_ops</literal> <emphasis role="strong">Entry Points</emphasis></para></entry>
			<entry></entry>
			<entry></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>open</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry>
				<para>Gets access to a device. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="character-7" /></para></listitem>
					<listitem><para><xref linkend="block-7" /></para></listitem>
				</itemizedlist>
			</entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>close</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry>
				<para>Gives up access to a device. The version of  <function>close</function> for STREAMS drivers has a different signature than character and block drivers. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="character-8" /></para></listitem>
					<listitem><para><xref linkend="block-8" /></para></listitem>
				</itemizedlist>
			</entry>
		</row>
		<row>
			<entry><para><emphasis role="strong">Loadable Module Entry Points</emphasis></para></entry>
			<entry></entry>
			<entry></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>_init</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Initializes a loadable module. Additional information: <xref linkend="autoconf-95548" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>_fini</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Prepares a loadable module for unloading. Required for all driver types. Additional information: <xref linkend="autoconf-95548" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>_info</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Returns information about a loadable module. Additional information: <xref linkend="autoconf-95548" /></para></entry>
		</row>
		<row>
			<entry><para><emphasis role="strong">Autoconfiguration Entry Points</emphasis></para></entry>
			<entry></entry>
			<entry></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>attach</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Adds a device to the system as part of initialization. Also used to resume a system that has been suspended. Additional information: <xref linkend="autoconf-41111" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>detach</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Detaches a device from the system. Also, used to suspend a device temporarily. Additional information: <xref linkend="autoconf-72235" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>getinfo</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry>
				<para>Gets device information that is specific to the driver, such as the mapping between a device number and the corresponding instance. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="autoconf-28012" /></para></listitem>
					<listitem><para><xref linkend="scsi-31824" />.</para></listitem>
				</itemizedlist>
			</entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>probe</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>See Description</para></entry>
			<entry>
				<para>Determines if a non-self-identifying device is present. Required for a device that cannot identify itself. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="autoconf-87993" /></para></listitem>
					<listitem><para><xref linkend="scsi-65313" /></para></listitem>
				</itemizedlist>
			</entry>
		</row>
		<row>
			<entry><para><emphasis role="strong">Kernel Statistics Entry Points</emphasis></para></entry>
			<entry></entry>
			<entry></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>ks_snapshot</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Takes a snapshot of <citerefentry><refentrytitle>kstat</refentrytitle><manvolnum>9S</manvolnum></citerefentry> data. Additional information: <xref linkend="euqcp" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>ks_update</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Updates <citerefentry><refentrytitle>kstat</refentrytitle><manvolnum>9S</manvolnum></citerefentry> data dynamically. Additional information: <xref linkend="euqcp" /></para></entry>
		</row>
		<row>
			<entry><para><emphasis role="strong">Power Management Entry Points</emphasis></para></entry>
			<entry></entry>
			<entry></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>power</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Sets the power level of a device. If not used, set to <literal>NULL</literal>. Additional information: <xref linkend="powermgt-129" /></para></entry>
		</row>
		<row>
			<entry><para><emphasis role="strong">Miscellaneous Entry Points</emphasis></para></entry>
			<entry></entry>
			<entry></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>prop_op</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>See Description</para></entry>
			<entry>
				<para>Reports driver property information. Required unless <citerefentry><refentrytitle>ddi_prop_op</refentrytitle><manvolnum>9F</manvolnum></citerefentry> is substituted. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="properties-18" /></para></listitem>
					<listitem><para><xref linkend="properties-20" /></para></listitem>
				</itemizedlist>
			</entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>dump</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>See Description</para></entry>
			<entry>
				<para>Dumps memory to a device during system failure. Required for any device that is to be used as the dump device during a panic. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="block-26" /></para></listitem>
					<listitem><para><xref linkend="scsi-1a" /></para></listitem>
				</itemizedlist>
			</entry>
		</row>
		<row>
			<entry><para><literal>identify</literal>(9E)</para></entry>
			<entry><para>Obsolete</para></entry>
			<entry><para>Do not use this entry point. Assign <citerefentry><refentrytitle>nulldev</refentrytitle><manvolnum>9F</manvolnum></citerefentry> to this entry point in the <varname role="structname">dev_ops</varname> structure.</para></entry>
		</row>
	</tbody>
</tgroup>
</table>
</sect3>
</sect2>
<sect2 xml:id="eqbrc">
<title>Entry Points for Block Device Drivers</title>
<para><indexterm xml:id="drvovr-ix95"><primary>block driver</primary><secondary>overview</secondary></indexterm><indexterm xml:id="drvovr-ix96"><primary>device drivers</primary><secondary>block driver</secondary></indexterm>Devices that support a file
system are known as <emphasis>block devices</emphasis>. Drivers written for
these devices are known as block device drivers. Block device drivers take
a file system request, in the form of a <citerefentry><refentrytitle>buf</refentrytitle><manvolnum>9S</manvolnum></citerefentry> structure, and issue the I/O operations to the disk
to transfer the specified block. The main interface to the file system is
the <citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry> routine.
See <xref linkend="block-34861" /> for more information.</para>
<para>A block device driver can also provide a character driver interface
to enable utility programs to bypass the file system and to access the device
directly. This device access is commonly referred to as the <emphasis>raw</emphasis> interface
to a block device.</para>
<para>The following table lists additional entry points that can be used by
block device drivers. See also <xref linkend="eqbwb" />.</para>
<table frame="topbot" pgwide="1" xml:id="eqbre">
<title>Additional Entry Points for Block Drivers</title>
<tgroup cols="3" colsep="0" rowsep="0">
	<colspec colwidth="26.58*"/>
	<colspec colname="colspec3" colwidth="10.61*"/>
	<colspec colname="colspec0" colwidth="55.79*"/>
	<thead>
		<row rowsep="1">
			<entry><para>Entry Point</para></entry>
			<entry><para>Usage</para></entry>
			<entry><para>Description</para></entry>
		</row>
	</thead>
	<tbody>
		<row>
			<entry><para><citerefentry><refentrytitle>aread</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry>
				<para>Performs an asynchronous read. Drivers that do not support an <function>aread</function> entry point should use the <citerefentry><refentrytitle>nodev</refentrytitle><manvolnum>9F</manvolnum></citerefentry> error return function. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="character-11" /></para></listitem>
					<listitem><para><xref linkend="character-16" /></para></listitem>
				</itemizedlist>
			</entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>awrite</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry>
				<para>Performs an asynchronous write. Drivers that do not support an <function>awrite</function> entry point should use the <citerefentry><refentrytitle>nodev</refentrytitle><manvolnum>9F</manvolnum></citerefentry> error return function. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="character-11" /></para></listitem>
					<listitem><para><xref linkend="character-16" /></para></listitem>
				</itemizedlist>
			</entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>print</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Displays a driver message on the system console. Additional information: <xref linkend="block-27" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry>
				<para>Perform block I/O. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="dma-28600" /></para></listitem>
					<listitem><para><xref linkend="character-35745" /></para></listitem>
					<listitem><para><xref linkend="character-64481" /></para></listitem>
					<listitem><para><xref linkend="character-16" /></para></listitem>
					<listitem><para><xref linkend="scsi-5" /></para></listitem>
					<listitem><para><xref linkend="scsihba-94" /></para></listitem>
				</itemizedlist>
			</entry>
		</row>
	</tbody>
</tgroup>
</table>
</sect2>
<sect2 xml:id="eqbuw">
<title>Entry Points for Character Device Drivers</title>
<indexterm xml:id="drvovr-ix97"><primary>device drivers</primary><secondary>standard character driver</secondary></indexterm>
<indexterm xml:id="drvovr-ix98"><primary>character device driver</primary><secondary>overview</secondary></indexterm>
<para>Character device drivers normally perform I/O in a byte stream. Examples
of devices that use character drivers include tape drives and serial ports.
Character device drivers can also provide additional interfaces not present
in block drivers, such as I/O control (<literal>ioctl</literal>) commands,
memory mapping, and device polling. See <xref linkend="character-21002" /> for more information.</para>
<para><indexterm><primary>I/O</primary><secondary>byte stream</secondary></indexterm>The main task of any device driver is to perform I/O, and many
character device drivers do what is called <emphasis>byte-stream</emphasis> or <emphasis>character</emphasis> I/O. The driver transfers data to and from the device
without using a specific device address. This type of transfer is in contrast
to block device drivers, where part of the file system request identifies
a specific location on the device.</para>
<para>The <citerefentry><refentrytitle>read</refentrytitle><manvolnum>9E</manvolnum></citerefentry> and <citerefentry><refentrytitle>write</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry points handle byte-stream
I/O for standard character drivers. See <xref linkend="character-25379" /> for more information.</para>
<para>The following table lists additional entry points that can be used by
character device drivers. For other entry points, see <xref linkend="eqbwb" />.</para>
<table frame="topbot" pgwide="1" xml:id="eqbrf">
<title>Additional Entry Points for Character Drivers</title>
<tgroup cols="3" colsep="0" rowsep="0">
	<colspec colwidth="26.05*"/>
	<colspec colname="colspec4" colwidth="10.65*"/>
	<colspec colname="colspec0" colwidth="54.75*"/>
	<thead>
		<row rowsep="1">
			<entry><para>Entry Point</para></entry>
			<entry><para>Usage</para></entry>
			<entry><para>Description</para></entry>
		</row>
	</thead>
	<tbody>
		<row>
			<entry><para><citerefentry><refentrytitle>chpoll</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Polls events for a non-STREAMS character driver. Additional information: <xref linkend="character-11313" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry>
				<para>Performs a range of I/O commands for character drivers. <function>ioctl</function> routines must make sure that user data is copied into or out of the kernel address space explicitly using <citerefentry><refentrytitle>copyin</refentrytitle><manvolnum>9F</manvolnum></citerefentry>, <citerefentry><refentrytitle>copyout</refentrytitle><manvolnum>9F</manvolnum></citerefentry>, <citerefentry><refentrytitle>ddi_copyin</refentrytitle><manvolnum>9F</manvolnum></citerefentry>, and <citerefentry><refentrytitle>ddi_copyout</refentrytitle><manvolnum>9F</manvolnum></citerefentry>, as appropriate. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="character-22" /></para></listitem>
					<listitem><para><xref linkend="gld-ioctl" /></para></listitem>
					<listitem><para><xref linkend="lp64-79" /></para></listitem>
				</itemizedlist>
			</entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>read</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry>
				<para>Reads data from a device. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="character-15613" /></para></listitem>
					<listitem><para><xref linkend="character-11" /></para></listitem>
					<listitem><para><xref linkend="character-12" /></para></listitem>
					<listitem><para><xref linkend="character-35745" /></para></listitem>
					<listitem><para><xref linkend="scsi-5" /></para></listitem>
				</itemizedlist>
			</entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>segmap</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry>
				<para>Maps device memory into user space. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="devmap-1" /></para></listitem>
					<listitem><para><xref linkend="devmap-6" /></para></listitem>
					<listitem><para><xref linkend="devcnmgt-9" /></para></listitem>
				</itemizedlist>
			</entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>write</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry>
				<para>Writes data to a device. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="devaccess-23" /></para></listitem>
					<listitem><para><xref linkend="character-15613" /></para></listitem>
					<listitem><para><xref linkend="character-11" /></para></listitem>
					<listitem><para><xref linkend="character-12" /></para></listitem>
					<listitem><para><xref linkend="character-35745" /></para></listitem>
					<listitem><para><xref linkend="scsi-5" /></para></listitem>
				</itemizedlist>
			</entry>
		</row>
	</tbody>
</tgroup>
</table>
</sect2>
<sect2 xml:id="eqbvd">
<title>Entry Points for STREAMS Device Drivers</title>
<para><indexterm xml:id="drvovr-ix107"><primary>STREAMS</primary><secondary>drivers</secondary></indexterm>STREAMS is a separate programming model for writing a character
driver. Devices that receive data asynchronously, such as terminal and network
devices, are suited to a STREAMS implementation. STREAMS device drivers must
provide the loading and autoconfiguration support described in <xref linkend="autoconf-17" />.
See the <olink targetdoc="streams" remap="external"><citetitle remap="book">STREAMS Programming Guide</citetitle></olink> for additional information on how to write STREAMS
drivers.</para>
<para>The following table lists additional entry points that can be used by
STREAMS device drivers. For other entry points, see <xref linkend="eqbwb" /> and <xref linkend="eqbuw" />.</para>
<table frame="topbot" pgwide="1" xml:id="eqbrm">
<title>Entry Points for STREAMS Drivers</title>
<tgroup cols="3" colsep="0" rowsep="0">
	<colspec colwidth="26.15*"/>
	<colspec colname="colspec6" colwidth="10.52*"/>
	<colspec colname="colspec0" colwidth="54.70*"/>
	<thead>
		<row rowsep="1">
			<entry><para>Entry Point</para></entry>
			<entry><para>Usage</para></entry>
			<entry><para>Description</para></entry>
		</row>
	</thead>
	<tbody>
		<row>
			<entry><para><citerefentry><refentrytitle>put</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>See Description</para></entry>
			<entry><para>Coordinates the passing of messages from one queue to the next queue in a stream. Required, except for the side of the driver that reads data. Additional information: <olink targetdoc="streams" remap="external"><citetitle remap="book">STREAMS Programming Guide</citetitle></olink></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>srv</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Manipulate messages in a queue. Additional information: <olink targetdoc="streams" remap="external"><citetitle remap="book">STREAMS Programming Guide</citetitle></olink></para></entry>
		</row>
	</tbody>
</tgroup>
</table>
</sect2>
<sect2 xml:id="eqbuf">
<title>Entry Points for Memory Mapped Devices</title>
<para><indexterm xml:id="drvovr-ix101"><primary>device memory</primary><secondary>mapping</secondary></indexterm><indexterm xml:id="drvovr-ix102"><primary>memory mapping</primary><secondary>device memory management</secondary></indexterm>For certain devices,
such as frame buffers, providing application programs with direct access to
device memory is more efficient than byte-stream I/O. Applications can map
device memory into their address spaces using the <citerefentry><refentrytitle>mmap</refentrytitle><manvolnum>2</manvolnum></citerefentry> system call. To support memory mapping, device drivers
implement <citerefentry><refentrytitle>segmap</refentrytitle><manvolnum>9E</manvolnum></citerefentry> and <citerefentry><refentrytitle>devmap</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry points.
For information on <citerefentry><refentrytitle>devmap</refentrytitle><manvolnum>9E</manvolnum></citerefentry>,
see <xref linkend="devmap-24338" />. For information on <citerefentry><refentrytitle>segmap</refentrytitle><manvolnum>9E</manvolnum></citerefentry>, see <xref linkend="character-21002" />.</para>
<para>Drivers that define the <citerefentry><refentrytitle>devmap</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry point usually do not
define <citerefentry><refentrytitle>read</refentrytitle><manvolnum>9E</manvolnum></citerefentry> and <citerefentry><refentrytitle>write</refentrytitle><manvolnum>9E</manvolnum></citerefentry> entry points, because application
programs perform I/O directly to the devices after calling <citerefentry><refentrytitle>mmap</refentrytitle><manvolnum>2</manvolnum></citerefentry>.</para>
<para>The following table lists additional entry points that can be used by
character device drivers that use the <literal>devmap</literal> framework
to perform memory mapping. For other entry points, see <xref linkend="eqbwb" /> and <xref linkend="eqbuw" />.</para>
<table frame="topbot" pgwide="1" xml:id="eptyo">
<title>Entry Points for Character Drivers That Use <literal>devmap</literal> for Memory Mapping</title>
<tgroup cols="3" colsep="0" rowsep="0">
	<colspec colwidth="26.06*"/>
	<colspec colname="colspec5" colwidth="10.65*"/>
	<colspec colname="colspec0" colwidth="54.76*"/>
	<thead>
		<row rowsep="1">
			<entry><para>Entry Point</para></entry>
			<entry><para>Usage</para></entry>
			<entry><para>Description</para></entry>
		</row>
	</thead>
	<tbody>
		<row>
			<entry><para><citerefentry><refentrytitle>devmap</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Validates and translates virtual mapping for a memory-mapped device. Additional information: <xref linkend="devmap-1" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>devmap_access</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Notifies drivers when an access is made to a mapping with validation or protection problems. Additional information: <xref linkend="devcnmgt-15" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>devmap_contextmgt</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Performs device context switching on a mapping. Additional information: <xref linkend="devcnmgt-16" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>devmap_dup</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Duplicates a device mapping. Additional information: <xref linkend="devcnmgt-17" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>devmap_map</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Creates a device mapping. Additional information: <xref linkend="devcnmgt-14" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>devmap_unmap</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Cancels a device mapping. Additional information: <xref linkend="devcnmgt-18" /></para></entry>
		</row>
	</tbody>
</tgroup>
</table>
</sect2>
<sect2 xml:id="eqbwc">
<title>Entry Points for the Generic LAN Device (GLD) Driver</title>
<para>The following table lists additional entry points that can be used by
the general LAN driver (GLD). For more information on GLD drivers, see the <citerefentry><refentrytitle>gld</refentrytitle><manvolnum>9E</manvolnum></citerefentry>, <citerefentry><refentrytitle>gld</refentrytitle><manvolnum>7D</manvolnum></citerefentry>, and <citerefentry><refentrytitle>gld_mac_info</refentrytitle><manvolnum>9S</manvolnum></citerefentry> man pages. For other entry
points, see <xref linkend="eqbwb" /> and <xref linkend="eqbuw" />.</para>
<table frame="topbot" pgwide="1" xml:id="epubo">
<title>Additional Entry Points for the Generic LAN Driver</title>
<tgroup cols="3" colsep="0" rowsep="0">
	<colspec colwidth="26.11*"/>
	<colspec colname="colspec7" colwidth="10.62*"/>
	<colspec colname="colspec0" colwidth="54.79*"/>
	<thead>
		<row rowsep="1">
			<entry><para>Entry Point</para></entry>
			<entry><para>Usage</para></entry>
			<entry><para>Description</para></entry>
		</row>
	</thead>
	<tbody>
		<row>
			<entry><para><citerefentry><refentrytitle>gldm_get_stats</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Gathers statistics from private counters in a generic LAN driver. Updates the <citerefentry><refentrytitle>gld_stats</refentrytitle><manvolnum>9S</manvolnum></citerefentry> structure. Additional information: <xref linkend="gld-10" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>gldm_intr</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>See Description</para></entry>
			<entry><para>Receives calls for potential interrupts to a generic LAN driver (GLD). Required if <citerefentry><refentrytitle>gld_intr</refentrytitle><manvolnum>9F</manvolnum></citerefentry> is used as interrupt handler. Additional information: <xref linkend="gld-8" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>gldm_ioctl</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Implements device-specific commands for a generic LAN driver (GLD). Additional information: <xref linkend="gld-11" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>gldm_reset</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Resets a generic LAN driver (GLD) to the initial state. Additional information: <xref linkend="gld-1a" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>gldm_send</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Queues a packet to a generic LAN driver (GLD) for transmission. Additional information: <xref linkend="gld-7" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>gldm_set_mac_addr</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Sets the physical address that the generic LAN driver (GLD) uses to receive data. Additional information: <xref linkend="gld-4" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>gldm_set_multicast</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Enables and disables device-level reception of specific multicast addresses for generic LAN driver (GLD). Additional information: <xref linkend="gld-5" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>gldm_set_promiscuous</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Enables and disables promiscuous mode for a generic LAN driver (GLD) to receive packets on the medium. Additional information: <xref linkend="gld-6" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>gldm_start</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Enables a generic LAN driver (GLD) to generate interrupts. Prepares the driver to call <citerefentry><refentrytitle>gld_recv</refentrytitle><manvolnum>9F</manvolnum></citerefentry> to deliver received data packets. Additional information: <xref linkend="gld-2" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>gldm_stop</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Disables a generic LAN driver (GLD) from generating interrupts and from calling <citerefentry><refentrytitle>gld_recv</refentrytitle><manvolnum>9F</manvolnum></citerefentry>. Additional information: <xref linkend="gld-3" /></para></entry>
		</row>
	</tbody>
</tgroup>
</table>
</sect2>
<sect2 xml:id="eqbsr">
<title>Entry Points for SCSI HBA Drivers</title>
<para>The following table lists additional entry points that can be used by
SCSI HBA device drivers. For information on the SCSI HBA transport structure,
see <citerefentry><refentrytitle>scsi_hba_tran</refentrytitle><manvolnum>9S</manvolnum></citerefentry>. For other entry points, see <xref linkend="eqbwb" /> and <xref linkend="eqbuw" />.</para>
<table frame="topbot" pgwide="1" xml:id="epubx">
<title>Additional Entry Points for SCSI HBA Drivers</title>
<tgroup cols="3" colsep="0" rowsep="0">
	<colspec colwidth="17.50*"/>
	<colspec colname="colspec8" colwidth="7.50*"/>
	<colspec colname="colspec0" colwidth="37.28*"/>
	<thead>
		<row rowsep="1">
			<entry><para>Entry Point</para></entry>
			<entry><para>Usage</para></entry>
			<entry><para>Description</para></entry>
		</row>
	</thead>
	<tbody>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_abort</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Aborts a specified SCSI command that has been transported to a SCSI Host Bus Adapter (HBA) driver. Additional information: <xref linkend="scsihba-84" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_bus_reset</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Resets a SCSI bus. Additional information: <xref linkend="scsihba-9" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_destroy_pkt</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Frees resources that are allocated for a SCSI packet.  Additional information: <xref linkend="scsihba-66" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_dmafree</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Frees DMA resources that have been allocated for a SCSI packet. Additional information: <xref linkend="scsihba-70" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_getcap</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Gets the current value of a specific capability that is provided by the HBA driver. Additional information: <xref linkend="scsihba-79" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_init_pkt</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Allocate and initialize resources for a SCSI packet.  Additional information: <xref linkend="scsihba-56" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_quiesce</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Stop all activity on a SCSI bus, typically for dynamic reconfiguration. Additional information: <xref linkend="scsihba-96" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_reset</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Resets a SCSI bus or target device. Additional information: <xref linkend="scsihba-85" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_reset_notify</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Requests notification of a SCSI target device for a bus reset. Additional information: <xref linkend="scsihba-86" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_setcap</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Sets the value of a specific capability that is provided by the SCSI HBA driver. Additional information: <xref linkend="scsihba-81" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_start</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Requests the transport of a SCSI command. Additional information: <xref linkend="scsihba-73" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_sync_pkt</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Synchronizes the view of data by an HBA driver or device. Additional information: <xref linkend="scsihba-68" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_tgt_free</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry>
				<para>Requests allocated SCSI HBA resources to be freed on behalf of a target device. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="scsihba-55" /></para></listitem>
					<listitem><para><xref linkend="scsihba-27" /></para></listitem>
				</itemizedlist>
			</entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_tgt_init</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry>
				<para>Requests SCSI HBA resources to be initialized on behalf of a target device. Additional information:</para>
				<itemizedlist>
					<listitem><para><xref linkend="scsihba-53" /></para></listitem>
					<listitem><para><xref linkend="scsihba-22" /></para></listitem>
				</itemizedlist>
			</entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_tgt_probe</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Probes a specified target on a SCSI bus. Additional information: <xref linkend="scsihba-54" /></para></entry>
		</row>
		<row>
			<entry><para><citerefentry><refentrytitle>tran_unquiesce</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Optional</para></entry>
			<entry><para>Resumes I/O activity on a SCSI bus after <citerefentry><refentrytitle>tran_quiesce</refentrytitle><manvolnum>9E</manvolnum></citerefentry> has been called, typically for dynamic reconfiguration. Additional information: <xref linkend="scsihba-96" /></para></entry>
		</row>
	</tbody>
</tgroup>
</table>
</sect2>
<sect2 xml:id="eqbwn">
<title>Entry Points for PC Card Drivers</title>
<para>The following table lists additional entry points that can be used by
PC Card device drivers. For other entry points, see <xref linkend="eqbwb" /> and <xref linkend="eqbuw" />.</para>
<table frame="topbot" pgwide="1" xml:id="eqbsv">
<title>Entry Points for PC Card Drivers Only</title>
<tgroup cols="3" colsep="0" rowsep="0">
	<colspec colwidth="26.28*"/>
	<colspec colname="colspec10" colwidth="10.39*"/>
	<colspec colname="colspec0" colwidth="54.70*"/>
	<thead>
		<row rowsep="1">
			<entry><para>Entry Point</para></entry>
			<entry><para>Usage</para></entry>
			<entry><para>Description</para></entry>
		</row>
	</thead>
	<tbody>
		<row>
			<entry><para><citerefentry><refentrytitle>csx_event_handler</refentrytitle><manvolnum>9E</manvolnum></citerefentry></para></entry>
			<entry><para>Required</para></entry>
			<entry><para>Handles events for a PC Card driver. The driver must call the <citerefentry><refentrytitle>csx_RegisterClient</refentrytitle><manvolnum>9F</manvolnum></citerefentry> function explicitly to set the entry point instead of using a structure field like <varname role="structname">cb_ops</varname>.</para></entry>
		</row>
	</tbody>
</tgroup>
</table>
</sect2>
</sect1>
<sect1 xml:id="kernelovr-41">
<title>Considerations in Device Driver Design</title>
<para>A device driver must be compatible with illumos, both as a consumer
and provider of services. This section discusses the following issues, which
should be considered in device driver design:</para>
<itemizedlist>
	<listitem><para><xref linkend="kernelovr-3a" /></para></listitem>
	<listitem><para><xref linkend="drvovr-28" /></para></listitem>
	<listitem><para><xref linkend="drvovr-29" /></para></listitem>
	<listitem><para><xref linkend="drvovr-30" /></para></listitem>
	<listitem><para><xref linkend="drvovr-31" /></para></listitem>
</itemizedlist>
<sect2 xml:id="kernelovr-3a">
<title>DDI/DKI Facilities</title>
<para><indexterm xml:id="eqiuq"><primary>DDI/DKI</primary><secondary>design considerations</secondary></indexterm>The illumos DDI/DKI interfaces are provided for driver
portability. With DDI/DKI, developers can write driver code in a standard
fashion without having to worry about hardware or platform differences. This
section describes aspects of the DDI/DKI interfaces.</para>
<sect3 xml:id="kernelovr-52">
<title>Device IDs</title>
<para>The DDI interfaces enable drivers to provide a persistent, unique identifier
for a device. The device ID can be used to identify or locate a device. The
ID is independent of the device's name or number (<literal>dev_t</literal>).
Applications can use the functions defined in <citerefentry><refentrytitle>libdevid</refentrytitle><manvolnum>3LIB</manvolnum></citerefentry> to read and manipulate
the device IDs registered by the drivers.</para>
</sect3>
<sect3 xml:id="kernelovr-60">
<title>Device Properties</title>
<indexterm xml:id="drvovr-ix157"><primary>properties</primary><secondary>overview</secondary>
</indexterm><para>The attributes of a device or device driver are specified by <emphasis>properties</emphasis>. A property is a name-value pair. The name is a string that identifies
the property with an associated value. Properties can be defined by the FCode
of a self-identifying device, by a hardware configuration file (see the <citerefentry><refentrytitle>driver.conf</refentrytitle><manvolnum>4</manvolnum></citerefentry> man page),
or by the driver itself using the <citerefentry><refentrytitle>ddi_prop_update</refentrytitle><manvolnum>9F</manvolnum></citerefentry> family of routines.</para>
</sect3>
<sect3 xml:id="kernelovr-50">
<title>Interrupt Handling</title>
<indexterm xml:id="drvovr-ix130"><primary>interrupt handling</primary><secondary>overview</secondary>
</indexterm><para>The DDI/DKI addresses the following aspects of device interrupt handling:</para><itemizedlist><listitem><para>Registering device interrupts with the system</para>
</listitem><listitem><para>Removing device interrupts</para>
</listitem><listitem><para>Dispatching interrupts to interrupt handlers</para>
</listitem>
</itemizedlist><para><indexterm xml:id="drvovr-ix131"><primary>interrupt property</primary><secondary>definition</secondary></indexterm>Device interrupt sources are
contained in a property called <emphasis>interrupt</emphasis>, which is either
provided by the PROM of a self-identifying device, in a hardware configuration
file, or by the booting system on the x86 platform.</para>
</sect3><sect3 xml:id="kernelovr-51"><title>Callback Functions</title><para>Certain DDI mechanisms provide a <emphasis>callback</emphasis> mechanism.
DDI functions provide a mechanism for scheduling a callback when a condition
is met. Callback functions can be used for the following typical conditions:</para><itemizedlist><listitem><para>A transfer has completed</para>
</listitem><listitem><para>A resource has become available</para>
</listitem><listitem><para>A time-out period has expired</para>
</listitem>
</itemizedlist><para><indexterm xml:id="drvovr-ix129"><primary>callback functions</primary><secondary>description of</secondary></indexterm>Callback functions are somewhat
similar to entry points, for example, interrupt handlers. DDI functions that
allow callbacks expect the callback function to perform certain tasks. In
the case of DMA routines, a callback function must return a value indicating
whether the callback function needs to be rescheduled in case of a failure.</para><para>Callback functions execute as a separate interrupt thread. Callbacks
must handle all the usual multithreading issues.</para><note><para>A driver must cancel all scheduled callback functions before detaching
a device.</para>
</note>
</sect3><sect3 xml:id="kernelovr-53"><title>Software State Management</title><para><indexterm><primary>state structure</primary></indexterm>To assist device
driver writers in allocating state structures, the DDI/DKI provides a set
of memory management routines called the <emphasis>software state management
routines</emphasis>, also known as the <emphasis>soft-state routines</emphasis>.
These routines dynamically allocate, retrieve, and destroy memory items of
a specified size, and hide the details of list management. An <emphasis>instance
number</emphasis> is used to identify the desired memory item. This number
is typically the instance number assigned by the system.</para><para>Routines are provided for the following tasks:</para><itemizedlist><listitem><para>Initialize a driver's soft-state list</para>
</listitem><listitem><para>Allocate space for an instance of a driver's soft state</para>
</listitem><listitem><para>Retrieve a pointer to an instance of a driver's soft state</para>
</listitem><listitem><para>Free the memory for an instance of a driver's soft state</para>
</listitem><listitem><para>Finish using a driver's soft-state list</para>
</listitem>
</itemizedlist>
<para>See <xref linkend="autoconf-95548" /> for an example of how to use these routines.</para>
</sect3>
<sect3 xml:id="kernelovr-54">
<title>Programmed I/O Device Access</title>
<para>Programmed I/O device access is the act of reading and writing of device
registers or device memory by the host CPU. The illumos DDI provides interfaces
for mapping a device's registers or memory by the kernel as well as interfaces
for reading and writing to device memory from the driver. These interfaces
enable drivers to be developed that are platform and bus independent, by automatically
managing any difference in device and host endianness as well as by enforcing
any memory-store sequence requirements imposed by the device.</para>
</sect3>
<sect3 xml:id="kernelovr-55">
<title>Direct Memory Access (DMA)</title>
<para>The illumos platform defines a high-level, architecture-independent
model for supporting DMA-capable devices.  The illumos DDI shields drivers
from platform-specific details. This concept enables a common driver to run
on multiple platforms and architectures.</para>
</sect3>
<sect3 xml:id="eqiup">
<title>Layered Driver Interfaces</title>
<para>The DDI/DKI provides a group of interfaces referred to as layered device
interfaces (LDI). These interfaces enable a device to be accessed from within
the illumos kernel. This capability enables developers to write applications
that observe kernel device usage. For example, both the <citerefentry><refentrytitle>prtconf</refentrytitle><manvolnum>1M</manvolnum></citerefentry> and <citerefentry><refentrytitle>fuser</refentrytitle><manvolnum>1M</manvolnum></citerefentry> commands use LDI to enable
system administrators to track aspects of device usage. The LDI is covered
in more detail in <xref linkend="ldi-1" />.</para>
</sect3>
</sect2>
<sect2 xml:id="drvovr-28">
<title>Driver Context</title>
<para><indexterm xml:id="drvovr-ix141"><primary>context of device driver</primary></indexterm><indexterm><primary>device drivers</primary><secondary>context</secondary></indexterm>The driver context refers to the condition under which a driver
is currently operating. The context limits the operations that a driver can
perform. The driver context depends on the executing code that is invoked.
Driver code executes in four contexts:</para>
<itemizedlist>
	<listitem>
		<para><emphasis role="strong">User context</emphasis>. A driver
			entry point has <emphasis>user context</emphasis> when invoked by a user thread
			in a synchronous fashion. That is, the user thread waits for the system to
			return from the entry point that was invoked. For example, the
			<citerefentry><refentrytitle>read</refentrytitle><manvolnum>9E</manvolnum></citerefentry>
			entry point of the driver has user context when invoked by a
			<citerefentry><refentrytitle>read</refentrytitle><manvolnum>2</manvolnum></citerefentry>
			system call. In this case, the driver has access to the user area for copying data into and
			out of the user thread.</para>
	</listitem>
	<listitem>
		<para><emphasis role="strong">Kernel context</emphasis>. A driver
			function has <emphasis>kernel context</emphasis> when invoked by some part
			of the kernel. In a block device driver, the
			<citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry>
			entry point can be called by the <literal>pageout</literal> daemon to write pages to the device. Because
			the page daemon has no relation to the current user thread,
			<citerefentry><refentrytitle>strategy</refentrytitle><manvolnum>9E</manvolnum></citerefentry>
			has kernel context in this case.</para>
	</listitem>
	<listitem>
		<para><emphasis role="strong">Interrupt context</emphasis>.
			<emphasis>Interrupt context</emphasis> is a more restrictive form of kernel context. Interrupt
			context is invoked as a result of the servicing of an interrupt. Driver interrupt
			routines operate in interrupt context with an associated interrupt level.
			Callback routines also operate in an interrupt context. See <xref linkend="interrupt-15678" /> for
			more information.</para>
	</listitem>
	<listitem>
		<para><emphasis role="strong">High-level interrupt context</emphasis>.
			<emphasis>High-level interrupt context</emphasis> is a more restricted form of interrupt context. If
			<citerefentry><refentrytitle>ddi_intr_hilevel</refentrytitle><manvolnum>9F</manvolnum></citerefentry>
			indicates that an interrupt is high level, the driver interrupt handler runs in high-level interrupt
			context. See <xref linkend="interrupt-15678" /> for more information.</para>
	</listitem>
</itemizedlist>
<para>The manual pages in section 9F document the allowable contexts for each
function.  For example, in kernel context the driver must not call <citerefentry><refentrytitle>copyin</refentrytitle><manvolnum>9F</manvolnum></citerefentry>.</para>
</sect2>
<sect2 xml:id="drvovr-29">
<title>Returning Errors</title>
<para><indexterm xml:id="gfrah"><primary>device drivers</primary><secondary>printing messages</secondary></indexterm><indexterm xml:id="gfram"><primary>error messages, printing</primary></indexterm><indexterm xml:id="gfrau"><primary>printing messages</primary></indexterm><indexterm xml:id="gfrbq"><primary><function>cmn_err</function> function</primary><secondary>description of</secondary></indexterm>Device drivers do not usually
print messages, except for unexpected errors such as data corruption. Instead,
the driver entry points should return error codes so that the application
can determine how to handle the error. Use the <citerefentry><refentrytitle>cmn_err</refentrytitle><manvolnum>9F</manvolnum></citerefentry> function to write messages
to a system log that can then be displayed on the console.</para><para>The format string specifier interpreted by <citerefentry><refentrytitle>cmn_err</refentrytitle><manvolnum>9F</manvolnum></citerefentry> is similar to the <citerefentry><refentrytitle>printf</refentrytitle><manvolnum>3C</manvolnum></citerefentry> format
string specifier, with the addition of the format <literal>%b</literal>, which
prints bit fields. The first character of the format string can have a special
meaning. Calls to <citerefentry><refentrytitle>cmn_err</refentrytitle><manvolnum>9F</manvolnum></citerefentry> also specify the message <replaceable>level</replaceable>, which indicates the severity label to be printed. See the <citerefentry><refentrytitle>cmn_err</refentrytitle><manvolnum>9F</manvolnum></citerefentry> man page
for more details.</para><para>The level <literal>CE_PANIC</literal> has the side effect of crashing
the system. This level should be used only if the system is in such an unstable
state that to continue would cause more problems. The level can also be used
to get a system core dump when debugging. <literal>CE_PANIC</literal> should
not be used in production device drivers.</para>
</sect2><sect2 xml:id="drvovr-30"><title>Dynamic Memory Allocation</title><para><indexterm xml:id="drvovr-ix146"><primary>kernel</primary><secondary>memory</secondary><tertiary>allocation</tertiary></indexterm>Device drivers must be prepared
to simultaneously handle all attached devices that the drivers claim to drive.
The number of devices that the driver handles should not be limited. All per-device
information must be dynamically allocated. </para><para><literal>void *kmem_alloc(size_t size, int flag);</literal></para>
<para><indexterm xml:id="drvovr-ix147"><primary>dynamic memory allocation</primary></indexterm><indexterm xml:id="drvovr-ix148"><primary><function>kmem_alloc</function> function</primary></indexterm><indexterm xml:id="drvovr-ix149"><primary>memory allocation</primary><secondary>description of</secondary></indexterm>The standard kernel memory
allocation routine is <citerefentry><refentrytitle>kmem_alloc</refentrytitle><manvolnum>9F</manvolnum></citerefentry>. <function>kmem_alloc</function> is similar to the
C library routine <citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>3C</manvolnum></citerefentry>,
with the addition of the <literal>flag</literal> argument. The <literal>flag</literal> argument
can be either <literal>KM_SLEEP</literal> or <literal>KM_NOSLEEP</literal>,
indicating whether the caller is willing to block if the requested size is
not available. If <literal>KM_NOSLEEP</literal> is set and memory is not available, <citerefentry><refentrytitle>kmem_alloc</refentrytitle><manvolnum>9F</manvolnum></citerefentry> returns <literal>NULL</literal>. </para><para><citerefentry><refentrytitle>kmem_zalloc</refentrytitle><manvolnum>9F</manvolnum></citerefentry> is similar to <citerefentry><refentrytitle>kmem_alloc</refentrytitle><manvolnum>9F</manvolnum></citerefentry>, but also clears the contents
of the allocated memory.</para>
<note><para>Kernel memory is a limited resource, not pageable, and competes
with user applications and the rest of the kernel for physical memory. Drivers
that allocate a large amount of kernel memory can cause system performance
to degrade.</para>
</note>
<para><literal>void kmem_free(void *cp, size_t size);</literal></para>
<para>Memory allocated by <citerefentry><refentrytitle>kmem_alloc</refentrytitle><manvolnum>9F</manvolnum></citerefentry> or by <citerefentry><refentrytitle>kmem_zalloc</refentrytitle><manvolnum>9F</manvolnum></citerefentry> is returned to the system with <citerefentry><refentrytitle>kmem_free</refentrytitle><manvolnum>9F</manvolnum></citerefentry>. <function>kmem_free</function> is similar to the C library routine <citerefentry><refentrytitle>free</refentrytitle><manvolnum>3C</manvolnum></citerefentry>, with the addition of the <literal>size</literal> argument.
Drivers <emphasis>must</emphasis> keep track of the size of each allocated
object in order to call <citerefentry><refentrytitle>kmem_free</refentrytitle><manvolnum>9F</manvolnum></citerefentry> later.</para>
</sect2><sect2 xml:id="drvovr-31"><title>Hotplugging</title><indexterm><primary>hotplugging</primary>
</indexterm><indexterm><primary>hot-plug</primary><see>hotplugging</see>
</indexterm><indexterm><primary>hotpluggable drivers</primary><see>hotplugging</see>
</indexterm><para><indexterm><primary>SCSI HBA driver</primary><secondary sortas="hotplug">and hotplugging</secondary></indexterm><indexterm><primary>hotplugging</primary><secondary>and SCSI HBA driver</secondary></indexterm>This manual does not
highlight hotplugging information. If you follow the rules and suggestions
for writing device drivers given in this book, your driver should be able
to handle hotplugging.  In particular, make sure that both autoconfiguration
(see <xref linkend="autoconf-17" />)
and <citerefentry><refentrytitle>detach</refentrytitle><manvolnum>9E</manvolnum></citerefentry> work
correctly in your driver.  In addition, if you are designing a driver that
uses power management, you should follow the information given in <xref linkend="powermgt-37437" />. SCSI
HBA drivers might need to add a <varname role="structname">cb_ops</varname> structure
to their <varname role="structname">dev_ops</varname> structure (see <xref linkend="scsihba-32898" />)
to take advantage of hotplugging capabilities.</para><para>Previous versions of the Solaris OS required hotpluggable drivers to
include a <property>DT_HOTPLUG</property> property, but this property
is no longer required. Driver writers are free, however, to include and use
the <property>DT_HOTPLUG</property> property as they see fit.</para>
</sect2>
</sect1>
</chapter>
